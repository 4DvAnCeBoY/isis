<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./src/docbkx/dtd-4.5/docbookx.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para><emphasis>Apache Isis</emphasis> is designed to allow programmers
    rapidly develop domain-driven applications following the <ulink
    url="http://en.wikipedia.org/wiki/Naked_Objects">Naked Objects</ulink>
    pattern. It is made up of a core framework that supports supports various
    viewers, along with <acronym>API</acronym>s and implementations relating
    to security, the programming model, the runtime (persistence) and profile
    stores (user preferences). <emphasis>Apache Isis</emphasis> is hosted at
    the <ulink url="http://incubator.apache.org/isis">Apache
    Foundation</ulink>, and is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>

    <para>The role of a runtime is to bootstrap the application and
    components, and to manage the lifecycle of domain object entities.
    Typically, this means managing their persistence and identity. In the case
    of the default runtime, it also means providing support for client/server
    remoting.</para>

    <sect1>
      <title>Who this Guide is For</title>

      <para>This guide is written for deployers looking to configure
      <emphasis>Isis</emphasis> to run using the default runtime, in any of
      the supported configurations. It is divided into the following
      parts:<itemizedlist>
          <listitem>
            <para>Core Concepts</para>

            <para>The chapters in this part of the guide <xref
            linkend="prt.CoreConcepts" /> describe the core concepts
            underpinning the design of the <emphasis>default
            runtime</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Runtime Modules</para>

            <para>This part of the guide *** has chapters for each of the
            modules that make up the <emphasis>default
            runtime</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Deployment</para>

            <para>The chapters in this part of the guide *** describe
            different ways to deploy an Isis application using the
            <emphasis>default runtime</emphasis>.</para>
          </listitem>
        </itemizedlist></para>
    </sect1>

    <sect1>
      <title>How this Guide relates to other Documentation</title>

      <para>The <emphasis>core</emphasis> documentation
      <package>[oai:core]</package> describes common modules, including
      reusable classes that make up the <emphasis>core runtime</emphasis>
      <package>[oai.core:runtime]</package>. This module, the default runtime,
      makes use of these classes, as well as other components. It also defines
      a number of its own <acronym>sub-API</acronym>s.</para>
    </sect1>
  </preface>

  <part id="prt.CoreConcepts">
    <title>Core Concepts</title>

    <chapter>
      <title>Core Concepts</title>

      <para></para>

      <sect1>
        <title>IsisContext</title>

        <para><emphasis>Context</emphasis></para>

        <para>The ObjectAdapterContext provide access to the main components
        of the NOF. If the system is started in a multi-user mode then the
        context will hold specific components for specific execution contexts,
        allowing the same process to access the same components and different
        processes to access unique instances.</para>

        <para>Each execution context will have its own Persistor, Message
        Broker and Update Notifier.</para>

        <para>The Reflector and Configuration are shared among all execution
        contexts.</para>

        <para><emphasis>Persistor</emphasis></para>

        <para>During startup the persistor is given a set of service objects.
        During intialisation the persistor must determine the OIDs for these
        service objects. If the persistor does not know about a service (by
        its ID) from a previous run then it must generate an OID for the
        service and persist that with the ID of the service. This allows
        references to be held persistently to service objects despite the fact
        that they are singletons.</para>

        <para></para>

        <para><emphasis>Identity map</emphasis></para>

        <para>Any object that has identity (whether it is persisted or not)
        must be registered with the identity map. This maps two relationships:
        domain objects to proxies and OIDs to proxies.</para>

        <para>Whenever a domain object is handled by the system, and before a
        proxy is created, it must be checked against the identity map and if
        it exists the proxy already in the identity map must be used instead
        of creating a new proxy.</para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Installers and
        <filename>installer-registry.properties</filename></title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Scopes</title>

        <para></para>

        <para></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/architecture.gif" scale="30" />
          </imageobject>
        </mediaobject>

        <para></para>
      </sect1>

      <sect1>
        <title>Update Notifier (Change Listener)</title>

        <para></para>

        <para>Changes to objects are collected by the
        <classname>UpdateNotifier</classname> object once they have been
        persisted. These changes can then be asynchronously accessed by a
        client to keep it in sync with the underlying model. Once changes are
        retrieved by client the notifier resets its collection so that changes
        are only available once.</para>

        <para>Within the framework, specifically the persistor, when objects
        changes and deletions are persisted the notifier should be informed
        via its <methodname>addChangedObject(ObjectAdapter)</methodname> and
        <methodname>addDisposedObject(ObjectAdapter)</methodname>
        methods.</para>

        <para>Clients should use the
        <methodname>allChangedObjects()</methodname> and
        <methodname>allDisposedObjects()</methodname> to get an
        <classname>Enumeration</classname> of the changes.</para>

        <para>The notifier itself can be got from system context using
        <methodname>IsisContext.getUpdateNotifer()</methodname>.</para>

        <para></para>
      </sect1>

      <sect1>
        <title>IdentityMap</title>

        <para></para>

        <para>A persistor should utilise an object-identity map (see Martin
        Fowler's Patterns of Enterprise Application Architecture) to manage
        the mapping of domain objects and adapters, and OIDs and adapters. For
        each domain object the map should store a single adapter, and an OID
        to that same adapter. The persitor can then guarantee that the same
        adapter is always provided for a specific domain object or OID</para>

        <para></para>
      </sect1>

      <sect1>
        <title>Profile Stores</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Exploration vs Prototype Modes</title>

        <para></para>

        <para></para>
      </sect1>
    </chapter>
  </part>

  <part>
    <title>Modules</title>

    <partintro>
      <para></para>

      <para></para>

      <para></para>
    </partintro>

    <chapter>
      <title>Runtime Module</title>

      <para></para>

      <para></para>

      <para>The runtime module is the "engine-room" of the framework, taking
      responsibility to manage domain object (pojo) instances at
      runtime.</para>

      <para>Each pojo is wrapped in an <classname>ObjectAdapter</classname>
      (cf <classname>java.lang.Object</classname>) from which the
      <classname>ObjectSpecification</classname> (cf
      <classname>java.lang.Class</classname>) can be obtained.</para>

      <para>Associated with each <classname>ObjectAdapter</classname> is an
      <classname>Oid</classname>: an opaque serializable identifier to the
      object. The runtime module maintains a 3-way identity map between these,
      allowing forward and reverse lookups.</para>

      <para>The runtime module defines a number of APIs the most important of
      which is the <classname>ObjectStore</classname> API. The runtime module
      manages persistence and transaction demarcation, with the actual storage
      of objects being delegated to an object store implementation.</para>

      <para>The other major API defined by the runtime module security API,
      dealing with authentication and authorization.</para>

      <para>In addition to all the above, the runtime module defines a
      command-line bootstrapper, making it easy to bootstrap Apache Isis from
      a main() or a JUnit test case.</para>

      <para></para>

      <sect1>
        <title>Package Layering / Dependencies</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Services Installer</title>

        <para></para>

        <para>The first thing that happens is the logging is set up so that
        everything can be logged. This attempts to load
        <filename>logging.properties</filename> from the
        <filename>config</filename> directory on the filesystem and if that
        cannot be found it will look for the same file in the same directory
        on the classpath. If neither of these are found then a default logging
        configuration will be programmatically installed that writes to the
        console.</para>

        <para>Now that logging is initialised the container can prepare for
        bootstrapping the system. The first task is load up all the component
        installers, which is done by the InstallerLookupDefault class. This
        reads the <filename>installer-registry.properties</filename> file from
        classpath and attempts to load each class listed. Any class not found
        is logged so it is easy to determine if a component should be
        available. Each installer simply knows how to install a component; the
        component is not loaded at this stage.</para>

        <para>Now the container knows what components are available a series
        of option handlers (<classname>OptionHandler</classname>) are
        intialise, with addtional one provided by the Isis container and web
        server subclasses. These interact with the Apache CLI library to
        provide details about the command line parameters and will lookup the
        available components so they can be listed on the command line help.
        With the handlers set up the command line is parsed using the Apache
        library. If this parse fails then the library generates a error
        message with an option summary and displays via the console and the
        startup process terminates.</para>

        <para>The last step before bootstrapping starts is to prepare the
        ground for using congfiguration properties. Configuration details are
        loaded by a <classname>ConfigurationBuilder</classname> object and
        will be subsequently placed in an immutable
        <classname>IsisConfiguration</classname> object. Immediately after
        this has been created each handler is visited so that it can, via its
        <methodname>primeConfigurationBuilder</methodname> method, add it
        properties to the builder. This way each command line option is
        converted to one or more properties of the same form as can be
        specified in the properties files, hence we only need one way to
        determine how the system is to be run.</para>

        <para>Now that the ground has been prepared it is time for the
        bootstrapping to begin. This is done via a call to the
        <methodname>bootstrapIsis</methodname> method, which is where the
        process differs for the Isis container and the web server.</para>

        <para></para>

        <para>Services are registered with the Framework at startup via the
        properties file, using the services properties. The
        <methodname>services</methodname> property itself dictates which
        service classes are to be instantiated at startup, for example:</para>

        <programlisting format="linespecific">isis.services = com.mycompany.myapp.dom.BookingFactory,\
                com.mycompany.myapp.dom.CustomerFactoryAndRepository, \
                com.mycompany.myapp.dom.LocationFactoryAndRepository</programlisting>

        <para>The <methodname>prefix</methodname> property allows you to
        specify the common package once and, hence omit them from the classes
        in the list. The following set of properties is therefore equivalent
        to the previous example:</para>

        <programlisting format="linespecific">isis.services.prefix = com.mycompany.myapp.dom
isis.services = BookingFactory, CustomerFactoryAndRepository, LocationFactoryAndRepository</programlisting>

        <para></para>
      </sect1>

      <sect1>
        <title>Fixtures Installer</title>

        <para>Fixtures are simple classes that are used to set up a adapter
        objects system. The code for a fixture should be placed in the
        <methodname>install</methodname> method, which is run when the system
        installs the fixtures. Fixtures are only installed if the
        <classname>ObjectAdapterPersistor</classname> flags that it is
        uninitialised via its <methodname>isInitialized</methodname> method.
        For the in memory object store this will be every time it is started,
        and for other object stores will only be when they detect they have no
        persistent data.</para>

        <para></para>

        <para>Fixtures are registered with the Framework at startup via the
        properties file, using the fixtures properties. The
        <methodname>fixtures</methodname> property itself dictates which
        fixture classes are to be instantiated at startup, for example:</para>

        <programlisting format="linespecific">isis.fixtures = fixture.BookingsFixture, fixture.PerspectivesFixture</programlisting>

        <para>The <methodname>prefix</methodname> property allows you specify
        the common package name once and, hence omit them from the classes in
        the list. The following set of properties is therefore equivalent to
        the previous example.</para>

        <programlisting format="linespecific">isis.fixtures.prefix = fixture
isis.fixtures = BookingsFixture, PerspectivesFixture</programlisting>
      </sect1>

      <sect1>
        <title>Persistor</title>

        <para></para>

        <para>The persistor is tasked with managing all of the domain objects
        and ensuring that they can be retrieved in the futures. In addition to
        it more obvious role in the storing of objects the persistor must also
        manage the object that are memory. This second task is known a
        identity mapping and is required to ensure that any domain object only
        ever has one adapter for it. If more than one adapter exists for an
        object then there will be risk that the system has .......</para>

        <para></para>

        <para></para>

        <sect2>
          <title>Creating Adapters</title>

          <para>Numerous methods exist in the persistor (see
          <classname>ObjectAdapterManager</classname>) for creating adapters.
          These methods do three things. First, they insure that there is no
          existing adapter for a domain object or OID, and if there is one
          then that adapter is returned to the caller immediately. Assuming
          there is no existing adapter then a new one is created for the
          domain object and the adapter's OID and resolved state are
          initialised. The OID is typically set to the one provided during the
          reuqest except when a new domain object is being created, in which
          case a new transient OID is created for it. The resolved state
          reflects the type of object and its persistent state. Newly created
          objects end up with <constant>TRANSIENT</constant>, persistent ones
          with <constant>GHOST</constant> and for objects that are aggregated
          the state is intialised to <constant>AGGREGATED (see
          ResolvedState)</constant></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Configuration Loading</title>

        <para>*** explain the principle, how we construct from the "id" of the
        installer.</para>

        <para></para>

        <para></para>

        <para>The configuration file (<filename class="directory"
        moreinfo="none">isis.properties</filename>) needs to specify what
        resources are used by the application and what fixtures to load. These
        details are common to all the modes that the NOF can be run in.
        Additional properties can be also specified for use in specific modes,
        such as database connection details when using the SQL object
        store.</para>

        <para>The configuration file <filename class="directory"
        moreinfo="none">isis.properties</filename> is always picked up. In
        addition other properties files will be picked up, if present, based
        on the type, viewer, persistor and connection command line switches
        with the filename matching the option. E.g.</para>

        <para>-r (or --persistor) hibernate will cause
        <filename>persistor.properties</filename> and <filename
        class="directory"
        moreinfo="none">persistor_hibernate.properties</filename> to be
        used</para>

        <para>-t (or --type) client will cause <filename class="directory"
        moreinfo="none">client.properties</filename> to be used</para>

        <para>-v (or --viewer) dnd will cause
        <filename>viewer.properties</filename> and <filename class="directory"
        moreinfo="none">viewer_dnd.properties</filename> to be used</para>

        <para>-x (or -- connector) xstream-sockets will cause
        <filename>transport.properties</filename>,
        <filename>transport_sockets.properties</filename>,
        <filename>protocol.properties</filename> and
        <filename>protocol_xstream.properties</filename> to be loaded; because
        of the way that connector is implemented it will also load
        <classname>persistor.properties</classname> and <filename
        class="directory"
        moreinfo="none">persistor_xstream-sockets.properties</filename>
        too.</para>

        <para>In addition a particular file can be selected with the -c
        switch. For example</para>

        <para>-c <filename class="directory"
        moreinfo="none">mysettings.properties</filename></para>

        <para></para>

        <sect2>
          <title>Properties file contents</title>

          <para>Each properties file can contain lists of services and
          fixtures as well as any specific settings (e.g. Hibernate setting).
          Services are defined using the
          <methodname>isis.services</methodname> property, fixtures by the
          <methodname>isis.fixtures</methodname> property.</para>

          <para></para>

          <para>As a shortcut you can specify the prefix for all classes
          listed in the <methodname>services</methodname> property using
          <methodname>services.prefix</methodname> and the
          <methodname>fixtures</methodname> property using
          <methodname>fixtures.prefix</methodname>.</para>

          <programlisting format="linespecific"># uncomment to hide splash
#isis.nosplash
isis.locale=en_GB
isis.services.prefix = org.apache.isis.example.expenses
isis.services = resources.ExpenseTypeFactory \
                       , resources.naive.NaiveClaimRepository\
                       , resources.naive.NaiveEmployeeRepository\
                       , resources.naive.NaiveExpenseTypeRepository\
                       , resources.naive.NaiveItemRepository

isis.fixtures.prefix=org.apache.isis.example.expenses.fixture
isis.fixtures=ExpenseTypes, Employees, ExampleClaim, Context</programlisting>

          <para>Other settings that can be set include</para>

          <itemizedlist>
            <listitem>
              <para>isis.nosplash</para>
            </listitem>

            <listitem>
              <para>isis.locale (e.g. en_GB)</para>
            </listitem>
          </itemizedlist>

          <para>See the relevant section for details of settings specific to
          persistence, web viewer etc.</para>

          <para>The <filename class="directory"
          moreinfo="none">logging.properties</filename> file allows control
          over the logging settings. The NOF uses log4j for logging so please
          refer to <ulink
          url="http://logging.apache.org/log4j/docs/documentation.html">Apache</ulink>
          log4j documentation.</para>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Other Properties</title>

        <sect2 id="locale">
          <title>Locale</title>

          <para>The locale that the system works in can be set by the
          following property:</para>

          <programlisting format="linespecific">isis.locale = en_GB</programlisting>

          <para>The locale is specified in two parts separated by an
          underscore.</para>

          <para>The first part is the language and is a valid ISO Language
          Code. These codes are the lower-case, two-letter codes as defined by
          ISO-639. You can find a full list of these codes at a number of
          sites, such as: <ulink
          url="???">http://www.loc.gov/standards/iso639-2/php/English_list.php</ulink>
          The second part is the country and is a valid ISO Country Code.
          These codes are the upper-case, two-letter codes as defined by
          ISO-3166. You can find a full list of these codes at a number of
          sites, such as: <ulink
          url="???">http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html</ulink></para>

          <para>If no underscore is used then the setting is deemed to be the
          language.</para>

          <para>If no locale is specified the system uses the locale specified
          by the operating system.</para>
        </sect2>

        <sect2>
          <title>Time zone</title>

          <para>The time zone that the system works in can be set by the
          following property:</para>

          <programlisting format="linespecific">isis.timezone = Europe/London</programlisting>

          <para>The time zone is normally a geographic area and a location
          separated by a slash (/), such as
          <emphasis>America/New_York</emphasis>,
          <emphasis>Europe/Paris</emphasis> or
          <emphasis>Australia/Perth</emphasis>. These codes can be looked up
          online on sites such as <ulink
          url="http://www.convertit.com/Go/ConvertIt/World_Time/Current_Time.ASP">ConvertIt.com</ulink>
          and <ulink url="http://twiki.org/cgi-bin/xtra/tzdatepick.html">Date
          and Time Gateway</ulink>.</para>

          <para>Alternatively the time zone can be specified in relative
          format of the form <emphasis>GMT-8:00</emphasis> where the relative
          number of hours and minutes can be specified.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Image Loading</title>

        <para>All images must be held in a directory called <filename
        class="directory" moreinfo="none">images</filename> in the working
        directory, or on the classpath.</para>

        <para>Images for objects are picked up by class name in the form of
        <filename class="directory"
        moreinfo="none">&lt;ClassName&gt;.&lt;extension</filename>&gt; and
        will be case sensitive on Unix/Linux, but case insensitive on
        Windows.</para>

        <para>The names of the images can be overriden by the reflector, which
        can pass back a name of an image that is found from the domain object.
        This provides a mechanism for objects to be shown with images that
        they themselves specify.</para>

        <para><emphasis>Extensions</emphasis> that are currently supported are
        <filename class="directory" moreinfo="none">.gif</filename>, <filename
        class="directory" moreinfo="none">.png</filename>, <filename
        class="directory" moreinfo="none">.jpg</filename> and <filename
        class="directory" moreinfo="none">.jpeg</filename>.</para>

        <para><emphasis>ClassName</emphasis> is either the short form or the
        fully qualified name of the class, and case can be important depending
        on the platform.</para>

        <para>When loading images based on class, if no image is found for the
        current class using the above variations then the process is repeated
        using the name (both short and fully qualified) of the class's
        immediate superclass. This process repeats until there are no more
        superclasses.</para>

        <para></para>

        <para></para>

        <para>There are a number of generic images that are used by the
        framework, and that can be changed to create a different look. These
        are:-</para>

        <itemizedlist>
          <listitem>
            <para><literal>empty-field.png</literal></para>
          </listitem>

          <listitem>
            <para><literal>logo.jpg</literal></para>
          </listitem>

          <listitem>
            <para><literal>small-logo.png</literal></para>
          </listitem>

          <listitem>
            <para><literal>transient.png</literal></para>
          </listitem>

          <listitem>
            <para><literal>unknown.png</literal></para>
          </listitem>
        </itemizedlist>

        <para></para>
      </sect1>

      <sect1>
        <title>Exploration Properties</title>

        <sect2>
          <title>Users</title>

          <para>*** this is also mentioned in isis-security.file...</para>

          <para></para>

          <para>The list of users that can be switched between during
          exploration can be listed, separated by commas, with the following
          property. If no users are specified the default user "exploration"
          will be used and switching between users will not be
          possible.</para>

          <programlisting format="linespecific">isis.exploration.users=sven, dick, bob</programlisting>
        </sect2>

        <sect2>
          <title>Exploration options</title>

          <para>To disable the showing of exploration menu items set the
          following property to false (by default exploration options are
          shown).</para>

          <programlisting format="linespecific">isis.exploration.show=false</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>*** Component loggers</title>

        <para>*** split this out to the respective modules.</para>

        <para>The framework provides a set of component loggers that
        specifically log the use of a component, adding additional log
        messages to the Log4j log or write out to a separate file. Additional
        logger can also be defined for other components. These logger are
        designed to log the parameters passed to and the the results return
        from the requests to a component and tend to be more verbose than the
        general logging just discussed. At present the following components
        have loggers available:-</para>

        <itemizedlist>
          <listitem>
            <para>The object persistor -
            <classname>ObjectPersistorLogger</classname></para>
          </listitem>

          <listitem>
            <para>The object store -
            <classname>ObjectStoreLogger</classname></para>
          </listitem>

          <listitem>
            <para>The distibution interface -
            <classname>DistributionLogger</classname></para>
          </listitem>
        </itemizedlist>

        <para>To set up a logger create an instance of it passing in the
        object you are logging. Then use the logger instance in place of the
        original component. The constructors for each of the loggers are
        overloaded so they take a component to decorate and possibly a file
        name. If the filename is specified then the logging is done to that
        file. If there is no file name then the events are logged via Log4j.
        For example the object store persistor would logged by
        replacing:</para>

        <programlisting format="linespecific">ObjectAdapterPersistor persistor = new ObjectStorePersistor();
isis.setObjectPersistor(persistor);</programlisting>

        <para>with this, which will log request to the persistor the <filename
        class="directory" moreinfo="none">sever-persistor.log</filename>
        file:</para>

        <programlisting format="linespecific">ObjectAdapterPersistor persistor = new ObjectStorePersistor();
persistor = new ObjectManagerLogger(persistor, "server-persistor.log");
isis.setObjectPersistor(persistor);</programlisting>

        <para>Please note that the log files, when used, are created when the
        logger is instantiated and will overwrite any exsiting file. This is
        not normally a problem as we are interested in the activities during
        an entire session. However on a stateless server where the component
        is being recreated each time the continual recreation of the file
        could be a problem.</para>

        <sect2>
          <title>Defining a logger</title>

          <para>To define a logger extend the Logger class, providing a
          suitable constructor, and implement the
          <methodname>getDecoratedClass</methodname> so it passes back the
          <classname>Class</classname> object of the class being decorated
          (this allows the Log4j logger to log messages as that class rather
          than as a separate class). Within the subclass you can use the
          following methods:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis> <methodname>void log(String
              message)</methodname> </emphasis></para>

              <para>output a log entry with the specified message.</para>
            </listitem>

            <listitem>
              <para><emphasis> <methodname>void log(String message, Object
              result)</methodname> </emphasis></para>

              <para>output a log entry with the specified message and the
              specified result. This is useful when needing to show both the
              entry and exit states, or the paramters and the return
              value.</para>
            </listitem>

            <listitem>
              <para><emphasis> <methodname>void close()</methodname>
              </emphasis></para>

              <para>closes the file that is being written to.</para>
            </listitem>
          </itemizedlist>

          <para></para>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Persistor API</title>

        <para></para>
      </sect1>

      <sect1>
        <title>Object Store API</title>

        <para></para>

        <para></para>

        <sect2>
          <title>Writing your own Object Store</title>

          <para>*** do we want to include this section ... it'll be somewhat
          long!</para>

          <para></para>

          <para>When a object is persisted the object store's
          <methodname>createCreateObjectCommand</methodname> method is called.
          This create a command object (see GoF Patterns books), which will
          later be processed when the transaction is be commited. All
          persistence actions (create, destroy and save) are collected
          together until this point. This way when a transaction is aborted
          all commands can be thrown away without recourse to the database.
          Specifically it is the <methodname>execute</methodname> method that
          is called on the command, and this command runs an insert command
          agains the the database.</para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Bytecode Provider API</title>

        <para></para>

        <para></para>

        <para>The default runtime for <emphasis>Apache Isis</emphasis>
        normally performs lazy loading of references and dirty tracking by
        proxying all domain objects. Two implementations are provided, using
        either cglib or javassist. The application archetype automatically
        configures the use of these proxies. However, some object stores
        (notably, the JPA object store) do not require these proxies (because
        they add their own proxies instead); in which case these can be
        disabled. Alternatively, you may not want to use the bytecode support,
        in which case you can add the appropriate calls for lazy loading and
        dirty tracking.</para>

        <para>This area is covered in the {{{./applib/index.html}applib}}, but
        there is also module-specific documentation in the
        {{{./core/bytecode-cglib/index.html}bytecode-cglib}} and
        {{{./core/bytecode-javassist/index.html}bytecode-javassist}}
        modules.</para>

        <para></para>
      </sect1>

      <sect1>
        <title>Profile Store API</title>

        <para></para>

        <para></para>

        <para>Information about a user of the system (rather that a user of
        the application domain model) is stored in a
        <classname>UserProfile</classname> object which is got from the
        <classname>UserProfileService</classname>, which in turn is accessible
        from <classname>IsisSession</classname>. There is also convienence
        methods on <classname>IsisContext</classname> to get both the
        <classname>UserProfile</classname> and the
        <classname>UserProfileService</classname>. The user profile details
        the perspectives the user has set up and options that have been
        specified, typically for the user interfaces. The user profile service
        provides a way to create, save and retrieve the user profiles,
        specifically the profile of the current user. The service in turn has
        a <classname>UserProfilePersistor</classname> that is used to do the
        actual persistence.</para>

        <para>Setting up profiles</para>

        <para>Profiles can be created at start up by creating
        <classname>UserProfileFixture</classname> subclasses. Theses are only
        ever loaded once as the fixture installer checks with
        <methodname>UserProfileSevice.isInitialized()</methodname> to see if
        the service is already set up. The profile fixture (which is defined
        in the application library and is therefore not part of the Isis
        framework) loads the profiles into Isis by passing in an
        implementation of ProfilePersistor that provides a way for the
        perspective to make requests of the framework.</para>

        <para></para>

        <para></para>

        <para></para>

        <para>To store profiles (during exploration) for users the a profile
        store must be specified.</para>

        <para>On the command line use -e xml to store them in an XML.</para>

        <para>Without this the profile will simply be kept in memory, and lost
        on exit.</para>

        <para></para>

        <sect2>
          <title>Setting up Perspectives (Profile Fixtures)</title>

          <para></para>

          <para></para>

          <para>Perspectives allow the set of services available to a user (eg
          as icons in the DnD viewer) to be customized for that user. Since
          these services represent the "start points" for the user to interact
          with the domain model, they in a sense define an application on a
          per-user basis.</para>

          <para>The perspectives are stored in user-profiles, which are a
          persistence mechanism independent of the object store. (The intent
          is for user profiles to store additional information for use by
          viewers, for example allowing a user to reskin an application or
          change colors or fonts. As of NOF 4.0 the functionality provided is
          still limited, however).</para>

          <para>The key here is that if a user logs in and no perspective
          exists for that user then one will be created for them. The new
          perspective will be a copy of the 'template' perspective, or, if
          none was defined, a perspective containing all the known services.
          To create a template perspective add a perspective fixture that
          calls <methodname>saveAsDefault()</methodname>, rather than
          <methodname>saveForUser()</methodname> for a named user, as shown
          below.</para>

          <programlisting>public class PerspectivesFixture extends UserProfileFixture {
    @Override
    protected void installProfiles() {
        Profile profile = newUserProfile();
        Perspective perspective = profile.newPerspective("ECS");
        perspective.addToServices(LocationFactory.class);
        perspective.addToServices(CustomerRepository.class);
        perspective.addToServices(PaymentMethodFactory.class);
        
        saveAsDefault(profile);
    }
}
</programlisting>

          <para>With that set up, when a new user now logs in they will see
          three service icons on the screen for locations, customers and
          payment methods. On the drag and drop user interface the user can
          add and remove services from their perspective. To remove a service
          icon right-click on the grey border and select the close option. To
          add a service select the Services... option from the application
          menu (accessed by right-clicking on the application background) and
          drag the required service onto the desktop. Unfortunately there is
          no similar mechanism available on the HTML user interface so you
          will need to modify the created perspectives via the DND UI.</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title>Webapp Module</title>

      <para></para>

      <para>The webapp module is a small module that provides reusable servlet
      context listeners and filters to webapp viewers. They include:</para>

      <itemizedlist>
        <listitem>
          <para><classname>IsisWebAppBootstrapper</classname> which is a
          servlet context listener to bootstrap an Isis runtime and bind to
          the servlet context</para>
        </listitem>

        <listitem>
          <para><classname>IsisSessionFilter</classname> which is a filter
          used to creating an IsisSession for each request (the Open session
          in View pattern)</para>
        </listitem>

        <listitem>
          <para><classname>ResourceServlet</classname> which serves up static
          content from the specified resource</para>
        </listitem>

        <listitem>
          <para><classname>StaticContentFilter</classname> which decorates
          static content with headers for caching</para>
        </listitem>
      </itemizedlist>

      <para><note>
          <para>The <classname>ResourceServlet</classname> and
          <classname>StaticContentFilter</classname> will likely move back to
          core framework because they are likely to be of use to most runtime
          implementations.</para>
        </note></para>

      <para>Not every webapp-based viewer is required to use these classes;
      refer to their documentation for exact details of what should reside in
      the web.xml.</para>

      <para></para>
    </chapter>

    <chapter>
      <title>Webserver Module</title>

      <para></para>

      <para>The webserver module is intended to make it easy to run
      webapp-based viewers, using the webapp as defined in
      <filename>src/main/webapp/WEB-INF/web.xml</filename>.</para>

      <para>This is a useful facility to have during development, but is not
      (expected to be) needed for deployment. In essence all the module does
      is to bundle up Jetty.</para>

      <para>An alternative would be to use <code>mvn jetty:run</code>; this
      module is for when you'd rather just run a standalone program (ie, with
      a <methodname>main()</methodname> in it) without the overhead of
      <emphasis>Maven</emphasis>.</para>

      <para></para>

      <para></para>

      <para>There is also an alternative bootstrapper,
      org.apache.isis.webserver.WebServer.</para>

      <para></para>

      <para></para>

      <sect1>
        <title></title>

        <para></para>

        <sect2>
          <title>Properties</title>

          <para>The embedded web server (implemented by Jetty) has only one
          properties</para>

          <programlisting format="linespecific">isis.embedded-web-server.port=8080</programlisting>

          <para>Which specifies the port to use when prototyping.</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title>Remoting Modules</title>

      <para></para>

      <para></para>

      <para></para>

      <para>There are two startup mechanisms provided with Isis: an Isis
      container; and a web container based on Jetty. Both are run from the
      command line and allow parameters to be specified that control its
      behaviour, determing how logging is performed, what components are
      loaded and so on.</para>

      <para>The Isis container is run using the <classname>Isis</classname>
      class from the core-runtime module.</para>

      <para>Another way to run Isis is in a independent web container like
      Tomcat or WebSphere. This process is dealt with later.</para>

      <para></para>

      <para></para>
    </chapter>
  </part>

  <part>
    <title>Deployment</title>

    <chapter>
      <title>Running in Development</title>

      <para>*** ie, not deployed, just running immediately.</para>

      <para></para>

      <para></para>

      <sect1 id="sec.RuntimeLauncher">
        <title>Bootstrapping (Isis launcher)</title>

        <para></para>

        <para></para>

        <para>The command line container runs Isis within its own container
        and is best suited to running from the command line where parameters
        are used to determine what components are used and how it all
        runs.</para>

        <para>In essense we are running Java with the Isis class like
        this:</para>

        <para>$ java -cp &lt;classpath&gt;
        org.apache.isis.runtimes.dflt.runtime.Isis
        &lt;parameters...&gt;</para>

        <para>however we typically use a script like the one created by the
        archetype so we can run more easily, eg</para>

        <para>$ ./isis.sh &lt;parameters...&gt;</para>

        <para>The Isis class immediately starts up the logging so that log
        messages are never lost. Next the
        <classname>InstallerLookup</classname> object is instantiated. This
        loads up all the installers that can be found on the classpath, which
        are listed in <filename>installer-registry.properties</filename> . (In
        the source tree, this file physically resides in
        <filename>core/runtime/src/main/resources/</filename>). This allows
        Isis to be aware of all the components that are available, allowing
        names such as xml, file, dnd and html to be used to refer to
        components instead of their fully qualified class names. We maintain
        this list with the framework and public available components will be
        added to the registry list when we know about them.</para>

        <para>With these details loaded Isis then parses the command line
        parameters. If there is problem with these then a help text is
        displayed list all the options and the program exits. With the command
        line arguments processed Isis initializes the installers and
        bootstraps the system.</para>

        <para></para>

        <para></para>

        <para></para>

        <para></para>

        <para>If you are asked from diagnostic information then run Apache
        Isis as follows to capture details about your machine, configuration
        and Isis.</para>

        <programlisting>$ isis.sh --diagnostics &gt; diagnostics.txt</programlisting>

        <para></para>

        <para></para>

        <para></para>

        <para>A bootstrapper takes care of loading up the Isis framework and
        application, initialising it, and running it. When it starts up it
        reads in a list of components and attempts to load in each one. Any
        component that can be loaded is then available to be used and can then
        be specified on the command line if required. Requesting a component
        that cannot be loaded will result in an error. To resolve such an
        error simply ensure that the component's Jar file is available on the
        class path. All the components supplied with the framework are listed
        in the file <filename class="directory"
        moreinfo="none">installer-registry.properties</filename> which is part
        of the JAR file for <package>[oai.runtimes.dflt:runtime]</package>
        module.</para>

        <para>During start-up Isis loads in a number of configuration files.
        The main file, <filename class="directory"
        moreinfo="none">isis.properties</filename>, is always loaded and must
        be present for the framework to start up. For each of the various
        types of persistor and viewer, there is a separate configuration file.
        For example, for the following command line parameters</para>

        <screen format="linespecific">-v dnd -r xml</screen>

        <para>specifies that the viewer is to be the drag and drop (<literal
        moreinfo="none">dnd</literal>) interface, and the persistor is to be
        the 'xml object store'. As well as loading those components, the
        framework will look for configuration files named
        <filename>viewer.properties</filename>, <filename class="directory"
        moreinfo="none">viewer_dnd.properties</filename>,
        <filename>persistor.xml</filename> and <filename class="directory"
        moreinfo="none">persistor_xml.properties</filename> and will load them
        if found.</para>

        <para></para>

        <para></para>

        <sect2>
          <title>Class</title>

          <para>The bootstrapper is the class
          <classname>org.apache.isis.runtime.Isis</classname> and takes the
          following options on the command line. (Note that in each case there
          is an abbreviated, and a full, version of the option).</para>

          <para></para>

          <para></para>

          <para>*** can also use org.apache.Isis - just delegates to
          org.apache.isis.runtime.Isis.</para>

          <para></para>
        </sect2>

        <sect2>
          <title>Configuration</title>

          <screen format="linespecific">-c &lt;config file&gt;
--config &lt;config file&gt;</screen>

          <para>Loads in the specified configuration file, in addition to
          <filename class="directory"
          moreinfo="none">isis.properties</filename> and the properties files
          relating to the installed component.</para>
        </sect2>

        <sect2>
          <title>Disable splash</title>

          <screen format="linespecific">-s
--nosplash</screen>

          <para>Prevents the splash screen from being displayed during start
          up.</para>
        </sect2>

        <sect2>
          <title>Help</title>

          <screen format="linespecific">-h
--help</screen>

          <para>Prints out the options that are available. This is dynamic so
          that only the components that can be used are listed.</para>
        </sect2>

        <sect2>
          <title>Logging</title>

          <para>The amount of logging detail can be controlled from the
          command line. If no flag is specified only warnings and errors are
          output. All logging level relate to the Log4J levels, which is the
          logging mechanism used by Isis.</para>

          <screen format="linespecific">-quiet</screen>

          <para>Quiet reduces logging to show errors only.</para>

          <screen format="linespecific">-verbose</screen>

          <para>Increases logging to show information about the system as it
          runs.</para>

          <screen format="linespecific">-debug</screen>

          <para>Increases logging to show all logged entries. At this level so
          much is logged that it will likely slow down the system if used when
          outputting log details to the console or other slow devices.</para>
        </sect2>

        <sect2>
          <title>Deployment Type (or Mode)</title>

          <screen format="linespecific">-t &lt;mode&gt;
--type &lt;mode&gt;</screen>

          <para>The framework is started up in one of several different
          deployment modes, as listed below:</para>

          <para><emphasis>exploration</emphasis> - Exploration mode is for
          developers to explore and test their code. The framework always uses
          an in-memory persistor and runs the fixtures at startup to ensure a
          known state every time the system is started. The user is not
          prompted to log in, but is automatically logged in as user
          'exploration'. The logged in user can be changed on the fly using an
          option with the user interface; this simply changes the user and
          does not require an explicit login action. Also, exploration methods
          defined in the DOM are also available to the user to do things that
          a user would not normally be allowed to do. These are used expressly
          for testing the system. Please note it is an error to specify a
          persistor type in exploration mode.</para>

          <para><emphasis>prototype</emphasis> - Prototype mode is for
          demonstrating the system in realistic fashion. The user is always
          prompted to log in at start up, and can log out and log in again
          without losing the state of the objects. This allows a user to
          demonstrate exactly how a system would work.</para>

          <para><emphasis>single-user</emphasis> - Single user mode runs the
          system for a single user with object persistence.</para>

          <para><emphasis>client</emphasis> - Client mode provides multiple
          users access to a server. With this mode selected the
          <emphasis>connection</emphasis> option must also be
          specified.</para>

          <para><emphasis>server-exploration</emphasis> - Server mode, but all
          clients will automatically be logged in as the 'exploration' user
          (or as <classname>LoginFixture</classname> is present).</para>

          <para><emphasis>server-prototype</emphasis> - Server mode, but if a
          <classname>LoginFixture</classname> is present then all clients will
          automatically be logged in as this user.</para>

          <para><emphasis>server</emphasis> - Server mode runs Isis as a
          server for multiple clients. With this mode selected the
          <emphasis>connection</emphasis> option must also be
          specified.</para>

          <para>If no mode is specified, the framework will start up in
          <emphasis>prototype</emphasis> mode.</para>
        </sect2>

        <sect2>
          <title>Overridden properties</title>

          <screen format="linespecific">-D property=value</screen>

          <para>Using this flag we can pass in properties from the command
          line that would otherwise need to specified in a configuration file.
          This is normally used to override a property, or to temporarily
          specify one.</para>
        </sect2>

        <sect2>
          <title>Password</title>

          <screen format="linespecific">-p &lt;password&gt;
--password &lt;password&gt;</screen>

          <para>Ignored if type is prototype or not used with the user option
          below.</para>

          <para>Uses the specified password when logging the user in with the
          username specified with <methodname>--user</methodname>.</para>
        </sect2>

        <sect2>
          <title>Persistor</title>

          <screen format="linespecific">-r &lt;persistor&gt;
--persistor &lt;persistor&gt;</screen>

          <para>Ignored if type is client.</para>

          <para>The persistor option allows you to choose how the objects
          created by the system will be persisted so they are still available
          the next time you run the system. The following options are
          available with the current distribution, and if none is specified
          then the in-memory persistor will be used for exploration mode and
          xml persistor will be used for other non-client modes by
          default.</para>

          <para><emphasis>in-memory</emphasis> - A simple non-persisting
          mechanism that will only hold the persisted object while the virtual
          machine is running. This is used for testing and
          demonstrating.</para>

          <para><emphasis>xml</emphasis> - A simple file based mechanism that
          encodes each object's data in an XML file. Alongside the data files
          for the objects are instance lists listing all the files for each
          type of object.<emphasis></emphasis></para>

          <para><emphasis>&lt;class name&gt;</emphasis> - By specifying a
          class name the boot loader will load up that class as the
          persistor.</para>
        </sect2>

        <sect2>
          <title>Remote connector</title>

          <screen format="linespecific">-x &lt;connector&gt;
--connector &lt;connector&gt;</screen>

          <para>Ignored if mode is not a client. If the type is a client then
          a connection mechanism can be specified. Connector mechanisms
          available are:-</para>

          <para><emphasis>encoding-sockets</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          TCP/IP sockets.</para>

          <para><emphasis>encoding-http</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          HTTP.</para>

          <para><emphasis>serializing-sockets</emphasis> - Uses Java
          serialization (of value types) to serialize/deserialize objects,
          over TCP/IP sockets.</para>

          <para><emphasis>xstream-sockets</emphasis> - Uses the Xstream
          library to serialize/deserialize objects to/from XML for simple
          stream communications, over TCP/IP sockets.</para>
        </sect2>

        <sect2>
          <title>User</title>

          <screen format="linespecific">-u &lt;user name&gt;
--user &lt;user name&gt;</screen>

          <para>Ignored if type is prototype.</para>

          <para>Uses the specified name when logging the user in. If the
          password is also specified (see above) then an attempt to log in
          using the supplied user name and password is made; authentication
          failure at this point will exit the program.</para>
        </sect2>

        <sect2>
          <title>Viewer</title>

          <screen format="linespecific">-v &lt;viewer&gt;
--viewer &lt;viewer&gt;</screen>

          <para>The viewer option allows you to choose the user interface that
          is used to access your Isis application. The following options are
          available with the current distribution, and if none is specified
          then the drag and drop view will be used by default.</para>

          <para><emphasis>dnd</emphasis> - Drag and Drop viewer</para>

          <para><emphasis>html</emphasis> - Web browser viewer - accessed via
          standard web browser such as FireFox, Internet Explorer or
          Opera</para>

          <para><emphasis>encoding-sockets</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          TCP/IP sockets.</para>

          <para><emphasis>encoding-http</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          HTTP.</para>

          <para><emphasis>serializing-sockets</emphasis> - Uses Java
          serialization (of value types) to serialize/deserialize objects,
          over TCP/IP sockets.</para>

          <para><emphasis>xstream-sockets</emphasis> - Uses the Xstream
          library to serialize/deserialize objects to/from XML for simple
          stream communications, over TCP/IP sockets.</para>

          <para><emphasis>&lt;class name&gt;</emphasis> - By specifying a
          class name the boot loader will load up that class as the
          viewer</para>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title>Standalone Deployment</title>

      <para></para>

      <para></para>

      <note>
        <para>TODO: discuss sealed/signed JARs to prevent tampering?</para>
      </note>

      <para></para>

      <sect1>
        <title>Setting up Security</title>

        <para></para>

        <para></para>

        <para></para>

        <para></para>
      </sect1>
    </chapter>

    <chapter>
      <title>Client/Server Deployment</title>

      <section>
        <title></title>

        <para></para>
      </section>
    </chapter>

    <chapter>
      <title>Web App Deployment</title>

      <para></para>

      <para></para>

      <para></para>

      <sect1>
        <title>Setting up Security</title>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Running as a WebApp</title>

        <para>Isis provides three different ways to run as a webapp:</para>

        <sect2>
          <title>Using isis.sh</title>

          <screen format="linespecific">$ isis.sh --type server --viewer html --persistor xml
2007-08-09 12:37:13.671::INFO:  Logging to STDERR via org.mortbay.log.StdErrLog
2007-08-09 12:37:13.801::INFO:  jetty-6.0.2
2007-08-09 12:37:13.954::INFO:  Started SocketConnector @ 0.0.0.0:8080
</screen>

          <para>This command runs the Isis with the HTML viewer, allowing
          multiple clients to access it via a browser. As for the standalone
          version the users need to access the URL
          http://<emphasis>server/logon.app</emphasis> to access the log on
          page.</para>
        </sect2>

        <sect2>
          <title>Using WebServer bootstrap</title>

          <para>The next mechanism uses the
          <classname>org.apache.isis.webserver.WebServer</classname> bootstrap
          to run Isis. This loads up whatever is in the webapp project's
          <filename>web.xml</filename> file.</para>

          <para><remark>TODO: we don't have a webserver.sh script to show this
          in action; we probably should.</remark></para>

          <para>Ordinarily the web.xml will be configured to run the same HTML
          viewer, so the end result will be the same. However, if necessary
          the remoting servlet can also be configured</para>
        </sect2>

        <sect2>
          <title>Deploying as a WAR</title>

          <para>The final mechanism is to use Maven to package up the webapp
          project as a WAR file, packaging up whatever is in the web.xml file.
          As above, ordinarily the web.xml will be configured to run the same
          HTML viewer, so the end result will be the same. However, if
          necessary the remoting servlet can also be configured</para>

          <para>Packaging up is done using:</para>

          <screen format="linespecific">$ cd webapp
$ mvn clean package</screen>

          <para>This should result in a WAR file in
          <filename>target</filename> directory. This can be deployed to an
          existing servlet containerd</para>

          <para></para>
        </sect2>
      </sect1>
    </chapter>
  </part>
</book>
