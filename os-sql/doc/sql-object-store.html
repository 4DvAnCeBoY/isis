<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />

    <link href="../style.css" rel="STYLESHEET" type="text/css" />

    <title>SQL Object Store</title>
  </head>

  <body>
    <h1>SQL Object Store</h1>

    <h3>Structure</h3>

    <p>The SQL Object Store contains a mapper for each class of Naked Object
    that might be persisted.Ã‚Â&nbsp; These mappers are specified and
    configured at runtime via the framework properties file.Ã‚Â&nbsp; To
    create an alternative mapper you must implement the ObjectMapper interface
    and register your class.Ã‚Â&nbsp; This interface requires that you provide
    methods to access the instances of your type, and methods to create, read,
    update and delete objects of your type.Ã‚Â&nbsp; There are various
    implementations of this interface in
    org.nakedobjects.persistence.sql.auto, which you can extend if you
    wish.</p>

    <p>The concrete implementations of the ObjectMapper make use of an
    abstracted database connection, called DatabaseConnector.Ã‚Â&nbsp; These
    connections are generated by a DatabaseConnectorFactory, which also must
    be provided at startup (see the configuration details below).Ã‚Â&nbsp; The
    provided JDBC implementation (the org.nakedobjects.persistence.sql.jdbc
    package) provides such a factory - JdbcConnectorFactory - that provides
    database connections using Java's JDBC.Ã‚Â&nbsp; The JdbcConnector
    implementation simply maps the requests made to the DatabaseConnector
    interface to JDBC specific requests.Ã‚Â&nbsp; Results from the database
    are encapsultaed in a Results object that allows the rows in the result
    set to be traversed (forward only), and the column data to be extracted
    into the framework.Ã‚Â&nbsp; Again a JDBC implementation is provided by
    JdbcResults.</p>

    <p>To connect to a database via another mechanism (other than JDBC) all of
    the following interfaces need to be implemented:-</p>

    <ol>
      <li>DatabaseConnector</li>

      <li>DatabaseConnectorFactory</li>

      <li>Results</li>
    </ol>

    <p>In addition you might need to create an OidGenerator also to create OID
    objects, but this is not strictly part of the Object Store itself,
    although it woud probably use the same facilities.</p>

    <p>Once a these connection classes have been implemented then the mappers
    provided within org.nakedobjects.persistence.sql.auto will be able to
    persist objects through the new connection.Ã‚Â&nbsp; Additional mappers
    can then be added as needed.</p>

    <p>The most useful auto-mapper is the AutoMapper, which automatically maps
    the contents of an object onto a corresponding table in the database,
    creating the table first if necessary.Ã‚Â&nbsp;</p>

    <h3>Configuration</h3>

    <p>The following configurations are taken from the nakedobjects.properties
    file.</p>

    <p>The first line specifies that we want to use the SQL Object Store for
    storing our objects.Ã‚Â&nbsp; Ensure there are no other lines in this file
    with the same key.Ã‚Â&nbsp; When running the SQL Object Store we must
    specify at least the following:</p>

    <ol>
      <li><p>what type of connections we will be using;</p></li>

      <li><p>the auto-mapper factory;</p></li>

      <li><p>a default mapper, which will be used for mapping objects that
      have no specific mapper specified later;</p></li>

      <li><p>a specific mapper for NakedClass objects</p></li>
    </ol>

    <p>The following are settings used for the basic JDBC based behaviour:</p>

    <pre>nakedobjects.object-store=org.nakedobjects.persistence.sql.SqlObjectStore
nakedobjects.sql-object-store.connector=org.nakedobjects.persistence.sql.jdbc.JdbcConnectorFactory
nakedobjects.sql-object-store.automapper=org.nakedobjects.persistence.sql.auto.AutoMapperFactory
nakedobjects.sql-object-store.default-mapper=org.nakedobjects.persistence.sql.auto.NameBasedMapper
nakedobjects.sql-object-store.class-mapper=  org.nakedobjects.persistence.sql.auto.DefaultNakedClassMapper</pre>

    <p>In addition we specify a specific OID generator (this is to keep the
    tables primary keys in order).</p>

    <pre>nakedobjects.oidgenerator=org.nakedobjects.persistence.sql.jdbc.JdbcOidGenerator</pre>

    <p>For the JDBC connector, as specified above, we need to provide details
    about how we access the database using JDBC. The following indicates that
    we want use the <span style="font-weight: bold;">SQLServer</span> driver
    from microsoft, to establish a connection to a <span
    style="font-weight: bold;">db-nof</span> database, and that the user is
    <span style="font-weight: bold;">sa</span>, while there is no
    password.</p>

    <pre>
nakedobjects.sql-object-store.jdbc.driver=com.microsoft.jdbc.sqlserver.SQLServerDriver
</pre>

    <pre>
nakedobjects.sql-object-store.jdbc.connection=jdbc:microsoft:sqlserver://localhost;selectMethod=cursor;databaseName=db-nof
</pre>

    <pre>
nakedobjects.sql-object-store.jdbc.user=sa
</pre>

    <pre>
nakedobjects.sql-object-store.jdbc.password=
</pre>

    <p>To assist the interactions with the database a set of low level mapping
    can also be specified. These specify what object in Naked Objects should
    be mapped to which column types in the database. The following are
    suitable for SQLServer.</p>

    <pre>
nakedobjects.sql-object-store.typemapper.OID=int
</pre>

    <pre>
nakedobjects.sql-object-store.typemapper.org.nakedobjects.object.value.TextString=varchar(255)
</pre>

    <pre>
nakedobjects.sql-object-store.typemapper.org.nakedobjects.object.value.Option=varchar(255)
</pre>

    <pre>
nakedobjects.sql-object-store.typemapper.org.nakedobjects.object.value.MultilineTextString=varchar(1024)
</pre>

    <pre>
nakedobjects.sql-object-store.typemapper.org.nakedobjects.object.value.Date=datetime
</pre>

    <pre>
nakedobjects.sql-object-store.typemapper.org.nakedobjects.object.value.TimeStamp=datetime
</pre>

    <pre>
nakedobjects.sql-object-store.typemapper.org.nakedobjects.object.value.Logical=BIT
</pre>

    <p>Specific object mappings can be specified with the following mapping
    pattern. On the left, after the prefix <span
    style="font-weight: bold;">nakedobjects.sql-object-store.mapper.</span>
    specify the class on Naked Object, and, after the equals sign, the mapper
    to use. The first example maps the User class to a specific user mapper,
    and the second specifies that the automatic mapper is used for Role
    objects.</p>

    <pre>
nakedobjects.sql-object-store.mapper.org.nakedobjects.security.User=  org.nakedobjects.persistence.sql.auto.UserMapper
</pre>

    <pre>
nakedobjects.sql-object-store.mapper.org.nakedobjects.security.Role=  auto
</pre>

    <pre>
  #nakedobjects.sql-object-store.mapper.dsfa.business.object.Customer=
  dsfa.objectstore.CustomerMapper
  #nakedobjects.sql-object-store.mapper.dsfa.business.object.Customer=
  auto.customer
  #nakedobjects.sql-object-store.automapper.customer.all-fields=off

  #nakedobjects.sql-object-store.automapper.customer.table=Customer

  #nakedobjects.sql-object-store.automapper.customer.id=PKCustomerID

  #nakedobjects.sql-object-store.automapper.customer.column.KnownAsSurname=Lastname

  #nakedobjects.sql-object-store.automapper.customer.column.KnownAsForename=Forename

  #nakedobjects.sql-object-store.automapper.customer.column.PKPPSN=Ppsn
</pre>

    <h3>Creating new Mappers</h3>

    <p>The simplest way to create a new mapper is to extend
    AbstractObjectMapper as it provides you with automatic set up, including
    an initialised connection. Specifically, it provides you with a mechnism
    for getting a primary key ID (as a long number) from an OID. In your
    subclass you need to implement all the remaining method from the
    ObjectMapper interface. As these can be reasonably long and complex, start
    by implementing getInstances() (where all three methods can start off as
    one implementation), and resolve(). These basic methods will allow you to
    see objects with data from the database (assuming the database is already
    populated). To ensure you can inovoke the instances methods from the class
    viewers, implement hasInstances() to return true, and numberOfInstances()
    to return a number greater than zero. Follow these instance methods with
    create() and save() methods so the objects can now be persisted, Finally,
    implement the destroy(), and the skipped hasInstances() and
    numberOfInstances() method to complete the mapper.</p>

    <p></p>
  </body>
</html>