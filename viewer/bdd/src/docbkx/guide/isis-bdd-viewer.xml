<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./resources/docbook-xml-4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para>Behaviour-driven development is a means to drive the development of
    an application through stories and scenarios. These are expressed in a
    semi-formal textual form that can be understood (or indeed be written) by
    the domain expert/business analyst, but which can then be used to directly
    exercise the system under test as it is developed.</para>

    <para>A number of frameworks exist to streamline this process. Generally
    these require the developer to write glue code that acts as a bridge from
    the textual specification and the system under test.</para>

    <para>The <emphasis>BDD Viewer</emphasis> module for <emphasis>Apache
    Isis</emphasis> aims to allow <acronym>BDD</acronym> stories/scenarios to
    be written against the domain model of an Isis application, without the
    developer having to write any glue code. It consists of a common library
    that abstracts the interaction with the Isis metamodel, along with an
    integration (that uses this common library) for one particular
    <acronym>BDD</acronym> framework, namely <ulink
    url="http://concordion.org">Concordion</ulink>.</para>

    <para>This user guide describes how to use the Concordion integration,
    along with details of the common library so that other BDD frameworks can
    be integrated if required.</para>

    <para><emphasis>Apache Isis</emphasis> is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>
  </preface>

  <!-- main content -->

  <chapter>
    <title>Introduction</title>

    <sect1>
      <title>Behaviour-driven Development</title>

      <para>Prior to agile development, requirements gathering for systems was
      traditionally performed by business analysts discussing requirements
      with the business, and expressing those requirements in documentation,
      such as Word specs and perhaps spreadsheets. The acceptance criteria for
      such requirements were often only sketched out, if at all; it would
      normally fall to the system testers to write acceptance tests for the
      requirements, through a mixture of consulting the original (by now
      out-of-date) requirements documentation and (as often as not)
      reverse-engineering the implementation.</para>

      <para>Behaviour-driven development combines requirements capture and the
      acceptance test criteria in a single form, through scenarios. As before,
      these requirements are in a form that a non-technical domain expert from
      the business can understand. What differs though is that these scenarios
      can be used directly exercise the system, and so also represent the
      acceptance tests for the scenario. Moreover, the results of these tests
      are rendered in such a way that the business can understand, and thus
      can help determine if the code is at fault or the test. Once
      implemented, the acceptance tests also act as a regression suite for the
      system.</para>

      <para>Scenario tests tend to act against a complete system, or sometimes
      at a subsystem-level. At any rate at a granularity that makes sense to a
      non-technical businesss person. Compare this to unit testing which
      exercises the behaviour / method of a single class.</para>

      <para>Scenario testing is closely related to (and sometimes a synonym
      for) "agile acceptance testing"; I must admit though that I find that
      term rather clumsy.</para>
    </sect1>

    <sect1>
      <title>Concordion Integration</title>

      <sect2>
        <title>Introduction to Concordion</title>

        <para><ulink url="http://concordion.org">Concordion</ulink> is a
        framework to enable scenario testing. It is implemented as a <ulink
        url="http://junit.org">JUnit4</ulink> test runner, with the test form
        being written in <acronym>XHTML</acronym>. The domain expert /
        business analyst authors new stories using an <acronym>XML</acronym>
        editor (<ulink url="http://xmlmind.net">XmlMind</ulink> is one
        commercial editor that we recommend); once executed as tests, the
        results are shown as the same XHTML document, annotated to indicate
        which assertions have succeeded, and which have failed. It also
        creates an efficient feedback loop; a Concordion test will "keep on
        going" even if it hits a failure. Thus the developer can identify
        several issues and fix them in a single pass.</para>

        <para>Another way to think of Concordion is as a replacement
        presentation layer, hitting the underlying domain model in the same
        way that the regular <acronym>UI</acronym> would. (This is why we call
        this module is called the <acronym>BDD
        </acronym><emphasis>viewer</emphasis>).</para>

        <para><acronym>Concordion</acronym> works using a "convention over
        configuration" approach, matching the <acronym>XHTML</acronym> text
        file with a corresponding JUnit4 test run set up to run using
        Concordion's <classname>ConcordionRunner</classname>, The developer
        then annotates the <acronym>XHTML</acronym> using special
        (Concordion-namespaced) attributes in order identify the inputs to and
        expected results of the test. This is used by the
        <classname>ConcordionRunner</classname> to call into corresponding
        methods in the test.</para>

        <para>For example, suppose the analyst writes a scenario test called
        <filename>CustomerPlacesOrder.xhtml</filename>. In the
        <acronym>XHTML</acronym> the analyst has identified the details of the
        customer doing the ordering (customer ref 4321, say), the product
        being ordered (product code 1234), the fact that the customer
        initially has no orders, and that the customer has no invoices
        outstanding. The test concludes with an assertion that there is now an
        unfulfilled order for the customer, and that the customer now has an
        invoice to be paid.</para>

        <para>The developer in turn edits the <acronym>XHTML</acronym>,
        identifying the customer and the product. He then further edits the
        <acronym>XHTML</acronym> to call a method in the JUnit4 test
        representing the placing of an order:
        <methodname>placeOrder()</methodname>, say. And he finishes by
        annotating the <acronym>XHTML</acronym> to make assertions about the
        post conditions (unfulfilled order, new invoice to be paid
        etc).</para>

        <para>Then, the developer writes a JUnit4 test alongside the
        <acronym>XHTML</acronym>; in this example it would be called
        <filename>CustomerPlacesOrderTest.java</filename>. Concordion calls
        into this JUnit4 test as it comes across the annotations in the
        <acronym>XHTML</acronym>, and the JUnit4 test mediates with the system
        under test.</para>

        <para>When the test runs, Concordion generates a copy of the
        <acronym>XHTML</acronym> in a output directory (by default specified
        by a system property) which can then made available for inspection by
        the business analyst (eg published on a website).</para>

        <para>The Concordion website has a good <ulink
        url="http://concordion.org/Tutorial.html">tutorial</ulink> that
        demonstrates all the above, and can be completed in 20~30
        minutes.</para>
      </sect2>

      <sect2>
        <title>How the Isis/Concordion Integration Works</title>

        <para>Although you could test an Apache Isis application using vanilla
        Concordion, this would entail you having to write all the glue code
        yourself to interact with the domain objects. You would also need to
        encode the rules that are normally implemented by the viewer, eg so
        that a hidden action cannot be invoked, and an invalid value for a
        property cannot be set.</para>

        <para>The <emphasis>BDD viewer</emphasis> integration provided by
        <emphasis>Apache Isis</emphasis> works by providing a superclass for
        the JUnit4 test, called
        <classname>AbstractIsisConcordionTest</classname>. This does several
        things:</para>

        <itemizedlist>
          <listitem>
            <para>it bootstraps an instance of <emphasis>Apache
            Isis</emphasis> system using the in-memory object store;</para>
          </listitem>

          <listitem>
            <para>the system is initialized with a set of services, picked up
            from the <filename>isis.properties</filename> configuration
            file</para>
          </listitem>

          <listitem>
            <para>it provides methods to allow fixtures (domain objects) to be
            installed into the object store</para>
          </listitem>

          <listitem>
            <para>it provides methods to allow a user to be logged in, and the
            date to be specified</para>
          </listitem>

          <listitem>
            <para>it provides methods to allow the user to interact with
            services and domain objects:</para>

            <itemizedlist>
              <listitem>
                <para>asserting on the value of properties and the contents of
                collections</para>
              </listitem>

              <listitem>
                <para>setting the value of a property (if valid) and adding
                to/removing from a collection (if valid)</para>
              </listitem>

              <listitem>
                <para>invoking actions</para>
              </listitem>

              <listitem>
                <para>asserting on the state of a class member (hidden,
                disabled or enabled)</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>For each <acronym>XHTML</acronym> scenario test, the developer
        writes subclasses the AbstractIsisConcordionTest, creating a name
        matching the scenario test (ie as per regular Concordion). He
        then</para>

        <para>annotates the original <acronym>XHTML</acronym>, either calling
        directly into the inherited methods, or writing small simple methods
        to delegate to these inherited methods as required. The Concordion
        website has some <ulink
        url="http://concordion.org/Technique.html">hints and tips</ulink> to
        help you find the right balance between these two approaches.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Common Library</title>

      <para>The Concordion integration is based on a library that factors out
      interactions with the running Isis system. This library is intended to
      make it easy to support other BDD frameworks if required.<footnote>
          <para>In fact, the first BDD framework integration was to <ulink
          url="http://fitnesse.org">FitNesse</ulink>. This has now been
          dropped because FitNesse has an incompatible license with Apache
          Software Foundation. The original FitNesse code can still be found
          on the <ulink
          url="http://isis-contrib.sourceforge.net">Isis-contrib</ulink>
          companion site, and does indeed use the common library.</para>
        </footnote></para>

      <para>The main concepts that the common library exposes are:</para>

      <itemizedlist>
        <listitem>
          <para>AliasItemsInListPeer</para>
        </listitem>

        <listitem>
          <para>AliasServicesPeer</para>
        </listitem>

        <listitem>
          <para>CheckListPeer</para>
        </listitem>

        <listitem>
          <para></para>
        </listitem>
      </itemizedlist>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter id="chp.HintsAndTips">
    <title>Hints and Tips</title>

    <para>This chapter contains a collection of hints, tips and suggestions
    for writing your own tests.</para>

    <para>For further guidance, check out Gojko Adzic's book, <ulink
    url="http://www.acceptancetesting.info/the-book/">Bridging the
    Communication Gap</ulink>.</para>

    <sect1>
      <title>Separate In-Progress Stories from the Backlog</title>

      <para>If you are using an agile methodology then you will be
      implementing a number of stories per iteration; the remainder will be in
      a backlog. When you select a story for implementation, create a new page
      for it in a "CurrentIteration" suite. The objective for the team is
      therefore to get the entire CurrentIteration suite green.</para>

      <para>Other stories that you may have identified but not selected for
      the iteration can remain in a Backlog suite.</para>
    </sect1>

    <sect1>
      <title>Use a Story Page to Collect A Set of Scenario Tests</title>

      <para>Part of estimating the size of a story includes identifying the
      acceptance criteria. These can be created as children of the story page
      as placeholders, so that the story page becomes a suite. The child
      scenario tests can be fleshed out as required with plain text during the
      estimation meeting, and with actual FitNesse tests once the iteration
      starts. The FitNesse <ulink
      url="http://fitnesse.org/FitNesse.UserGuide.MarkupContents">!contents</ulink>
      instruction will then list all the acceptance criteria for the
      story.</para>

      <para>For the story page itself, the "as a ... I want ... so that... "
      template is a good way to summarize the intent of the story.</para>
    </sect1>

    <sect1>
      <title>Organize Completed Stories by Component</title>

      <para>Once you have completed an iteration and implements its stories,
      move those stories out to the relevant component that the story relates
      to. The scenario tests for stories ultimately <emphasis>are</emphasis>
      the documentation of the behaviour of the system. A year on you won't
      remember (and won't care) which iteration you implemented a story,
      you'll be searching for it by the component whose behaviour you want to
      understand.</para>
    </sect1>

    <sect1>
      <title>Structure your test using Given/When/Then</title>

      <para>A standard template for organizing structuring tests is
      given/when/then<footnote>
          <para>As first described, I believe, by Dan North in a blog post,
          <ulink url="http://dannorth.net/introducing-bdd">Introducing
          BDD</ulink>.</para>
        </footnote>:</para>

      <itemizedlist>
        <listitem>
          <para>given ... the system is in this particular state</para>
        </listitem>

        <listitem>
          <para>when ... this interesting thing happens</para>
        </listitem>

        <listitem>
          <para>then ... these are the consequences</para>
        </listitem>
      </itemizedlist>

      <para>This structure is readily understood by non-technical business
      users, and helps them (and the team) focus on the point of the
      test.</para>

      <para>In terms of mechanics, one approach is to put the "given" into the
      setup page for a test, with the "when" and the "then" in separate pages.
      Alternatively, as the archetype does (see <xref
      linkend="chp.UsingTheFitNesseArchetype" />), you could separate out the
      "given", the "when" and the "then" into a hierarchy of pages.</para>

      <itemizedlist>
        <listitem>
          <para>Separating out the "given" from the rest of the test makes it
          easy to include that given in other tests (discussed further in
          <xref linkend="sec.FactorOutCommonGivens" />), and it also allows us
          to run up the viewer to inspect the setup (see <xref
          linkend="sec.UsingTheFixtureViewer" />).</para>
        </listitem>

        <listitem>
          <para>Separating out the "then" from the "when" makes it easy to
          identify the individual post conditions. A new requirement might
          mean only the addition of a new post condition. A downside is that
          the "given" and "when" will be run for each post-condition, leading
          to longer test turn-around times.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1 id="sec.UsingTheFixtureViewer">
      <title>Using the RunViewer fixture</title>

      <para>One reason that the archetype (<xref
      linkend="chp.UsingTheFitNesseArchetype" />) separates out the "given",
      "when" and "then" is so that the "given" - which is often the hardest
      part to get setup - can be verified independently from the rest of the
      test.</para>

      <para>To do this, we can use the RunViewer fixture (see <xref
      linkend="sec.RunViewer" />). This will run up the drag-n-drop viewer at
      the specified point in the test; a visual equivalent of
      <code>System.out.println()</code>, really. We can therefore take the
      Given page and add a RunViewer fixture at the end.</para>

      <para>Note that to do this you must temporarily mark the Given page as a
      <ulink url="http://fitnesse.org/FitNesse.UserGuide.PageProperties">test
      page</ulink>.</para>
    </sect1>

    <sect1 id="sec.FactorOutCommonGivens">
      <title>Factor out common "Given"s</title>

      <para>Just like code, tests need to be actively managed, because if the
      tests become hard to maintain, they'll end up being deleted. In fact, we
      probably should take even more care with the tests than the code if they
      represent the primary documentation of the behaviour of the
      system.</para>

      <para>In terms of size, the "given" is far larger than either the "when"
      or the "then", and therefore this is the area where tests can quickly
      become unmaintainable. So instead, factor out your givens into separate
      pages, and then use FitNesse's <ulink
      url="http://fitnesse.org/FitNesse.UserGuide.MarkupPageInclude">!include</ulink>
      directive to assemble the pages you need (as done by the archetype,
      <xref linkend="chp.UsingTheFitNesseArchetype" />).</para>

      <para>The names of these pages should also follow a declarative style,
      see <xref linkend="sec.UseADeclarativeStyle" />.</para>
    </sect1>

    <sect1 id="sec.UseADeclarativeStyle">
      <title>Use a Declarative Style for Page Names</title>

      <para>When factoring out "given"s (see <xref
      linkend="sec.FactorOutCommonGivens" />), or indeed when writing the
      "when"s and the "then"s, use a declarative style for the pages. The page
      should describe what it does, not how it does it.</para>

      <para>For example, a good page would be "SetUpCountries". It's clear
      that this will set up all <classname>Country</classname> reference data
      classes. This could be included into a "SetUpReferenceData" page. For
      transaction data, we could have a page "JoeBloggsCustomer"; another one
      again could be "JoeBloggsFiveOrders".</para>
    </sect1>

    <sect1>
      <title>Run against a real database</title>

      <para>The Tested Objects' integration exercises the Naked Objects domain
      model as configured in nakedobjects.properties (as per the
      SetUpConfigDirectory fixture, <xref
      linkend="sec.SetUpConfigDirectory" />). Out-of-the-box, of course, Naked
      Objects uses an in-memory object store, and so there are no issues
      running one scenario test against another.</para>

      <para>You can if you want though configure Naked Objects to go against a
      real database, for example by using the Hibernate-based object store
      provided by the <ulink url="http://jpaobjects.sourceforge.net">JPA
      Objects</ulink> sister project. In this case you will need to ensure
      that you reset the database at the end; Tested Objects doesn't provide
      any fixtures to help you though, so you are on your own here. An
      alternative might be to use JPA Objects against HSQLDB configured to for
      in-memory use. This would let you verify your database mappings, but
      without no need to tear anything down.</para>
    </sect1>

    <sect1 id="sec.SettingUpContinuousIntegration">
      <title>Set up Continuous Integration</title>

      <para>Since Tested Objects is a Maven application, it is easy enough to
      configure it to run under a CI server, such as <ulink
      url="http://hudson-ci.org/">Hudson</ulink>. If you google around you
      should be able find <ulink
      url="http://andypalmer.com/2009/04/showing-fitnesse-test-results-in-hudson/">a
      way</ulink> to publish the FitNesse test results through Hudson.</para>
    </sect1>
  </chapter>

  <appendix id="apx.Reference">
    <title>Reference</title>

    <para>This appendix shows the features of the common library, and how they
    are used by the framework-specific integrations.</para>

    <para>Note that due to licensing restrictions the
    <emphasis>FitNesse</emphasis> integration is not part of Apache Isis.
    Instead, it can be found in <ulink
    url="http://isis-contrib.sourceforge.net">isis-contrib</ulink>. We provide
    an overview of its features here for convenience.</para>

    <para></para>

    <sect1>
      <title>Bootstrapping</title>

      <para>The common library provides the <classname>Story</classname> class
      which holds a reference to a running <classname>IsisSystem</classname>.
      The means by which this bootstrapping occurs is specific to the
      <acronym>BDD</acronym> framework integration.</para>

      <table>
        <title>Bootstrapping</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Common</entry>

              <entry align="center">Concordion</entry>

              <entry align="center">FitNesse (isis-contrib)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>Story</classname><para>Provides a context for
              the story.</para></entry>

              <entry><classname>AbstractIsisConcordionTest</classname><para>Test
              cases should inherit from this class; provides access as
              inherited methods</para></entry>

              <entry><para><methodname>|StoryFixture|</methodname></para><para>Part
              of the bootstrapping of the test framework itself, typically
              referenced in the test suite's setup page. Should appear first
              within this setup.</para></entry>
            </row>

            <row>
              <entry><methodname>Story#bootstrapIsis(configDirectory,
              deploymentType)</methodname><para>Bootstraps the Isis runtime
              using the specified config directory (containing isis.properties
              config file) and deployment type. The latter should be either
              EXPLORATION (meaning exploration actions are enabled) or
              PROTOTYPE; no other values are valid.</para><para>Even if
              running in exploration mode, you should still call
              <filename>Story#logonAs()</filename> in order to indicate which
              user account to run the story as.</para></entry>

              <entry><methodname>#bootstrapIsis(String configDirectory,
              DeploymentType deploymentType)</methodname><para>Typically
              called from within a <methodname>@Before setUp()</methodname>
              method.</para><para><methodname>#bootstrapIsis(String
              configDirectory, String
              deploymentTypeStr)</methodname></para><para>Overloaded version
              callable from within <acronym>XHTML</acronym>; use if wish to
              make it clear how the bootstrapping has been
              performed.</para></entry>

              <entry><para><methodname>|BootstrapIsisConfiguredFrom|configDirectory|InMode|deploymentType|</methodname></para><para>Typically
              immediately after the call to
              <classname>StoryFixture</classname>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect1>

    <sect1>
      <title>SetUp</title>

      <para>The setup fixtures are used to specify the running application for
      a particular story's setup. Specifically, this means setting up the
      services that define the application, the effective date and the
      effective user. It also allows the setup of arbitrary objects (typically
      reference/static data objects; for transactional objects see <xref
      linkend="sec.UserInteraction" />).</para>

      <table>
        <title>SetUp</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Common</entry>

              <entry align="center">Concordion</entry>

              <entry align="center">FitNesse (isis-contrib)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>Story#dateAndTimeIs(java.util.Date)</classname><para>Sets
              the clock to a specific date and time.</para><para>This installs
              the <classname>FixtureClock</classname> as the implementation of
              the <classname>Clock</classname> singleton (in the applib). If
              this fixture is not called, then the default system clock is
              used, which gets the time from the host computer. The
              Story#debugClock () method (<xref linkend="sec.Debugging" />)
              can be used to verify the clock state.</para></entry>

              <entry><classname>#dateIs(String
              dateAndTimeStr)</classname><para><methodname>#dateIsNow(String
              dateAndTimeStr)</methodname></para><para><methodname>#timeIs(String
              dateAndTimeStr)</methodname></para><para><methodname>#timeIsNow(String
              dateAndTimeStr)</methodname></para><para>Intended to be called
              from the <acronym>XHTML</acronym>, as part of the "given".
              Parsed in format 'dd MMM yyyy hh:mm'</para></entry>

              <entry><para><methodname>|DateIs|dateAndTimeStr|</methodname></para><para><methodname>|DateIsNow|dateAndTimeStr|</methodname></para><para><methodname>|TimeIs|dateAndTimeStr|</methodname></para><para><methodname>|TimeIsNow|dateAndTimeStr|</methodname></para><para>Typically
              called early on in the test, as part of the "given". Parsed in
              format 'dd MMM yyyy hh:mm'</para></entry>
            </row>

            <row>
              <entry><methodname>Story#logonAsOrSwitchUserTo(String
              userName)</methodname><para>Logs on / switch user to as a
              specific
              user.</para><para><methodname>Story#logonAsOrSwitchUserTo(String
              userName, List&lt;String&gt;
              roleNames)</methodname></para><para>Logs on to a specific user,
              with specified roles. Part of the initialization for a
              particular story's setup, and typically referenced in the test
              suite or story's own setup page.</para><para>Also used for
              switching the current user within a story, eg to check a
              workflow between different users.</para></entry>

              <entry><methodname>#logonAs(String
              userName)</methodname><para><methodname>#logonAs(String
              userName, String roleListStr)</methodname></para><para>Intended
              to be called from the <acronym>XHTML</acronym>, as part of the
              "given". The role list, if specified, should be
              comma-separated.</para><methodname>#switchUserTo(String
              userName)</methodname><para><methodname>#switchUserTo(String
              userName, String roleListStr)</methodname></para><para>Switch
              the currently logged-on user to another user, optionally with
              specified roles.</para></entry>

              <entry><para><methodname>|LogonAs|userName|</methodname></para><para><methodname>|LogonAs|userName|WithRoles|roleList|</methodname></para><para>Typically
              called early on in the test, as part of the "given". The role
              list, if specified, should be
              comma-separated.</para><para><methodname>|SwitchUserTo|userName|</methodname></para><para><methodname>|SwitchUserTo|userName|WithRoles|roleList|</methodname></para><para>Switch
              the currently logged-on user to another user, optionally with
              specified roles.</para></entry>
            </row>

            <row>
              <entry><methodname>Story#getAliasRegistry()</methodname><para>and</para><para><methodname>AliasRegistry#aliasService(String
              aliasAs, String
              serviceClassName)</methodname></para><para>Specifies an alias to
              a service in order to invoke actions upon them.</para><para>Note
              that the services are <emphasis>not</emphasis> defined here,
              merely aliased. </para></entry>

              <entry><methodname>#aliasService(aliasAs, String
              serviceClassName)</methodname><para><methodname>#aliasServices(aliasAs,
              String serviceClassName)</methodname></para><para>Aliases a
              service. Typically called within a table.</para></entry>

              <entry><methodname>|AliasServices|</methodname><para><methodname>|className|alias=|</methodname></para><para>Two-column
              fixture, first column specifying class name and second column
              defining the alias.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <sect2 id="sec.AliasServices">
        <title>AliasServices</title>

        <para></para>

        <screenshot>
          <screeninfo>AliasServices</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/AliasServices.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.SetUpObjects">
        <title>SetUpObjects</title>

        <para id="sec.UsingNakedObjectsForViewer">Initializes objects.
        Typically used for immutable reference/standing data objects). Can
        also be to setup used for transaction/operational data objects (though
        UsingNakedObjectsViewerForSetup, <xref
        linkend="sec.UsingNakedObjectsViewer" />, is preferable). The
        DebugObjectStore fixture (<xref linkend="sec.DebugObjectStore" />) can
        be used to check the state of objects created.</para>

        <screenshot>
          <screeninfo>SetUpObjects</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/SetUpObjects.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>
    </sect1>

    <sect1 id="sec.UserInteraction">
      <title>User Interaction</title>

      <para>User interaction fixtures appear in the main body of the test, for
      the "given" (to setup the rest of the state of the system, typically
      transactional objects), for the "when" (the interaction being tested) or
      the "then" (assertions on the state after the interaction being
      tested).</para>

      <sect2 id="sec.UsingNakedObjectsViewer">
        <title>UsingNakedObjectsViewer /
        UsingNakedObjectsViewerForSetup</title>

        <para>Simulates interacting with domain objects as if through a
        viewer. Interact with objects, check their state, alias referenced or
        returned objects.</para>

        <para>The "ForSetup" version disables checks for visibility and
        usability, making it easier to reuse functionality for setting up
        objects prior to a test scenario (the "given"). The DebugObjectStore
        fixture (<xref linkend="sec.DebugObjectStore" />) can be used to check
        the state of objects created.</para>

        <screenshot>
          <screeninfo>UsingNakedObjectsViewer</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>Example usage:</para>

        <screenshot>
          <screeninfo>ExampleUsage</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.ExampleUsage.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On properties:</para>

        <screenshot>
          <screeninfo>On Properties</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnProperties.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On collections:</para>

        <screenshot>
          <screeninfo>On Collections</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnCollections.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On actions:</para>

        <screenshot>
          <screeninfo>On Actions</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnActions.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On objects:</para>

        <screenshot>
          <screeninfo>On Objects</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnObjects.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.CheckList">
        <title>CheckList</title>

        <para>Check items in list, either precisely or just for presence,
        using their title. Lists are either aliased results of actions, or
        aliased collections within objects.</para>

        <para>Typically used in the "Then", though can be helpful as a way of
        confirming/documenting a "Given".</para>

        <para>See also AliasItemsInList (<xref
        linkend="sec.AliasItemsInList" />), which also performs an implicit
        check (will fail if the objects are not in the list) and aliases them
        for further use.</para>

        <screenshot>
          <screeninfo>CheckList</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/CheckList.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.AliasItemsInList">
        <title>AliasItemsInList</title>

        <para>Allows an alias to be associated with items in a list. The list
        items are located by their title, and are presumed to exist. This
        fixture can therefore also be used as a way of checking for presence
        of items in a list (similar to CheckList, <xref
        linkend="sec.CheckList" />).</para>

        <para>Typically used both in the "Given" (to simplify writing the rest
        of a test).</para>

        <screenshot>
          <screeninfo>AliasItemsInList</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/AliasItemsInList.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>
    </sect1>

    <sect1 id="sec.Debugging">
      <title>Debugging</title>

      <para>Debugging and diagnostics. Useful for checking setup, for
      example.</para>

      <sect2 id="sec.DebugServices">
        <title>DebugServices</title>

        <para>Lists service class names, as picked up from configuration.
        Useful with AliasServices (see <xref
        linkend="sec.AliasServices" />).</para>

        <screenshot>
          <screeninfo>DebugServices</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/DebugServices.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.DebugClock">
        <title>DebugClock</title>

        <para>Reads the current value of the clock. Useful for debugging and
        diagnostics.</para>

        <screenshot>
          <screeninfo>DebugClock</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/DebugClock.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.DebugObjectStore">
        <title>DebugObjectStore</title>

        <para>Dumps the contents of the object store. Useful for debugging
        setup (through SetupObjects, <xref linkend="sec.SetUpObjects" />, and
        UsingNakedObjectsViewerForSetup, <xref
        linkend="sec.UsingNakedObjectsViewer" />).</para>

        <screenshot>
          <screeninfo>DebugObjectStore</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/DebugObjectStore.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.CheckSpecificationsLoaded">
        <title>CheckSpecificationsLoaded</title>

        <para>Verifies that listed NakedObjectSpecifications have been loaded
        into the metamodel.</para>

        <screenshot>
          <screeninfo>CheckSpecificationsLoaded</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/CheckSpecificationsLoaded.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.RunViewer">
        <title>RunViewer</title>

        <para>Runs up the DnD viewer with the current state of the objects.
        This is a great way to inspect the state of the system, for example if
        a test is failing and you can't see why.</para>

        <para>Of course, other alternatives are writing unit tests and
        debugging with break points. But failing scenario tests usually arise
        because of an integration issue between two different bits of the
        system. Being able to have a "poke around" can be invaluable.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Tear Down</title>

      <para>The opposite of setting up...</para>

      <sect2>
        <title>ShutDownNakedObjects</title>

        <para>This fixture shuts down the Naked Objects runtime, releasing
        memory and so on. A good place to put this is in the test's <ulink
        url="http://fitnesse.org/FitNesse.UserGuide.SpecialPages">TearDown</ulink>
        page (which could be inherited).</para>
      </sect2>
    </sect1>
  </appendix>
</book>
