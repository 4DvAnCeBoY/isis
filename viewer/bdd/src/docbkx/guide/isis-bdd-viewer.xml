<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./src/docbkx/dtd-4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para>Behaviour-driven development is a means to drive the development of
    an application through stories and scenarios. These are expressed in a
    semi-formal textual form that can be understood (or indeed be written) by
    the domain expert/business analyst, but which can then be used to directly
    exercise the system under test as it is developed.</para>

    <para>A number of frameworks exist to streamline this process. Generally
    these require the developer to write glue code that acts as a bridge from
    the textual specification and the system under test.</para>

    <para>The <emphasis>BDD Viewer</emphasis> module for <emphasis>Apache
    Isis</emphasis> aims to allow <acronym>BDD</acronym> stories/scenarios to
    be written against the domain model of an Isis application, without the
    developer having to write any glue code. It consists of a common library
    that abstracts the interaction with the Isis metamodel, along with an
    integration (that uses this common library) for one particular
    <acronym>BDD</acronym> framework, namely <ulink
    url="http://concordion.org">Concordion</ulink>.</para>

    <para>This user guide describes how to use the Concordion integration,
    along with details of the common library so that other BDD frameworks can
    be integrated if required.</para>

    <para><emphasis>Apache Isis</emphasis> is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>
  </preface>

  <!-- main content -->

  <chapter>
    <title>Introduction</title>

    <sect1>
      <title>Behaviour-driven Development</title>

      <para>Prior to agile development, requirements gathering for systems was
      traditionally performed by business analysts discussing requirements
      with the business, and expressing those requirements in documentation,
      such as Word specs and perhaps spreadsheets. The acceptance criteria for
      such requirements were often only sketched out, if at all; it would
      normally fall to the system testers to write acceptance tests for the
      requirements, through a mixture of consulting the original (by now
      out-of-date) requirements documentation and (as often as not)
      reverse-engineering the implementation.</para>

      <para>Behaviour-driven development combines requirements capture and the
      acceptance test criteria in a single form, through scenarios. As before,
      these requirements are in a form that a non-technical domain expert from
      the business can understand. What differs though is that these scenarios
      can be used directly exercise the system, and so also represent the
      acceptance tests for the scenario. Moreover, the results of these tests
      are rendered in such a way that the business can understand, and thus
      can help determine if the code is at fault or the test. Once
      implemented, the acceptance tests also act as a regression suite for the
      system.</para>

      <para>Scenario tests tend to act against a complete system, or sometimes
      at a subsystem-level. At any rate at a granularity that makes sense to a
      non-technical businesss person. Compare this to unit testing which
      exercises the behaviour / method of a single class.</para>

      <para>Scenario testing is closely related to (and sometimes a synonym
      for) "agile acceptance testing"; I must admit though that I find that
      term rather clumsy.</para>
    </sect1>

    <sect1>
      <title>Concordion Integration</title>

      <sect2>
        <title>Introduction to Concordion</title>

        <para><ulink url="http://concordion.org">Concordion</ulink> is a
        framework to enable scenario testing. It is implemented as a <ulink
        url="http://junit.org">JUnit4</ulink> test runner, with the test form
        being written in <acronym>XHTML</acronym>. The domain expert /
        business analyst authors new stories using an <acronym>XML</acronym>
        editor (<ulink url="http://xmlmind.net">XmlMind</ulink> is one
        commercial editor that we recommend); once executed as tests, the
        results are shown as the same XHTML document, annotated to indicate
        which assertions have succeeded, and which have failed. It also
        creates an efficient feedback loop; a Concordion test will "keep on
        going" even if it hits a failure. Thus the developer can identify
        several issues and fix them in a single pass.</para>

        <para>Another way to think of Concordion is as a replacement
        presentation layer, hitting the underlying domain model in the same
        way that the regular <acronym>UI</acronym> would. (This is why we call
        this module is called the <acronym>BDD
        </acronym><emphasis>viewer</emphasis>).</para>

        <para><acronym>Concordion</acronym> works using a "convention over
        configuration" approach, matching the <acronym>XHTML</acronym> text
        file with a corresponding JUnit4 test run set up to run using
        Concordion's <classname>ConcordionRunner</classname>, The developer
        then annotates the <acronym>XHTML</acronym> using special
        (Concordion-namespaced) attributes in order identify the inputs to and
        expected results of the test. This is used by the
        <classname>ConcordionRunner</classname> to call into corresponding
        methods in the test.</para>

        <para>For example, suppose the analyst writes a scenario test called
        <filename>CustomerPlacesOrder.xhtml</filename>. In the
        <acronym>XHTML</acronym> the analyst has identified the details of the
        customer doing the ordering (customer ref 4321, say), the product
        being ordered (product code 1234), the fact that the customer
        initially has no orders, and that the customer has no invoices
        outstanding. The test concludes with an assertion that there is now an
        unfulfilled order for the customer, and that the customer now has an
        invoice to be paid.</para>

        <para>The developer in turn edits the <acronym>XHTML</acronym>,
        identifying the customer and the product. He then further edits the
        <acronym>XHTML</acronym> to call a method in the JUnit4 test
        representing the placing of an order:
        <methodname>placeOrder()</methodname>, say. And he finishes by
        annotating the <acronym>XHTML</acronym> to make assertions about the
        post conditions (unfulfilled order, new invoice to be paid
        etc).</para>

        <para>Then, the developer writes a JUnit4 test alongside the
        <acronym>XHTML</acronym>; in this example it would be called
        <filename>CustomerPlacesOrderTest.java</filename>. Concordion calls
        into this JUnit4 test as it comes across the annotations in the
        <acronym>XHTML</acronym>, and the JUnit4 test mediates with the system
        under test.</para>

        <para>When the test runs, Concordion generates a copy of the
        <acronym>XHTML</acronym> in a output directory (by default specified
        by a system property) which can then made available for inspection by
        the business analyst (eg published on a website).</para>

        <para>The Concordion website has a good <ulink
        url="http://concordion.org/Tutorial.html">tutorial</ulink> that
        demonstrates all the above, and can be completed in 20~30
        minutes.</para>
      </sect2>

      <sect2>
        <title>How the Isis/Concordion Integration Works</title>

        <para>Although you could test an Apache Isis application using vanilla
        Concordion, this would entail you having to write all the glue code
        yourself to interact with the domain objects. You would also need to
        encode the rules that are normally implemented by the viewer, eg so
        that a hidden action cannot be invoked, and an invalid value for a
        property cannot be set.</para>

        <para>The <emphasis>BDD viewer</emphasis> integration provided by
        <emphasis>Apache Isis</emphasis> works by providing a superclass for
        the JUnit4 test, called
        <classname>AbstractIsisConcordionTest</classname>. This does several
        things:</para>

        <itemizedlist>
          <listitem>
            <para>it bootstraps an instance of <emphasis>Apache
            Isis</emphasis> system using the in-memory object store;</para>
          </listitem>

          <listitem>
            <para>the system is initialized with a set of services, picked up
            from the <filename>isis.properties</filename> configuration
            file</para>
          </listitem>

          <listitem>
            <para>it provides methods to allow fixtures (domain objects) to be
            installed into the object store</para>
          </listitem>

          <listitem>
            <para>it provides methods to allow a user to be logged in, and the
            date to be specified</para>
          </listitem>

          <listitem>
            <para>it provides methods to allow the user to interact with
            services and domain objects:</para>

            <itemizedlist>
              <listitem>
                <para>asserting on the value of properties and the contents of
                collections</para>
              </listitem>

              <listitem>
                <para>setting the value of a property (if valid) and adding
                to/removing from a collection (if valid)</para>
              </listitem>

              <listitem>
                <para>invoking actions</para>
              </listitem>

              <listitem>
                <para>asserting on the state of a class member (hidden,
                disabled or enabled)</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>For each <acronym>XHTML</acronym> scenario test, the developer
        writes subclasses the AbstractIsisConcordionTest, creating a name
        matching the scenario test (ie as per regular Concordion). He
        then</para>

        <para>annotates the original <acronym>XHTML</acronym>, either calling
        directly into the inherited methods, or writing small simple methods
        to delegate to these inherited methods as required. The Concordion
        website has some <ulink
        url="http://concordion.org/Technique.html">hints and tips</ulink> to
        help you find the right balance between these two approaches.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Common Library</title>

      <para>The Concordion integration is based on a library that factors out
      interactions with the running Isis system. This library is intended to
      make it easy to support other BDD frameworks if required.<footnote>
          <para>In fact, the first BDD framework integration was to <ulink
          url="http://fitnesse.org">FitNesse</ulink>. This has now been
          dropped because FitNesse has an incompatible license with Apache
          Software Foundation. The original FitNesse code can still be found
          on the <ulink
          url="http://isis-contrib.sourceforge.net">Isis-contrib</ulink>
          companion site, and does indeed use the common library.</para>
        </footnote></para>

      <para>The main concepts that the common library exposes are:</para>

      <itemizedlist>
        <listitem>
          <para>AliasItemsInListPeer</para>
        </listitem>

        <listitem>
          <para>AliasServicesPeer</para>
        </listitem>

        <listitem>
          <para>CheckListPeer</para>
        </listitem>

        <listitem>
          <para></para>
        </listitem>
      </itemizedlist>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter id="chp.HintsAndTips">
    <title>Hints and Tips</title>

    <para>This chapter contains a collection of hints, tips and suggestions
    for writing your own tests.</para>

    <para>For further guidance, check out Gojko Adzic's book, <ulink
    url="http://www.acceptancetesting.info/the-book/">Bridging the
    Communication Gap</ulink>.</para>

    <sect1>
      <title>Separate In-Progress Stories from the Backlog</title>

      <para>If you are using an agile methodology then you will be
      implementing a number of stories per iteration; the remainder will be in
      a backlog. When you select a story for implementation, create a new page
      for it in a "CurrentIteration" suite. The objective for the team is
      therefore to get the entire CurrentIteration suite green.</para>

      <para>Other stories that you may have identified but not selected for
      the iteration can remain in a Backlog suite.</para>
    </sect1>

    <sect1>
      <title>Use a Story Page to Collect A Set of Scenario Tests</title>

      <para>Part of estimating the size of a story includes identifying the
      acceptance criteria. These can be created as children of the story page
      as placeholders, so that the story page becomes a suite. The child
      scenario tests can be fleshed out as required with plain text during the
      estimation meeting, and with actual FitNesse tests once the iteration
      starts. The FitNesse <ulink
      url="http://fitnesse.org/FitNesse.UserGuide.MarkupContents">!contents</ulink>
      instruction will then list all the acceptance criteria for the
      story.</para>

      <para>For the story page itself, the "as a ... I want ... so that... "
      template is a good way to summarize the intent of the story.</para>
    </sect1>

    <sect1>
      <title>Organize Completed Stories by Component</title>

      <para>Once you have completed an iteration and implements its stories,
      move those stories out to the relevant component that the story relates
      to. The scenario tests for stories ultimately <emphasis>are</emphasis>
      the documentation of the behaviour of the system. A year on you won't
      remember (and won't care) which iteration you implemented a story,
      you'll be searching for it by the component whose behaviour you want to
      understand.</para>
    </sect1>

    <sect1>
      <title>Structure your test using Given/When/Then</title>

      <para>A standard template for organizing structuring tests is
      given/when/then<footnote>
          <para>As first described, I believe, by Dan North in a blog post,
          <ulink url="http://dannorth.net/introducing-bdd">Introducing
          BDD</ulink>.</para>
        </footnote>:</para>

      <itemizedlist>
        <listitem>
          <para>given ... the system is in this particular state</para>
        </listitem>

        <listitem>
          <para>when ... this interesting thing happens</para>
        </listitem>

        <listitem>
          <para>then ... these are the consequences</para>
        </listitem>
      </itemizedlist>

      <para>This structure is readily understood by non-technical business
      users, and helps them (and the team) focus on the point of the
      test.</para>

      <para>In terms of mechanics, one approach is to put the "given" into the
      setup page for a test, with the "when" and the "then" in separate
      pages.d</para>
    </sect1>

    <sect1 id="sec.UsingTheFixtureViewer">
      <title>Using the RunViewer fixture</title>

      <para>The "given" can often be the hardest part to get setup. To check
      it, we can use the <classname>RunViewer</classname> fixture (see <xref
      linkend="sec.RunViewer" />). This will run up the drag-n-drop viewer at
      the specified point in the test; a visual equivalent of
      <code>System.out.println()</code>, really. We can therefore take the
      Given page and add a RunViewer fixture at the end.</para>

      <para>Note that to do this you must temporarily mark the Given page as a
      <ulink url="http://fitnesse.org/FitNesse.UserGuide.PageProperties">test
      page</ulink>.</para>
    </sect1>

    <sect1 id="sec.FactorOutCommonGivens">
      <title>Factor out common "Given"s</title>

      <para>Just like code, tests need to be actively managed, because if the
      tests become hard to maintain, they'll end up being deleted. In fact, we
      probably should take even more care with the tests than the code if they
      represent the primary documentation of the behaviour of the
      system.</para>

      <para>In terms of size, the "given" is far larger than either the "when"
      or the "then", and therefore this is the area where tests can quickly
      become unmaintainable. So instead, try to factor out your givens into
      separate pages.</para>

      <para>For example:</para>

      <itemizedlist>
        <listitem>
          <para>if using Concordion, you can use &lt;a href's&gt; with a
          concordion:execute tag to include another page.</para>
        </listitem>

        <listitem>
          <para>if usingFitNesse, then use it's <ulink
          url="http://fitnesse.org/FitNesse.UserGuide.MarkupPageInclude">!include</ulink>
          directive to assemble the pages you need</para>
        </listitem>
      </itemizedlist>

      <para>The names of these pages should also follow a declarative style,
      see <xref linkend="sec.UseADeclarativeStyle" />.</para>
    </sect1>

    <sect1 id="sec.UseADeclarativeStyle">
      <title>Use a Declarative Style for Page Names</title>

      <para>When factoring out "given"s (see <xref
      linkend="sec.FactorOutCommonGivens" />), or indeed when writing the
      "when"s and the "then"s, use a declarative style for the pages. The page
      should describe what it does, not how it does it.</para>

      <para>For example, a good page would be "SetUpCountries". It's clear
      that this will set up all <classname>Country</classname> reference data
      classes. This could be included into a "SetUpReferenceData" page. For
      transaction data, we could have a page "JoeBloggsCustomer"; another one
      again could be "JoeBloggsFiveOrders".</para>
    </sect1>

    <sect1 id="sec.SettingUpContinuousIntegration">
      <title>Set up Continuous Integration</title>

      <para>Since Isis is a Maven application, it is easy enough to configure
      it to run under a CI server, such as <ulink
      url="http://hudson-ci.org/">Hudson</ulink>. If you google around you
      should also be able find a way to make Hudson publish the test results
      onto a website so that they can be inspected by your domain experts /
      business analysts.</para>
    </sect1>
  </chapter>

  <appendix id="apx.Reference">
    <title>Reference</title>

    <para>This appendix shows the features of the common library, and how they
    are used by the framework-specific integrations.</para>

    <para>Note that due to licensing restrictions the
    <emphasis>FitNesse</emphasis> integration is not part of Apache Isis.
    Instead, it can be found in <ulink
    url="http://isis-contrib.sourceforge.net">isis-contrib</ulink>. We provide
    an overview of its features here for convenience.</para>

    <para></para>

    <sect1>
      <title>Bootstrapping</title>

      <para>The common library provides the <classname>Story</classname> class
      which holds a reference to a running <classname>IsisSystem</classname>.
      The means by which this bootstrapping occurs is specific to the
      <acronym>BDD</acronym> framework integration.</para>

      <table>
        <title>Bootstrapping</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Common</entry>

              <entry align="center">Concordion</entry>

              <entry align="center">FitNesse (isis-contrib)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><classname>Story</classname><para>Provides a context for
              the story.</para></entry>

              <entry><classname>AbstractIsisConcordionTest</classname><para>Test
              cases should inherit from this class; provides access as
              inherited methods</para></entry>

              <entry><para><methodname>|StoryFixture|</methodname></para><para>Part
              of the bootstrapping of the test framework itself, typically
              referenced in the test suite's setup page. Should appear first
              within this setup.</para></entry>
            </row>

            <row>
              <entry><methodname></methodname><para>Bootstraps the Isis
              runtime using the specified config directory (containing
              isis.properties config file) and deployment type. The latter
              should be either EXPLORATION (meaning exploration actions are
              enabled) or PROTOTYPE; no other values are
              valid.</para><para></para></entry>

              <entry><methodname>#bootstrapIsis(String configDirectory,
              DeploymentType deploymentType)</methodname><para>Typically
              called from within a <methodname>@Before setUp()</methodname>
              method.</para><para><methodname>#bootstrapIsis(String
              configDirectory, String
              deploymentTypeStr)</methodname></para><para>Overloaded version
              callable from within <acronym>XHTML</acronym>; use if wish to
              make it clear how the bootstrapping has been
              performed.</para></entry>

              <entry><para><methodname>|BootstrapIsisConfiguredFrom|configDirectory|InMode|deploymentType|</methodname></para><para>Typically
              immediately after the call to
              <classname>StoryFixture</classname>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <sect2>
        <title>Story Context</title>

        <para>The common library provides an object to represent the story
        context to manage such things as the Isis configuration, the date/time
        that the story is running as, the user that is logged-in, and managing
        the aliases of objects so that they can be interacted with.</para>

        <sect3>
          <title>Common</title>

          <para>An instance of the <classname>Story</classname> class provides
          a context for the story. Framework integrations are expected to
          instantiate this class, and then use it as the primary means to
          interact with the system.</para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para>The <classname>AbstractIsisConcordionTest</classname>
          instantiates the <classname>Story</classname> and provides methods
          that can be invoked from within <acronym>XHTML</acronym> (ie taking
          <classname>String</classname>s). Test cases should inherit from this
          abstract class, with the <acronym>XHTML</acronym> typically calling
          to the inherited methods directly. The developer may optionally add
          small helper methods to be called from the <acronym>XHTML</acronym>
          instead; these can factor out any boilerplate in the script.</para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para>The <classname>StoryFixture</classname> fixture is a
          <acronym>FIT</acronym> <classname>DoFixture</classname> that
          provides the overall context for the framework. Whereas other
          fixtures are instantiated once per table, the
          <classname>StoryFixture</classname> exists for the duration of the
          test page. It should typically be referenced in the test suite's
          setup page, and should appear first within this setup.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Bootstrapping Isis</title>

        <para>An Isis runtime can be bootstrapped with a single call. This
        installs no-op implementations of some of the main components, along
        with an in-memory object store.</para>

        <sect3>
          <title>Common</title>

          <para>The <methodname>Story#bootstrapIsis(String configDirectory,
          DeploymentType deploymentType)</methodname> is used to bootstrap the
          Isis runtime:</para>

          <itemizedlist>
            <listitem>
              <para>The specified config directory contains
              <filename>isis.properties</filename> config file, from which the
              services are registered. Any fixtures in that properties file
              are ignored (the <acronym>BDD</acronym> integration requires
              that any objects are created through the test scripts, see <xref
              linkend="sec.SetUpObjects" /> and <xref
              linkend="sec.UsingIsisViewer" />).</para>
            </listitem>

            <listitem>
              <para>The deployment type must be either EXPLORATION (meaning
              exploration actions are enabled) or PROTOTYPE; no other values
              are valid).</para>
            </listitem>
          </itemizedlist>

          <para>Even if running in exploration mode, you must still logon (see
          <xref linkend="sec.LogonAsSwitchUserTo" />) in order to indicate
          which user account to run the story as.</para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para>The <classname>AbstractIsisConcordionTest</classname> class
          provides two overloaded versions of
          <methodname>bootstrapIsis(...)</methodname> method:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>#bootstrapIsis(String configDirectory,
              DeploymentType deploymentType)</methodname></para>

              <para>Intended to be called from within an <methodname>@Before
              setUp()</methodname> method, when there's no particular need to
              document the bootstrapping process within the story</para>
            </listitem>
          </itemizedlist>

          <itemizedlist>
            <listitem>
              <para><methodname>#bootstrapIsis(String configDirectory, String
              deploymentType):boolean</methodname></para>

              <para>Intended to be called from the <acronym>XHTML</acronym>
              page, allowing the story document the bootstrapping process. For
              example, to bootstrap in exploration mode, use:</para>

              <programlisting>&lt;p concordion:execute="#result=bootstrapIsis(#configDir,#deploymentType)"&gt;
Isis system &lt;span concordion:assertTrue="#result"&gt;bootstrapped&lt;/span&gt; from config directory &lt;span concordion:set="#configDir"&gt;../quickrun/config&lt;/span&gt; and running in &lt;span concordion:set="#deploymentType"&gt;exploration&lt;/span&gt; mode.
&lt;/p&gt;</programlisting>

              <para>The method always returns <literal>true</literal>, but any
              runtime exception will propagate to the generated page.</para>
            </listitem>
          </itemizedlist>

          <para>Whichever method is used, they both delegate to the common
          <methodname>Story#bootstrapIsis(...)</methodname> method.</para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para>The <classname>BootstrapIsisConfiguredFromInMode</classname>
          fixture is used to bootstrap Isis. It takes the form:</para>

          <informaltable>
            <tgroup cols="4">
              <colspec colwidth="3*" />

              <tbody>
                <row>
                  <entry><classname>Bootstrap Isis Configured
                  From</classname></entry>

                  <entry><emphasis>config Directory</emphasis></entry>

                  <entry><methodname>In Mode</methodname></entry>

                  <entry><emphasis>deployment Type</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>This delegates to the common
          <methodname>Story#bootstrapIsis(...)</methodname> method.</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>SetUp</title>

      <para>The setup fixtures are used to specify the running application for
      a particular story's setup. Specifically, this means setting up the
      services that define the application, the effective date and the
      effective user. It also allows the setup of arbitrary objects (typically
      reference/static data objects; for transactional objects see <xref
      linkend="sec.UserInteraction" />).</para>

      <table>
        <title>SetUp</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Common</entry>

              <entry align="center">Concordion</entry>

              <entry align="center">FitNesse (isis-contrib)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><methodname></methodname><para>and</para><para><methodname></methodname></para><para></para><para>
              </para></entry>

              <entry><methodname>#aliasService(aliasAs, String
              serviceClassName)</methodname><para><methodname>#aliasServices(aliasAs,
              String serviceClassName)</methodname></para><para>Aliases a
              service. Typically called within a table.</para></entry>

              <entry><methodname>|AliasServices|</methodname><para><methodname>|className|alias=|</methodname></para><para>Two-column
              fixture, first column specifying class name and second column
              defining the alias.</para></entry>
            </row>

            <row>
              <entry><methodname>Story#getAliasRegistry()</methodname><para>and</para><para><methodname>AliasRegistry#aliasService(String
              aliasAs, String
              serviceClassName)</methodname></para><para>Specifies an alias to
              a service in order to invoke actions upon them.</para><para>Note
              that the services are <emphasis>not</emphasis> defined here,
              merely aliased. </para></entry>

              <entry><methodname>#aliasService(aliasAs, String
              serviceClassName)</methodname><para><methodname>#aliasServices(aliasAs,
              String serviceClassName)</methodname></para><para>Aliases a
              service. Typically called within a table.</para></entry>

              <entry><methodname>|AliasServices|</methodname><para><methodname>|className|alias=|</methodname></para><para>Two-column
              fixture, first column specifying class name and second column
              defining the alias.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <sect2 id="sec.LogonAsSwitchUserTo">
        <title>Logging On / Switching User</title>

        <para>Used to specify the currently logged-on user. Should always be
        called near the top of the story, as part of the "given". Can also be
        used for switching the current user later on in the story, eg to check
        a workflow between different users.</para>

        <sect3>
          <title>Common</title>

          <para>The common library provides two overloaded methods, depending
          on whether the roles for the user need to be specified or
          not:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>Story#logonAsOrSwitchUserTo(String
              userName)</methodname></para>

              <para>Logs on / switch user to as a specific user.</para>
            </listitem>

            <listitem>
              <para><methodname>Story#logonAsOrSwitchUserTo(String userName,
              List&lt;String&gt; roleNames)</methodname></para>

              <para>Logs on to a specific user, with specified roles. Part of
              the initialization for a particular story's setup, and typically
              referenced in the test suite or story's own setup page.</para>
            </listitem>
          </itemizedlist>

          <para>The username and roles are not validated against.</para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para>The Concordion integration provides two sets of overloaded
          methods:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>#logonAs(String userName)</methodname> and
              <methodname>#logonAs(String userName, String
              roleListStr)</methodname></para>

              <para>Intended to be called in the initial setup, as part of the
              story's "given".</para>
            </listitem>

            <listitem>
              <para><methodname>#switchUserTo(String userName)</methodname>
              and <methodname>#switchUserTo(String userName, String
              roleListStr)</methodname></para>

              <para>(Optional); intended to be called later on in the story,
              eg, to test workflow.</para>
            </listitem>
          </itemizedlist>

          <para>Each of these is intended to be called from the
          <acronym>XHTML</acronym>. For example:</para>

          <programlisting>&lt;p concordion:execute="#result=logonAs(#userName)"&gt;&lt;span concordion:assertTrue="#result"&gt;logged on&lt;/span&gt; as &lt;span concordion:set="#userName"&gt;fsmith&lt;/span&gt;&lt;/p&gt;</programlisting>

          <para>The role list, if specified, should be comma-separated (any
          white space will be ignored).</para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para>The FitNesse integration provides two sets of overloaded
          fixtures:</para>

          <informaltable>
            <tgroup cols="2">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Logon As</classname></entry>

                  <entry><emphasis>user name</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <informaltable>
            <tgroup cols="4">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Logon As</classname></entry>

                  <entry><emphasis>user name</emphasis></entry>

                  <entry><classname>With Roles</classname></entry>

                  <entry><emphasis>role list</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Intended to be called in the initial setup, as part of the
          story's "given".</para>

          <informaltable>
            <tgroup cols="2">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Switch User To</classname></entry>

                  <entry><emphasis>user name</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <informaltable>
            <tgroup cols="4">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Switch User To</classname></entry>

                  <entry><emphasis>user name</emphasis></entry>

                  <entry><classname>With Roles</classname></entry>

                  <entry><emphasis>role list</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Optional; intended to be called later on in the story, eg, to
          test workflow.</para>

          <para>The role list, if specified, should be comma-separated (any
          white space will be ignored).</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Setting Date and Time</title>

        <para>Sets the story's clock to a specific date and time. Stories that
        deal with domain objects that use the clock (eg for the defaulting of
        a date/time property) will typically need to call this fixture.</para>

        <para>Typically called within the "given", though may be called many
        times throughout the story.</para>

        <sect3>
          <title>Common</title>

          <para><methodname>Story#dateAndTimeIs(java.util.Date)</methodname></para>

          <para>This fixture installs the <classname>FixtureClock</classname>
          as the implementation of the <classname>Clock</classname> singleton
          (in the applib). Every call to the <classname>Clock</classname> will
          return the same date/time until the method is called again.</para>

          <para>If this fixture is not called, then the default system clock
          is used, which gets the time from the host computer. The
          <methodname>Story#debugClock()</methodname> method (<xref
          linkend="sec.DebugClock" />) can be used to verify the clock
          state.</para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para>The Concordion integration provides a number of overloaded
          methods, all designed to be called from the
          <acronym>XHTML</acronym>:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>#dateIs(String
              dateAndTimeStr)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>#timeIs(String
              dateAndTimeStr)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>For example:</para>

          <programlisting>&lt;p concordion:execute="#result=timeIs(#dateTime)"&gt;The &lt;span concordion:assertTrue="#result"&gt;date/time&lt;/span&gt; is &lt;span concordion:set="#dateTime"&gt;2 mar 2007 09:20&lt;/span&gt;.&lt;/p&gt; </programlisting>

          <para>The overloaded forms are just for convenience; sometimes the
          story will want to emphasis the date, other times the time. In all
          case the date/time provided is parsed against the format 'dd MMM
          yyyy hh:mm'</para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para>The FitNesse integration provides four versions (overloaded
          only so reads well in the page):</para>

          <informaltable>
            <tgroup cols="2">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Date Is</classname></entry>

                  <entry><emphasis>date and time</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <informaltable>
            <tgroup cols="2">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Date Is Now</classname></entry>

                  <entry><emphasis>date and time</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <informaltable>
            <tgroup cols="2">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Time Is</classname></entry>

                  <entry><emphasis>date and time</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <informaltable>
            <tgroup cols="2">
              <colspec />

              <tbody>
                <row>
                  <entry><classname>Time Is Now</classname></entry>

                  <entry><emphasis>date and time</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>In each case the date/time provided is parsed against the
          format 'dd MMM yyyy hh:mm'</para>
        </sect3>
      </sect2>

      <sect2 id="sec.AliasServices">
        <title>Aliasing Services</title>

        <para>Specifies an alias to a service in order to invoke actions upon
        it. Typically this will be done for most if not all of the registered
        repositories. The class name (as defined in
        <filename>isis.properties</filename>) is used as the key; the alias
        defines a simple handle.</para>

        <para>For example, a service
        <classname>com.mycompany.customers.defaults.CustomerRepositoryDefault</classname>
        can be mapped to "customers".</para>

        <sect3>
          <title>Common</title>

          <para>The common library provides two methods:<itemizedlist>
              <listitem>
                <para><methodname>Story#getAliasRegistry()</methodname></para>
              </listitem>

              <listitem>
                <para><methodname>AliasRegistry#aliasService(String aliasAs,
                String serviceClassName)</methodname></para>
              </listitem>
            </itemizedlist></para>

          <para>The <acronym>BDD</acronym> framework integration is expected
          to obtain the <classname>AliasRegistry</classname> from the
          <classname>Story</classname>, and then use the
          <classname>AliasRegisty</classname> to register the alias.</para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para>The Concordion integration provides a corresponding method,
          <methodname>#aliasService(aliasAs, String
          serviceClassName)</methodname>. This returns <literal>true</literal>
          if the service was found, false otherwise. Call within a table to
          alias multiple services, for example:<programlisting>&lt;table concordion:execute="#result=aliasService(#aliasAs, #className)"&gt;
  &lt;tr&gt;
    &lt;th concordion:set="#className"&gt;Class Name&lt;/th&gt;
    &lt;th concordion:set="#aliasAs"&gt;aliasAs&lt;/th&gt;
    &lt;th concordion:assertTrue="#result"/&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;com.mycompany.myapp.objstore.dflt.claim.ClaimRepositoryDefault&lt;/td&gt;
    &lt;td&gt;claims&lt;/td&gt;
    &lt;td&gt;ok&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;com.mycompany.myapp.objstore.dflt.employee.EmployeeRepositoryDefault&lt;/td&gt;
    &lt;td&gt;employees&lt;/td&gt;
    &lt;td&gt;ok&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</programlisting></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para>The FitNesse integration provides an implementation of a
          <classname>ColumnFixture</classname>, which is used as
          follows:</para>

          <para><informaltable>
              <tgroup cols="2">
                <colspec colname="_1" />

                <colspec colname="_2" />

                <tbody>
                  <row>
                    <entry nameend="_2" namest="_1"><classname>Alias
                    Services</classname></entry>
                  </row>

                  <row>
                    <entry><classname>class name</classname></entry>

                    <entry><classname>alias=</classname></entry>
                  </row>

                  <row>
                    <entry><emphasis>com.mycompany.myapp.objstore.dflt.claim.ClaimRepositoryDefault</emphasis></entry>

                    <entry><emphasis>claims</emphasis></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable></para>
        </sect3>
      </sect2>

      <sect2 id="sec.SetUpObjects">
        <title>Setting Up Objects</title>

        <para>Initializes objects. Typically used for immutable
        reference/standing data objects). Can also be to setup used for
        transaction/operational data objects (though
        UsingNakedObjectsViewerForSetup, <xref
        linkend="sec.UsingNakedObjectsViewer" />, is preferable). The
        DebugObjectStore fixture (<xref linkend="sec.DebugObjectStore" />) can
        be used to check the state of objects created.</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id="sec.UserInteraction">
      <title>User Interaction</title>

      <para>User interaction fixtures appear in the main body of the test, for
      the "given" (to setup the rest of the state of the system, typically
      transactional objects), for the "when" (the interaction being tested) or
      the "then" (assertions on the state after the interaction being
      tested).</para>

      <sect2 id="sec.UsingIsisViewer">
        <title>Using Isis Viewer / Using Isis Viewer For Setup</title>

        <para></para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2>
        <title>Check List</title>

        <para></para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2>
        <title>Alias Items In List</title>

        <para></para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2 id="sec.UsingNakedObjectsViewer">
        <title>UsingNakedObjectsViewer /
        UsingNakedObjectsViewerForSetup</title>

        <para>Simulates interacting with domain objects as if through a
        viewer. Interact with objects, check their state, alias referenced or
        returned objects.</para>

        <para>The "ForSetup" version disables checks for visibility and
        usability, making it easier to reuse functionality for setting up
        objects prior to a test scenario (the "given"). The DebugObjectStore
        fixture (<xref linkend="sec.DebugObjectStore" />) can be used to check
        the state of objects created.</para>

        <screenshot>
          <screeninfo>UsingNakedObjectsViewer</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>Example usage:</para>

        <screenshot>
          <screeninfo>ExampleUsage</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.ExampleUsage.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On properties:</para>

        <screenshot>
          <screeninfo>On Properties</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnProperties.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On collections:</para>

        <screenshot>
          <screeninfo>On Collections</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnCollections.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On actions:</para>

        <screenshot>
          <screeninfo>On Actions</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnActions.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>On objects:</para>

        <screenshot>
          <screeninfo>On Objects</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/UsingNakedObjectsViewer.PerformOnObjects.png"
                         scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.CheckList">
        <title>CheckList</title>

        <para>Check items in list, either precisely or just for presence,
        using their title. Lists are either aliased results of actions, or
        aliased collections within objects.</para>

        <para>Typically used in the "Then", though can be helpful as a way of
        confirming/documenting a "Given".</para>

        <para>See also AliasItemsInList (<xref
        linkend="sec.AliasItemsInList" />), which also performs an implicit
        check (will fail if the objects are not in the list) and aliases them
        for further use.</para>

        <screenshot>
          <screeninfo>CheckList</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/CheckList.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>

      <sect2 id="sec.AliasItemsInList">
        <title>AliasItemsInList</title>

        <para>Allows an alias to be associated with items in a list. The list
        items are located by their title, and are presumed to exist. This
        fixture can therefore also be used as a way of checking for presence
        of items in a list (similar to CheckList, <xref
        linkend="sec.CheckList" />).</para>

        <para>Typically used both in the "Given" (to simplify writing the rest
        of a test).</para>

        <screenshot>
          <screeninfo>AliasItemsInList</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/AliasItemsInList.png" scale="40" />
            </imageobject>
          </mediaobject>
        </screenshot>
      </sect2>
    </sect1>

    <sect1 id="sec.Debugging">
      <title>Debugging</title>

      <para>Debugging and diagnostics. Useful for checking setup, for
      example.</para>

      <sect2 id="sec.DebugServices">
        <title>Debugging Services</title>

        <para>Lists service class names, as picked up from configuration.
        Useful with AliasServices (see <xref
        linkend="sec.AliasServices" />).</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2 id="sec.DebugClock">
        <title>Debugging the Clock</title>

        <para>Reads the current value of the clock. Useful for debugging and
        diagnostics.</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2 id="sec.DebugObjectStore">
        <title>Debugging the Object Store</title>

        <para>Dumps the contents of the object store. Useful for debugging
        setup (through SetupObjects, <xref linkend="sec.SetUpObjects" />, and
        UsingNakedObjectsViewerForSetup, <xref
        linkend="sec.UsingIsisViewer" />).</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2 id="sec.CheckSpecificationsLoaded">
        <title>Check Specifications Loaded</title>

        <para>Verifies that listed <classname>ObjectSpecification</classname>s
        have been loaded into the metamodel</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>

      <sect2 id="sec.RunViewer">
        <title>Run Viewer</title>

        <para>Runs up the DnD viewer with the current state of the objects.
        This is a great way to inspect the state of the system, for example if
        a test is failing and you can't see why.</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Tear Down</title>

      <para>The opposite of setting up...</para>

      <sect2 id="sec.ShutdownIsis">
        <title>Shutdown Isis</title>

        <para>This fixture shuts down the Naked Objects runtime, releasing
        memory and so on. A good place to put this is in the test's
        teardown.</para>

        <sect3>
          <title>Common</title>

          <para></para>
        </sect3>

        <sect3>
          <title>Concordion</title>

          <para></para>
        </sect3>

        <sect3>
          <title>FitNesse</title>

          <para></para>
        </sect3>
      </sect2>
    </sect1>
  </appendix>
</book>
