<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Notes on Naked Objects</title>
</head>
<body>
<h1>Notes</h1>
<h2>Naked values</h2>
<p>Naked values are reflectively set using a string representation,
which is parsed by the specific NakedValue class.&nbsp; Where these
objects support a locale there could be a problem when the client and
server are set to different locales.<br>
</p>
<p>The reflection mechanism only supports string values when setting a
NakedValue.&nbsp; Could it not accept a more suitable type?<br>
</p>
<p>Values can be interogatted and set in two ways: for use within the
system, and for use by the user.&nbsp; For the user a number of formats
can be entered for one value, e.g. the 12th of March, and the format
that applies to the locale the user is working within can also
differ.&nbsp; To enter and display values to the user the values should
be accessed and changed using the parse() and title() methods
respectively.&nbsp; The former method should attempt to parse all the
different format, but should be limited to the current local.&nbsp; In
addition, if there is an international format, as there is for dates
then this should also be tried after all the others.&nbsp; Although
there are a number of valid formats, the title method will only uses
one of these. The important link between these two method is that a
title from a value should be parsable by that value, and should not
change the value of that NakedValue object.<br>
</p>
<p>For internal use there are the saveString() and restoreString()
methods that return and take a standard string encoded representation,
which offers no variations, and does not change according to
locale.&nbsp; These repesentations must be used when persisting values,
when moving values between VMs, and when setting values that are not in
a user representation (e.g. a bar showing&nbsp; <br>
</p>
<p>The best way to get hold of&nbsp; a string representation of a value
is to create a separate NakedValue object, use it methods to change the
value, and then call saveString() to get the string representation.<br>
</p>
<h3>Reflection<br>
</h3>
<p>The Value class provides the reflective methods for NakedValue
objects.&nbsp; It allows you to get a NakedValue object from a
NakedObject, and both to restore the value in NakedValue from an encode
string, and set a NakedValue though a user text string, i.e. one
entered by the user, normally from the keyboard.&nbsp; The latter is
achieved through the parseAndSave() method that locally parses the text
entry into the value object, runs the fields validity check on the
value, and if that succeeds saves the value of the NakedValue
object.&nbsp; If either the text fails to parse, or is found to
otherwise be invalid, the original value is restored and an
InvalidEntryException is thrown (i.e. the value is not persisted).<br>
</p>
<p>All other methods in, and indeed all the calls within the
parseAndSave() method are forwarded to the Value's delegation object
that either executes them locally or remotely requests their execution
on the server.&nbsp; The remote value delegate (RemoteValue) executes
everthing locally, via its own delegate, except for the saveValue()
method which is always executed remotely for persistent NakedObjects,
and the getAbout() and getValue() methods that are remotely executed
when reflection is set up for full proxying.<br>
</p>
<p>The JavaValue class reflectively calls the necessary get, about and
valid methods in the underlying NakedObject classes.<br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
</p>
<p><br>
<br>
</p>
<br>
</body>
</html>
