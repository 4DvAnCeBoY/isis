The viewer has technical status bar, which can be turned on using the following configuration setting.
 nakedobjects.viewer.skylark.debugstatus=on
 ----
 Configuration is done via the configuration object, allowing configurations to be set from files, databases, etc. To get the configuration call:
 UiConfiguration.getInstance().
 ----
''''The design of the UI

'''''The Viewer
The skylark viewer is a lightweight viewer for rendering Naked Objects.  The entire viewer is series of composite views that use builders to create new views.  Each view is wrapped by decorators to give a view behaviours and visual features.  Each view is created to render a Content object.

ObjectView is the base class for all views that display a NakedObject.  It provides default behaviour for dragging and dropping objects onto other objects.  It provides easy access to the content's object (which is held by the ObjectContent). The only option added to the menu items is New Workspace, which should create a new workspace, within the existing workspace, showing the specified object.

''''Content
The Content interface links a view to an object within naked objects.  The subclasses of ObjectField represent naked objects that are fields of a parent object, and subclasses of ActionField represent parameters used when invoking an action method.

Content types for fields:-
* ValueField - for NakedValue objects identified as a Value object
* OneToOneField - for NakedObject objects identified as a OneToOneAssociation object
* OneToManyField - for NakedObject objects identified as a OneToManyAssociation object

RootObject is for top-level NakedObjects - placed on the desktop/workplace.

CollectionElement is for NakedObjects that are placed in non-field based collection, such as those for instances.

ActionContent links together and object and an action that can be performed on it.

ParameterContent provide the holders for the parameter for the Actions

''''Changing views
When a view has been changed, moved, replaced etc, call markDamaged() to cause the view to be redrawn next time drawing is taking place.
----
The entire system is displayed within a single RenderingArea with a x, y coordinate system running horizontally from left to right, and top to bottom, with 0,0 being the top-left corner.  This area is normally contained by a java.awt.Frame or a java.applet.Applet.  The viewer displays one, and only one, view and this is expanded to take the up the entire RenderingArea.  Normally this root view is a composite view and will hold many other smaller views.  Each of the subviews is located relative to the root view's top-left hand corner.

Any view may contain subviews and these are all located relative to their superviews' top-left corner.  Each view has numerous methods that are called by the framework when various event occur, such as mouse entering a view, or a key on the keyboard being pressed.  Only the view that on which the interaction occurred is notified by the framework.  Not even the parent view is notified.  Some events occur that detail a location, such as mouse moved.  All location are specified relative to the top-left hande corner of the view.
 
Each view may be decorated by any number of decorators.  Each decorator passes on the requests it has received before, or after, it has itself responded to the request.  In those cases where the decorators physically extend the view they need to modify locations and sizes before forwarding the request.
 
The InteractionHandler is the single point of inteface for the GUI event mechanism.  This implements the MouseMotionListener, MouseListener and KeyListener interfaces capturing all mouse and keyboard events.  The target view for each event is deemed to be the top most view that is showing under the mouse pointer (known as the mouse location).  The InteractionHandler calculates the coordinates of the mouse pointer relative to the views top-left corner and an event object is created if necessary.  Event objects are of the types Click and Drag, and contain information about the location within the view.  Depending on the action that occured, the relavent method on the view is called with the event object or other relevant information.

Workspace views are special views that group together a set of views that are being used together.  Many workspaces can exists, although it is common to have just a single workspace that fills the entire viewer.  The views in a workspace are bound to that workspace and cannot be moved to another workspace.  In fact views can only be moved around the workspace they belong to, and generally it is only workspaces that have moveable views.

There are three types of dragging that can occur: view; content; and internal.  The type of drag that occurs depends on the type returned by the viewAreaType() method given the location within the view.  This allows the view, and its decorators, to determine what drag will occurr depending on the mouse location.

View dragging is the mechanism that allows the user to physically move the view, repositioning it within a workspace (or other view that allows repositioning).  A view drag occurs in three steps.  The first step is when the user presses down the mouse button and moves the mouse.  When the InteractionHandler detects a movement with the mouse button depressed it calls the target view's pickup(ViewDrag) method, which will return an overlay view to use for visual feedback.  Next, as the user continues to move the mouse the overlay view's location is update so it tracks the mouses movement.  When the user releases the mouse button the workspace is notified that one of its views has been dropped on it, and the location that that view should now assume.  Alternatively, if the user presses the escape key the drag is cancelled by removing the overlay view and reseting the InteractionHandler so a new drag can be started.

 Internal drags occur within a view and

----
Icons and Images

Images are extactly what you expect.  Icons are images scaled to specific size - given as a height so they can be rectangular, and just square - and given a specific tint.  All images and icons are loaded by name from the filesystem, or from the classpath, where, for icons, the name is composed of the icon name and size.

All images are provided by the ImageFactory, which is singleton factory.  The factory is configured to get all images from a specific directory, and to use a specific image as default image if none can be specifically found.  The factory can:-
* create an icon given a name, height, and tint
* create a fallback icon given a height and tint
* create an image given a name

As each image is created it is cached so that the next time the create method is called with the same parameters it will return the previously cached image.

The factory delegates the actual loading of the images to the TemplateImageLoader, but is only requesting a templaye image from which it can generate the various icons.  It attempts to load images of a given name that have one of the extensions specified by the class.  At present files with the .gif, .jpg, .jpeg, .png extensions are attempted.  The loaded will attempt to load these images from the classpath first, and then, if unsuccessful, will attempt to load them from the filesystem.

The TemplateImageLoader, passes back a TemplateImage to the factory.  From this template the factory can provide the client with the full size original image, or it can reduce and tint the image to create an icon.  These template images are cached by the image loaded ready for the next request from the factory.  This will actually only happen when the factory is asked for another icon of the same name, but with another size or tint.
----
''''Notes
 
see SkylarkGraphics