<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.1//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.1/sdocbook.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<article>
  <articleinfo>
    <title>Recognised Annotations</title>

    <author>
      <firstname></firstname>

      <surname></surname>

      <affiliation>
        <orgname></orgname>
      </affiliation>
    </author>

    <pubdate></pubdate>
  </articleinfo>

  <section>
    <title>Recognised Annotations</title>

    <para>This section defines the set of annotations that are recognised by
    the [[NAME]] Java Programming Model.</para>

    <section>
      <title>@ActionOrder</title>

      <para>Note: The recommended mechanism for specifying the order in which
      actions are listed to the user is <literal>@MemberOrder</literal> (see
      below). <literal>@ActionOrder</literal> provides an alternative
      mechanism, in which the order is specified in one place in the class,
      with the added advantage (currently) that you can easily specify
      groupings (which may be rendered by the viewer as sub-menus). However,
      <literal>@ActionOrder</literal> is more 'brittle' to change: if you
      change the name of an existing action you will need to ensure that the
      corresponding name within the <literal>@ActionOrder</literal> annotation
      is also changed.</para>

      <para>The syntax is: <literal moreinfo="none">@ActionOrder("&lt;comma
      separated list of action names&gt;")</literal> (the action names are not
      case sensitive).</para>

      <para>For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("PlaceNewOrder, CheckCredit")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

...
}</programlisting>

      <para>Actions can be grouped together by surrounding the group with
      brackets, and prefixing the group with name and colon. This information
      may be used by the viewing mechanism to render actions into sub-menus.
      For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("(Account Management: PlaceOrder, CheckCredit), (Personal Details: ChangeOfAddress, AddEmail)")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

    public void changeOfAddress() {}

    public void addEmail(String emailAddress) {}

    ...
}</programlisting>
    </section>

    <section>
      <title>@Bounded</title>

      <para>For immutable objects where there is a bounded set of instances,
      the <literal moreinfo="none">@Bounded</literal> annotation can be used.
      For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@Bounded</emphasis>
public class County {
    // members and actions here
}</programlisting>

      <para>The number of instances is expected to be small enough that all
      instance can be held in memory. The viewer will use this information to
      render all the instances of this class in a drop-down list or
      equivalent. (Note: Although this is not enforced, <literal
      moreinfo="none">@Bounded</literal> is intended for use on <literal
      moreinfo="none">final</literal> classes. Its behaviour when used on
      interfaces, or classes with sub-classes is not specified).</para>
    </section>

    <section>
      <title>@Debug</title>

      <para>The <literal>@Debug </literal>annotation marks an action method as
      available in debug mode only, and so will not normally be displayed by
      the user interface.</para>
    </section>

    <section>
      <title>@DescribedAs</title>

      <para>The <literal moreinfo="none">@DescribedAs</literal> annotation is
      used to provide a short description of something that features on the
      user interface. How this description is used will depend upon the
      viewing mechanism - but it may be thought of as being like a 'tool tip'.
      Descriptions may be provided for objects, members (properties,
      collections and actions), and for individual parameters within an action
      method. <literal moreinfo="none">@DescribedAs</literal> therefore works
      in a very similar manner to <literal
      moreinfo="none">@Named</literal>.</para>

      <para><emphasis>Providing a description for an object</emphasis></para>

      <para>To provide a description for an object, use the <literal
      moreinfo="none">@DescribedAs</literal> annotation immediately before the
      declaration of that object class. For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@DescribedAs("A Customer who may have originally become known to us via " +
             "the marketing system or who may have contacted us directly.")</emphasis>
public class ProspectiveSale {
   ...
}</programlisting>

      <para><emphasis>Providing a description for a member</emphasis></para>

      <para>Any member (property, collection or action) may provide a
      description. To specify this description, use the <literal
      moreinfo="none">@DescribedAs</literal> annotation immediately before the
      declaration of that member. For example:</para>

      <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@DescribedAs("The name that the customer has indicated that they wish to be " +
                 "addressed as (e.g. Johnny rather than Jonathan)")</emphasis>
    public String getFirstName() { ... }
}</programlisting>

      <para><emphasis>Providing a description for an action
      parameter</emphasis></para>

      <para>To provide a description for an individual action parameter, use
      the <literal moreinfo="none">@DescribedAs</literal> annotation in-line
      i.e. immediately before the parameter declaration. For example:</para>

      <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity")
                      <emphasis role="strong">@DescribedAs("The quantity of the product being ordered")</emphasis>
                      int quantity) {

        Order order = new Order();
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
    </section>

    <section>
      <title>@Disabled</title>

      <para>The <literal moreinfo="none">@Disabled</literal> annotation means
      that the member cannot be used in any instance of the class. When
      applied to the property it means that the user may not modify the value
      of that property (though it may still be modified programmatically).
      When applied to an action method, it means that the user cannot invoke
      that method. For example:</para>

      <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>
    public void assessCreditWorthiness() { ... }

    <emphasis role="strong">@Disabled</emphasis>
    public int getInitialCreditRating(){ ... }
    public void setInitialCreditRating(int initialCreditRating) { ... }
}</programlisting>

      <para>Note that if an action is marked as <literal
      moreinfo="none">@Disabled</literal>, it will be shown on the user
      interface but cannot ever be invoked. One possible reason to do this is
      during prototyping, to indicate an action that is still to be developed.
      If a method is intended for programmatic use, but not intended ever to
      be invoked directly by a user, then it should be marked as <literal
      moreinfo="none">@Hidden</literal> instead.</para>

      <para>This annotation can also take a single parameter indicating when
      it is to be hidden, for example the following code would disable the
      action until the object has been saved.</para>

      <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>(When.UNTIL_PERSISTED)
    public void assessCreditWorthiness() { ... }
}</programlisting>

      <para>The acceptable values for the parameter are:
      <literal>When.ALWAYS</literal>, <literal>When.NEVER</literal>,
      <literal>When.ONCE_PERSISTED</literal> and
      <literal>When.UNTIL_PERSISTED</literal>. By default the annotated
      property or action is always disabled i.e. it is implicitly
      <literal>When.ALWAYS.</literal></para>
    </section>

    <section>
      <title>@Executed</title>

      <para>The <literal>@Executed</literal> annotation overrides the default
      location where a method is executed.</para>

      <para><emphasis>Forcing a method to be executed on the
      client</emphasis></para>

      <para>The <literal>@Executed(Where.LOCALLY)</literal> annotation marks
      an action method so that it executes on the client, rather than being
      forwarded to the server for execution. This is useful for methods that
      invoke a service that must be run client-side, for example spawning off
      a separate process (such as a web browser or Acrobat Reader).</para>

      <para><emphasis>Forcing a method to be executed on the
      server</emphasis></para>

      <para>The <literal>@Executed(Where.REMOTELY)</literal> annotation marks
      an action method so that it executes on the server, even though it would
      normally be executed on the client (as methods for transient objects
      are). This is useful for methods that although based on transient
      objects need access to persistent objects.</para>
    </section>

    <section>
      <title>@Exploration</title>

      <para>The <literal>@Exploration</literal> annotation marks an action
      method as available in exploration mode only, and therefore not intended
      for use in the production system</para>
    </section>

    <section>
      <title>@FieldOrder</title>

      <para>Note: The recommended mechanism for specifying the order in which
      fields are listed to the user is <literal>@MemberOrder</literal> (see
      below). <literal>@FieldOrder</literal> provides an alternative
      mechanism, in which the order is specified in one place in the class.
      However, <literal>@FieldOrder</literal> is more 'brittle' to change: if
      you change the name of an existing property you will need to ensure that
      the corresponding name within the <literal>@FieldOrder</literal>
      annotation is also changed.</para>

      <para>The syntax is: <literal moreinfo="none">@FieldOrder("&lt;comma
      separated list of field names&gt;") </literal>(the field names are not
      case sensitive.).</para>

      <para>For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@FieldOrder("Name, Address, DateOfBirth, RecentOrders")</emphasis>
public class Customer {

    public Date getDateOfBirth() {...}

    public List&lt;Order&gt; getRecentOrders() {...}

    public String getAddress() {...}

    public String getName() {...}

    ...
}</programlisting>
    </section>

    <section>
      <title>@Hidden</title>

      <para>The <literal moreinfo="none">@Hidden</literal> annotation
      indicates that the member (property, collection or action) to which it
      is applied should never be visible to the user. For example:</para>

      <programlisting format="linespecific">public class Customer {
    private int internalId;

    <emphasis role="strong">@Hidden</emphasis>
    public int getInternalId() {
        return internalId;
    }

    <emphasis role="strong">@Hidden</emphasis>
    public void updateStatus() { ... }
}</programlisting>

      <para>This annotation can also take a single parameter indicating when
      it is to be hidden, for example the following code would show the Id
      until the object has been saved, and then would hide it.</para>

      <programlisting format="linespecific">public class Customer {
    private int internalId;

    <emphasis role="strong">@Hidden</emphasis>(When.ONCE_PERSISTED)
    public int getInternalId() {
        return internalId;
    }
}</programlisting>

      <para>The acceptable values for the parameter are:
      <literal>When.ALWAYS</literal>, <literal>When.NEVER</literal>,
      <literal>When.ONCE_PERSISTED</literal> and
      <literal>When.UNTIL_PERSISTED</literal>. By default the annotated
      property or action is always hidden i.e. it is implicitly
      <literal>When.ALWAYS.</literal></para>
    </section>

    <section>
      <title>@Immutable</title>

      <para>The <literal moreinfo="none">@Immutable</literal> annotation may
      be applied to a class. The framework does not allow the state of such
      objects to be changed through the UI, and it should be considered a
      programmer error to do so programmatically. The ObjectStorePersistor, as
      used to run the in-memory and Hibernate object stores will actually fail
      if the programmer tries to change an object in a way that cause the
      persistor to try and save it. For example the following class would
      prevent the user from changing the object even when transient:</para>

      <programlisting format="linespecific"><emphasis role="strong">@Immutable</emphasis>
public class Country {
    ...
}</programlisting>

      <para>This annotation can also take a single parameter indicating when
      it is to become immutable, for example the following code would allow
      the user to create an email object and set it up, and then prevent any
      changes once it has been saved.</para>

      <programlisting format="linespecific"><emphasis role="strong">@Immutable</emphasis>(When.ONCE_PERSISTED)
public class Email {
    ...
}</programlisting>

      <para>The acceptable values for the parameter are:
      <literal>When.ALWAYS</literal>, <literal>When.NEVER</literal>,
      <literal>When.ONCE_PERSISTED</literal> and
      <literal>When.UNTIL_PERSISTED</literal>. By default the annotated
      property or action is always immutable i.e. it is implicitly
      <literal>When.ALWAYS.</literal></para>
    </section>

    <section>
      <title id="mask-annotation">@Mask</title>

      <para>The <literal moreinfo="none">@Mask </literal>annotation may be
      applied to any property, or to any parameter within an action method,
      that allows the user to type in text as input. The mask serves to
      validate, and potentially to normalise, the format of the input. The
      characters that can be used are based on Swing's MaskFormatter, and also
      Java's SimpleDateFormat. When applying a mask to a value property, the
      annotation should be applied to the 'getter'. For example:</para>

      <programlisting format="linespecific">public class Email {
    private String telNo;

    <emphasis role="strong">@Mask("(NNN)NNN-NNNN")</emphasis>
    public String getTelephoneNumber() {...}

    public void setTelephoneNumber(String telNo) {...}
    ...
}</programlisting>

      <para>When applying a mask to a value parameter within an action method,
      the annotation should be applied 'in-line' before that parameter). For
      example:</para>

      <programlisting format="linespecific">public void newContact(
     @Named("Contact Name")
     String contactName,
     @Named("Telephone Number")
     <emphasis role="strong">@Mask("(NNN)NNN-NNNN")</emphasis>
     String telNo) {}</programlisting>
    </section>

    <section>
      <title>@MaxLength</title>

      <para>The <literal moreinfo="none">@MaxLength</literal> annotation
      indicates the maximum number of characters that the user may enter into
      a <literal moreinfo="none">String</literal> property, or a <literal
      moreinfo="none">String</literal> parameter in an action. (It is ignored
      if applied to a property or parameter of any other type.) For
      example:</para>

      <programlisting format="linespecific">public class Customer {

    <emphasis role="strong">@MaxLength(30)</emphasis>
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
    ...
}</programlisting>

      <para>If the model is being persisted on a relational database then
      <literal moreinfo="none">@MaxLength</literal> should be specified for
      all <literal moreinfo="none">String</literal> properties and action
      parameters.</para>
    </section>

    <section>
      <title>@MemberOrder</title>

      <para><literal>@MemberOrder</literal> is the recommended mechanism for
      specifying the order in which fields and/or actions are presented to the
      user. (<literal>@ActionOrder</literal> and
      <literal>@FieldOrder</literal> provide alternative mechanisms).</para>

      <para><literal>@MemberOrder</literal> is specified at the individual
      member level, on a 'relative' basis. The syntax is:</para>

      <programlisting format="linespecific">@MemberOrder(sequence = "&lt;relative order&gt;")</programlisting>

      <para>where <literal>&lt;relative order&gt;</literal> may be any string.
      The actual sequence is determined by comparing all the values of the
      sequence specifier string, using the standard <literal>String</literal>
      comparator.</para>

      <para>The simplest convention is to use numbers - 1, 2, 3 - though it is
      a better idea to leave gaps in the numbers - 10, 20, 30 perhaps - such
      that a new member may be added without having to edit existing numbers.
      A useful alternative is to adopt the 'dot-decimal' notation - 1, 1.1,
      1.2, 2, 3, 5.1.1, 5.2.2, 5.2, 5.3 - which allows for an indefinite
      amount of future insertion. For example:</para>

      <programlisting format="linespecific">Public Class Customer {
    @MemberOrder(sequence="2.1")
    Public String getAddress() {...}
    Public void setAddress(value as String) {...}

    @MemberOrder(sequence="1.1")
    Public String getFirstName() {...}
    Public void setFirstName(value as String) {...}

    @MemberOrder(sequence="1.2")
    Public String getLastName() {...}
    Public void setLastName(value as String) {...}

    @MemberOrder(sequence="3")
    Public Date getDateOfBirth() {...}
    Public void setDateOfBirth(value as Date) {...}
    ...
}   </programlisting>

      <para>If a member does not have a specified order then it will be placed
      after those that are specified. Two members may have the same sequence
      specifier, but in such a case the relative ordering of those members
      will be indeterminate.</para>

      <para>This approach is especially useful when dealing with inheritance
      hierarchies, as it allows sub-classes to specify where their additional
      members should be placed in relation to those inherited from the
      super-class.</para>

      <para>Note that certain styles of user interface will lay out an
      object's properties and its collections separately, in which case the
      relative member order of properties and collections will be evaluated
      separately. However, since other styles of user interface may interleave
      properties and collections, it is safer to assume the latter.</para>
    </section>

    <section>
      <title>@MultiLine</title>

      <para>The <literal moreinfo="none">@MultiLine</literal> annotation
      provides information about the carriage returns in a <literal
      moreinfo="none">String</literal> property or action parameter. The
      annotation indicates that:</para>

      <para>- the <literal>String</literal> property or parameter may contain
      carriage returns, and</para>

      <para>- (optionally) the typical number of such carriage returns,
      and</para>

      <para>- (optionally) that the text should be wrapped (the default is
      that text is not wrapped).</para>

      <note>
        <para>Currently the <literal moreinfo="none">preventWrapping</literal>
        functionality is not fully implemented.</para>
      </note>

      <para>This may be used by the viewing mechanism to render the property
      as a multi-line textbox (or text-editor when changes are permitted),
      with appropriate wrapping and/or scrollbars. The syntax is:</para>

      <para><literal
      moreinfo="none">@MultiLine([numberOfLines=&lt;typicalNumberOfCRs&gt;]
      [,preventWrapping=&lt;false|true&gt;])</literal></para>

      <para>For example:</para>

      <programlisting format="linespecific">public class BugReport {
    <emphasis role="strong">@MultiLine(numberOfLines=10)</emphasis>
    public String getStepsToReproduce() { ... }
    public void setStepsToReproduce(String stepsToReproduce) { ... }
    ...
}</programlisting>

      <para>Here the <literal moreinfo="none">stepsToReproduce</literal> may
      be displayed in a text area of 10 rows, with no wrapping. A horizontal
      scrollbar may appear if the number of characters on any given row
      exceeds the width. Another example:</para>

      <programlisting format="linespecific">public class Email {
    <emphasis role="strong">@MultiLine(numberOfLines=20, preventWrapping=false)</emphasis>
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

      <para>Here the body should be displayed in a text area of 20 rows, with
      wrapping. If this attribute is combined with the <literal
      moreinfo="none">&lt;TypicalLength&gt;</literal>, then the expected width
      of the text area in the user interface will be determined by the value
      of the typical length divided by the number of specified lines. For
      example:</para>

      <programlisting format="linespecific">public class Email {
    <emphasis role="strong">@MultiLine(numberOfLines=20, preventWrapping=false)</emphasis>
    @TypicalLength(800)
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

      <para>Here the body will (likely be) displayed in a text area of 20
      rows, with 40 columns.</para>
    </section>

    <section>
      <title>@MustSatisfy</title>

      <para>The <literal moreinfo="none">@MustSatisfy</literal> annotation
      allows validation to be applied to properties using an (implementation
      of a) <literal>org.apache.isis.applib.spec.Specification</literal>
      object.</para>

      <para>For example:</para>

      <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@MustSatisfy(StartWithCapitalLetterSpecification.class)</emphasis>
    public String getFirstName() { ... }

    ...
}</programlisting>

      <para>The <literal>Specification</literal> is consulted during
      validation, being passed the proposed value.</para>
    </section>

    <section>
      <title>@Named</title>

      <para>The <literal moreinfo="none">@Named</literal> annotation is used
      when you want to specify the way something is named on the user
      interface i.e. when you do not want to use the name generated
      automatically by the system. It can be applied to objects, members
      (properties, collections, and actions) and to parameters within an
      action method.</para>

      <note>
        <title>Warning</title>

        <para>Generally speaking it is better to rename the property,
        collection or action. The only common case where @Named is common is
        to rename parameters for built-in value types. Even here though a
        custom value type can be defined using @Value so that the value type
        is used as the parameter name. @Named may also be used if the name
        needs punctuation or other symbols in the name presented to the
        user.</para>
      </note>

      <para><emphasis>Specifying the name of an object</emphasis></para>

      <para>By default the name of an object is derived, reflectively from the
      class name. To specify a different name for an object, use the <literal
      moreinfo="none">@Named</literal> annotation in front of the class
      declaration. For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@Named("Customer")</emphasis>
public class CustomerImpl implements Customer{
   ...
}</programlisting>

      <para>See also: <literal moreinfo="none">@Plural</literal>.</para>

      <para><emphasis>Specifying the name of a member</emphasis></para>

      <para>By default, the name of a member (a property, collection or
      action) presented to the user is derived, reflectively, from the name of
      the member defined in the program code. To specify a different name use
      the <literal moreinfo="none">@Named </literal>annotation immediately
      before the member declaration. For example:</para>

      <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Named("Given Name")</emphasis>
    public String getFirstName() { ... }

    <emphasis role="strong">@Named("Family Name")</emphasis>
    public String getSurname() { ... }

    public CreditRating getCreditRating() { ... }
}</programlisting>

      <para>Note that the framework provides a separate and more powerful
      mechanism for internationalisation.</para>

      <para><emphasis>Specifying the name for an action
      parameter</emphasis></para>

      <para>The most common usage of <literal moreinfo="none">@Named
      </literal>will be to specify names for the parameters of an action:
      because, by default, the user interface will use the type of the
      parameter as the name. (This is because the parameter name declared in
      the code for the action method cannot be picked up reflectively.) To
      specify the name of a parameter, the <literal
      moreinfo="none">@Named</literal> annotation is applied 'in-line' (i.e.
      preceding the individual parameter declaration). For example:</para>

      <programlisting format="linespecific">public class Customer {

    public Order placeOrder(
                      Product product,
                      <emphasis role="strong">@Named("Quantity")</emphasis>
                      int quantity) {

        Order order = new Order();
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
    </section>

    <section>
      <title>@NotPersistable</title>

      <para>This annotation indicates that transient instances of this class
      may be created but may not be persisted. The framework will not provide
      the user with an option to 'save' the object, and attempting to persist
      such an object programmatically would be an error. For example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@NotPersistable</emphasis>
public class InputForm {
    // members and actions here
}</programlisting>

      <para>This annotation can also take a single parameter indicating
      whether it is only the user that cannot persist the object, for example
      the following code would prevent the user from saving the object (via
      the viewer) but still allow the program to persist the object. By
      default the annotated object is effectively transient, e.g. it is
      implicitly
      <literal>By</literal>.<literal>USER_OR_PROGRAM</literal>.</para>

      <programlisting format="linespecific"><emphasis role="strong">@NotPersistable</emphasis>(By.USER)
public class InputForm {
    ...
}</programlisting>
    </section>

    <section>
      <title>@NotPersisted</title>

      <para>This indicates that the property is not to be persisted. Note that
      in many cases the same thing could be achieved by providing the property
      with a 'getter' but no 'setter'. For example:</para>

      <para><emphasis>Check that this is acceptable for
      Hibernate</emphasis></para>

      <programlisting format="linespecific">public class Order {

    private Order previousOrder;

    <emphasis role="strong">@NotPersisted</emphasis>
    public Order getPreviousOrder() {...}

    public void setPreviousOrder(Order previousOrder) {...}

    // rest of code
}</programlisting>
    </section>

    <section>
      <title>@Optional</title>

      <para>By default, the system assumes that all properties of an object
      are required, and therefore will not let the user save a new object
      unless a value has been specified for each property. Similarly, by
      default, the system assumes that all parameters in an action are
      required and will not let the user execute that action unless values
      have been specified for each parameter. To indicate that either a
      property, or an action parameter, is optional, use the <literal
      moreinfo="none">@Optional</literal> annotation.</para>

      <para><emphasis>Making a property optional</emphasis></para>

      <para>To indicate that a property is optional (i.e. that the user may
      save the object without necessarily specifying a value for this
      property), use the @Optional annotation immediately before the
      declaration of that property. For example:</para>

      <programlisting format="linespecific">public class Order {
    public Product getProduct() { ... }
    
    public java.util.Date getShipDate() { ... }
    public void setShipDate(Date java.util.shipDate) { ... }

    <emphasis role="strong">@Optional</emphasis>
    public String getComments() { ... }
    public void setComments(String comments) { ... }
}</programlisting>

      <para>Here the <literal moreinfo="none">product</literal> and <literal
      moreinfo="none">shipDate</literal> properties are both required, but the
      <literal moreinfo="none">comments</literal> property is optional.</para>

      <para><emphasis>Making an action parameter optional</emphasis></para>

      <para>To indicate that an action may be invoked without having to
      specify a value for a particular parameter, the <literal
      moreinfo="none">@Optional</literal> annotation should be used in-line
      i.e. immediately before the declaration of that parameter. For
      example:</para>

      <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
              Product product,
              @Named("Quantity") int quantity, 
              @Optional @Named("Special Instructions") String instr) {
        ....
    }
    ...
}</programlisting>

      <para>Note that the <literal
      moreinfo="none">@Optional</literal>annotation has no meaning for a
      primitive property (or parameter) such as <literal
      moreinfo="none">int</literal> - because primitives will always return a
      default value (e.g. zero). If optionality is required, then use the
      corresponding wrapper class (e.g. java.lang.Integer).</para>
    </section>

    <section>
      <title>@Plural</title>

      <para>Where [[NAME]] displays a collection of several objects it
      may use the plural form of the object type in the title. By default the
      plural name will be created by adding an 's' to the end of the singular
      name (whether that is the class name or another name specified using
      <literal moreinfo="none">@Named</literal>). Where the single name ends
      in 'y' then the default plural name will end in 'ies' - for example a
      collection of <literal moreinfo="none">Country</literal> objects will be
      titled 'Countries'. Where these conventions do not work, the programmer
      may specify the plural form of the name using @Plural. For
      example:</para>

      <programlisting format="linespecific"><emphasis role="strong">@Plural("Children")</emphasis>
public class Child {
    // members and actions here
}</programlisting>
    </section>

    <section>
      <title>@RegEx</title>

      <para>The <literal moreinfo="none">@RegEx</literal> annotation may be
      applied to any property, or to any parameter within an action method,
      that is a value type (i.e. that allows the user to type in text as
      input). It serves both to validate and potentially to normalise the
      format of the input. <literal moreinfo="none">@Regex</literal> is
      therefore similar in use to <literal moreinfo="none">@Mask</literal> but
      provides more flexibility. The syntax is:</para>

      <para><literal moreinfo="none">@RegEx(validation = &lt;regEx string&gt;,
      format = &lt;regEx string&gt;, caseSensitive =
      &lt;true|false&gt;)</literal></para>

      <para>The first parameter is required; the format defaults to 'no
      formatting'; caseSensitive defaults to false. When applying Regex to a
      value property, the annotation should be applied to the 'getter'. For
      example:</para>

      <programlisting format="linespecific">    private String email;

<emphasis role="strong">    @RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")</emphasis>
    public String getEmail() {}

    public void setEmail(String email) {}</programlisting>

      <para>When applying a RegEx expression to a value parameter within an
      action method, the annotation should precede that parameter:</para>

      <programlisting format="linespecific">    public void newContact(
        @Named("Contact Name")
        String contactName,
        @Named("Email")
        <emphasis role="strong">@RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")</emphasis>
        String email) {}</programlisting>
    </section>

    <section>
      <title>@TypeOf</title>

      <para>The <literal moreinfo="none">@TypeOf</literal> annotation is used
      to specify the type of elements in a collection, when it is not possible
      to use generics - for example when invoking an external method that does
      not use generics.</para>

      <programlisting format="linespecific"><emphasis role="strong">@TypeOf(Customer.class)</emphasis>
public List allNewCustomers() {
    return CustomerDatabase.allNewCustomers();
}</programlisting>
    </section>

    <section>
      <title>@TypicalLength</title>

      <para>The <literal moreinfo="none">@TypicalLength</literal> annotation
      indicates the typical length of a <literal
      moreinfo="none">String</literal> property or <literal
      moreinfo="none">String</literal> parameter in an action. This may be
      used by the viewing mechanism to determine the space that should be
      given to that property or parameter in the appropriate view. For
      example:</para>

      <programlisting format="linespecific">public class Customer {
    @MaxLength(30)
    <emphasis role="strong">@TypicalLength(20)</emphasis>
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
}</programlisting>

      <para>If the typical length is the same as the <literal
      moreinfo="none">&lt;MaxLength&gt;</literal> then there is no need to
      specify <literal moreinfo="none">&lt;TypicalLength&gt;</literal> as
      well. If the value specified is zero or negative then it will be
      ignored.</para>
    </section>

    <section>
      <title>@Value</title>

      <para>The <literal moreinfo="none">@Value</literal> annotation indicates
      that a class should be treated as a value type rather than as a
      reference (or entity) type. It does this providing an implementation of
      a
      <literal>org.apache.isis.applib.adapters.ValueSemanticsProvider</literal>.</para>

      <para>For example:</para>

      <programlisting format="linespecific">@Value(semanticsProviderClass=ComplexNumberValueSemanticsProvider.class)
public class ComplexNumber {
    ...
}</programlisting>

      <para>The <literal>ValueSemanticsProvider</literal> allows the framework
      to interact with the value, parsing strings and displaying as text, and
      encoding/decoding (for serialization).</para>
    </section>
  </section>
</article>
