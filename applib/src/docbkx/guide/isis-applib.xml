<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./src/docbkx/dtd-4.5/docbookx.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>

      <author>
        <firstname>Robert</firstname>

        <surname>Matthews</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para><emphasis>Apache Isis</emphasis> is designed to allow programmers
    rapidly develop domain-driven applications following the <ulink
    url="http://en.wikipedia.org/wiki/Naked_Objects">Naked Objects</ulink>
    pattern. It is made up of a core framework plus a number of alternate
    implementations, and supports various viewers and object stores. Apache
    Isis is hosted at the <ulink url="http://incubator.apache.org/isis">Apache
    Foundation</ulink>, and is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>

    <para>This guide is written for programmers looking to understand the
    programming conventions, annotations and supporting utilities within the
    <emphasis>Apache Isis</emphasis> application library (or
    <emphasis>applib</emphasis>), in order that the framework can correctly
    pick up and render the business rules and logic encoded within their
    domain objects.</para>
  </preface>

  <!-- main content -->

  <chapter>
    <title>Introduction</title>

    <abstract>
      <para>What this guide contains, who it is for, and how the applib
      relates to other parts of the framework.</para>
    </abstract>

    <sect1>
      <title>What's in this Guide</title>

      <para>This guide describes the set of conventions for writing domain
      objects, that are together known as the <emphasis>Apache Isis</emphasis>
      Programming Model. It's important reading for developers who are looking
      to write domain-driven applications either for prototyping or deployment
      on <emphasis>Apache Isis</emphasis>.</para>

      <para>More correctly, this guide actually documents the
      <emphasis>default</emphasis> programming model, targetted for the Java
      programming language, and implemented by the
      <classname>org.apache.isis.defaults:progmodel</classname> module.
      <emphasis>Isis</emphasis> is in fact capable of supporting different
      programming models, either for other JVM-based languages; for example
      the Groovy language is supported in the
      <classname>org.apache.isis.alternatives.progmodel:groovy</classname>
      module.</para>
    </sect1>

    <sect1>
      <title>This Guide vs the Core Documentation</title>

      <para>This guide assumes that you have at least the outline of a running
      <emphasis>Apache Isis</emphasis> application, for example having run the
      quickstart archetype. If you haven't done this, then please consult the
      core documentation to learn how.</para>

      <para>You should also note that the core documentation also explains the
      wider landscape of what makes up an <emphasis>Isis</emphasis>
      application, dealing with such matters as running the app with different
      components, eg viewers or object stores.</para>

      <para>Indeed, it is also possible for developers to build their own
      programming model, either as a subset of the default programming model
      described here, and possibly with additional custom elements. See the
      core documentation for details on how to write your own programming
      model.</para>

      <para>However, everything related to the specifics of writing a domain
      object with the <emphasis>default</emphasis> programming model is
      here.</para>
    </sect1>

    <sect1>
      <title>Principles</title>

      <para>The conventions of the programming model are best described as
      'intentional' - they convey an intention as to how domain objects, their
      properties and behaviours, are to be made available to users. The
      specific way in which those intentions are interpreted or implemented
      will depend upon the framework, and/or the particular components or
      options selected within that framework.</para>

      <para>To pick a single example, marking up a domain class with the
      annotation <code>@Bounded</code> is an indication that the class is
      intended to have only a small number of instances and that the set does
      not change very often - such as the class <code>Country</code>. This is
      an indication to any interested framework that the whole set of
      instances might be offered to the user in a convenient form such as a
      drop-down list. The programming convention has <emphasis>not</emphasis>
      been defined as <code>@DropDownList</code> because the user interface
      might not support drop-down-lists - but it might provide a capability to
      select from an <code>@Bounded</code> class by typing the initial letters
      of the desired instance.</para>
    </sect1>

    <sect1>
      <title>Where Next?</title>

      <para>This guide itself is in several parts. The first part is a set of
      chapters is written in the style of recipes/cookbooks, providing a
      "how-to" guide on developing domain objects. This is good reading if you
      are just starting out. The second part provides details on other
      supporting features relevant to writing domain applications. The final
      part is a series of appendices that provide details of the programming
      model in reference form. You should find this more useful if you've used
      <emphasis>Isis</emphasis> for a while and just need to check on a
      specific detail.</para>
    </sect1>
  </chapter>

  <part>
    <title>Writing Domain Objects</title>

    <partintro>
      <para>This part of the guide is a set of chapters that provides how-to's
      for writing domain objects, by which we mean domain entities, value
      types, services and repositories/factories.</para>
    </partintro>

    <chapter id="chp.Objects">
      <title>Domain Entities</title>

      <abstract>
        <para>How-to's relating to the object itself</para>
      </abstract>

      <para>This chapter contains how-to's for programming conventions that
      apply to the domain objects, or more specifically domain entities.
      Domain values conventions are covered in <xref
      linkend="chp.ValueTypes" />.</para>

      <sect1>
        <title>How to not inherit from framework classes</title>

        <para>It isn't mandatory for domain entities to inherit from any
        framework superclass; they can be plain-old pojos if required.
        However, they do at a minimum need to have a
        <classname>org.apache.isis.applib.DomainObjectContainer</classname>
        injected into them (an interface), from which other framework services
        can be accessed.</para>

        <para>If you don't have a requirement to inherit from any other
        superclass, then it usually makes sense to inherit from mention
        <classname>org.apache.isis.applib.AbstractDomainObject</classname>,
        which already supports the
        <classname>DomainObjectContainer</classname> and has a number of
        convenience helper methods.</para>

        <para>There is further coverage on
        <classname>DomainObjectContainer</classname> in <xref
        linkend="sec.LifecycleMethods" /> and also in <xref
        linkend="chp.DomainServices" />.</para>
      </sect1>

      <sect1>
        <title condition="java">How to specify a title for an object</title>

        <para>A title is used to identify an object to the user in the user
        interface. For example, a <classname>Customer</classname>'s title
        might be the organization's customer reference, or perhaps (more
        informally) their first and last names. By default, the framework will
        use the object's <literal moreinfo="none">toString()</literal> method
        as the title. However, if a <literal moreinfo="none">title()
        </literal>method (returning a <literal
        moreinfo="none">String</literal>) is present, then that is used
        instead, thus:</para>

        <para><programlisting>public String toString()</programlisting></para>

        <para>or</para>

        <para><programlisting>public String title()</programlisting></para>

        <para>The reason for providing the option to use a <literal
        moreinfo="none">title()</literal> method is in case the programmer
        needs to make use of the <literal moreinfo="none">toString()</literal>
        method for other purposes, such as for debugging.</para>

        <para>The applib contains a class,
        <classname>org.apache.isis.applib.util.TitleBuffer</classname>, which
        you can use to help create title strings if you so wish. See <xref
        linkend="apx.UtilityClasses" /> for more details.</para>
      </sect1>

      <sect1 id="sec.HowToSpecifyTheIconForAnObjectsClass">
        <title condition=".net">How to specify the icon for an object's
        class</title>

        <para condition="1.5">By default, the framework will look for an image
        in the <filename class="directory" moreinfo="none">images</filename>
        directory (either from the classpath or from the filesystem) that has
        the same name as the object class. Multiple file extensions are
        searched for, including <filename>.png</filename>,
        <filename>.gif</filename> and <filename>.jpg</filename> (in order of
        preference). For example, fan object of type
        <classname>Customer</classname> it will look for <filename
        class="directory" moreinfo="none">Customer.png</filename>, <filename
        class="directory" moreinfo="none">Customer.gif</filename>,
        <filename>Customer.jpg</filename> etc.</para>

        <para condition="1.5">If the framework finds no such file, then it
        will work up the inheritance hierarchy to see if there is an icon
        matching the name of any of the super-classes, and use that instead.
        If no matching icon is found then the framework will look for an image
        called <filename class="directory"
        moreinfo="none">default.png</filename>,
        <filename>default.gif</filename> or <filename>default.jpg</filename>
        in the images directory, and if this has not been specified, then the
        framework will use its own default image for an icon.</para>

        <para>We strongly recommend that you adopt 'camel case' as the
        convention for icon file names: if you have a class called <classname
        condition="vb"> OrderLine</classname>, then call the icon <filename
        class="directory" moreinfo="none">OrderLine.png</filename>. Actually,
        the framework will also recognise <filename class="directory"
        moreinfo="none">orderline.png</filename>, but some operating systems
        and deployment environments are case sensitive, so it is good practice
        to adopt an unambiguous convention.</para>

        <para>You may alternatively choose to specify, manually, which icon to
        use, by specifying an <literal moreinfo="none">iconName</literal>()
        method:</para>

        <programlisting format="linespecific">public String iconName() {
    return "Person";
}</programlisting>

        <para>This makes it easy for more than one class to use the same icon,
        without having to duplicate the image file.</para>
      </sect1>

      <sect1>
        <title>How to specify the icon for an individual object's
        state</title>

        <para>As discussed in <xref
        linkend="sec.HowToSpecifyTheIconForAnObjectsClass" />, the
        <code>iconName()</code> method may be used to specify an object. The
        value returned from this method need not be static, and so it can be
        used to represent the state of an individual object.</para>

        <para>For example, an instance of <classname>Product</classname> could
        use a photograph of the product as an icon, using:</para>

        <programlisting format="linespecific">public class Product {
    public String iconName() {
        return "Product-" + getPhotograph();
    }
    ...
}</programlisting>

        <para>Alternatively, an <classname>Order</classname> might vary the
        icon according to the status of the object:<programlisting>public class Order {
    public String iconName() {
        return "Order-" + getStatus();
    }
    ...
}</programlisting></para>
      </sect1>

      <sect1>
        <title condition="j#">How to specify a name and/or description for an
        object</title>

        <para>By default, the name (or type) of an object, as displayed to the
        user will be the class name. However, if an <literal
        moreinfo="none">@Named</literal> annotation is included, then this
        will override the default name. This might be used to include
        punctuation or other characters that may not be used within a class
        name, or when - for whatever reason - the name of the class includes
        technical artifacts (for example project-defined prefixes or
        suffices). It is also useful if the required name cannot be used
        because it is a keyword in the language.</para>

        <para>By default the framework will create a plural version of the
        object name by adding an 's' to singular name, or a 'ies' to names
        ending 'y'. For irregular nouns or other special case, the
        <code>@Plural</code> annotation may be used to specify the plural form
        of the name explicitly.t</para>

        <para>The programmer may optionally also provide a <literal
        moreinfo="none">@DescribedAs</literal> annotations, containing a brief
        description of the object's purpose, from a user perspective. The
        framework will make this available to the user in a form appropriate
        to the user interface style - for example as a tooltip.</para>

        <para>For example:</para>

        <programlisting>@Named("Customer")
@Plural("Customers")
@DescribedAs("Individuals or organizations that have either "+
             "purchased from us in the past or "+
             "are likely to in the future")
public class CustomerImpl implements ICustomer {
    ...y
}</programlisting>

        <note>
          <para>There is an entirely separate mechanism for dealing with
          Internationalisation, details of which can be found in the core
          documentation.</para>
        </note>
      </sect1>

      <sect1>
        <title condition="vb">How to specify that an object should not be
        persisted</title>

        <para>Non-persisted objects are intended to be used as view models;
        they aggregate some state with respect to a certain process. This may
        be read-only (eg a projection of certain informaiton) or read-write
        (eg a wizard-like process object). Either way, the viewer is expected
        to interpret this by not providing any sort of automatic "save" menu
        item if such an object is returned to the
        <acronym>GUI</acronym>.</para>

        <para>Non-persisted objects that are read-only are typically also
        marked as immutable (see <xref linkend="sec.Immutable" />).</para>

        <para>To indicate that an object cannot be persisted, use the <literal
        moreinfo="none">@NotPersistable</literal> annotation.</para>
      </sect1>

      <sect1 id="sec.Immutable">
        <title>How to specify that an object should never be modified by the
        user</title>

        <para>Some objects have state which should not be modifiable; for
        example those representing reference data. The viewer is expected to
        interpret this by which suppressing any sort of "edit" button.</para>

        <para>To indicate that an object cannot be modified, use the <literal
        moreinfo="none">@Immutable</literal> annotation.</para>

        <para>For example:</para>

        <programlisting>@Immutable
public class ChasingLetter implements PaymentReclaimStrategy {
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.Bounded">
        <title>How to specify that a class of objects has a limited number of
        instances</title>

        <para>Sometimes an entity may only have a relatively small number of
        instances, for example the types of credit cards accepted (Visa,
        Mastercard, Amex). Viewers will typically expected to render the
        complete set of instances as a drop down list whenever the object type
        is used (ie as a property or action parameter).</para>

        <para>To indicate that a class has a limited number of instances, use
        the <classname>@Bounded</classname> annotation. Note that there is an
        implied expectation is that the list of objects is small, and
        relatively cheap to obtain from the object store.</para>

        <para>An alternative way to specify a selection of objects is using
        the <classname>choicesXxx()</classname> supporting methods.</para>

        <para>For example:</para>

        <programlisting>@Bounded
public class PaymentMethod {
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.HowToCreateAnObject">
        <title>How to create or delete objects within your code</title>

        <para>When you create any domain object within your application code,
        it is important that the framework is made aware of the existence of
        this new object - in order that it may be persisted to the object
        store, and in order that any services that the new object needs are
        injected into it.</para>

        <para>Just specifying <literal moreinfo="none">new
        Customer()</literal>, for example, will create a
        <classname>Customer</classname> object, but that object will
        <emphasis>not</emphasis> be known to the framework. However, since we
        do not want to tie our domain objects to a particular framework, we
        use the idea of a 'container' to mediate, specified by the <literal
        moreinfo="none">org.apache.isis.applib.DomainObjectContainer</literal>
        interface. See <xref linkend="apx.DomainObjectContainer" /> for the
        full list of methods provided by
        <classname>DomainObjectContainer</classname>.</para>

        <para>This interface defines the following methods for managing domain
        objects:</para>

        <itemizedlist>
          <listitem>
            <para><literal moreinfo="none">&lt;T&gt; T
            newTransientInstance(final Class&lt;T&gt;
            ofClass)</literal></para>

            <para>Returns a new instance of the specified class, that is
            transient (unsaved). The object may subsequently be saved either
            by the user invoking the Save action (that will automatically be
            rendered on the object view) or programmatically by calling
            <literal moreinfo="none">persist(Object
            transientObject)</literal></para>
          </listitem>

          <listitem>
            <para><methodname>&lt;T&gt; T newPersistentInstance(final
            Class&lt;T&gt; ofClass)</methodname></para>

            <para>Creates a new object already persisted.</para>
          </listitem>

          <listitem>
            <para><methodname>boolean isPersistent()</methodname></para>

            <para>Checks whether an object has already been persisted. This is
            often useful in controlling visibility or availability of
            properties or actions.</para>
          </listitem>

          <listitem>
            <para><methodname>void persist(Object
            transientObject)</methodname></para>

            <para>Persists a transient object (created using
            <methodname>newTransientInstance(...)</methodname>, see
            above).</para>
          </listitem>

          <listitem>
            <para><methodname>void persistIfNotAlready(Object
            domainObject)</methodname></para>

            <para>It is an error to persist an object if it is already
            persistent; this method will persist only if the object is not
            already persistent (otherwise it will do nothing).</para>
          </listitem>

          <listitem>
            <para><methodname>void remove(Object
            persistentObject)</methodname></para>

            <para>Removes (deletes) from the object store, making the
            reference transient.</para>
          </listitem>

          <listitem>
            <para><methodname>void removeIfNotAlready(Object
            domainObject)</methodname></para>

            <para>It is an error to remove an object if it is not persistent;
            this method will remove only if the object is known to be
            persistent (otherwise it will do nothing).</para>
          </listitem>
        </itemizedlist>

        <para>A domain object specifies that it needs to have a reference to
        the <classname>DomainObjectContainer</classname> injected into by
        including the following code:</para>

        <programlisting format="linespecific">private DomainObjectContainer container;
protected DomainObjectContainer getContainer() {
    return container;
}
public final void setContainer(final DomainObjectContainer container) {
    this.container = container;
}</programlisting>

        <para>Creating or deleting objects is then done by invoking those
        methods on the container. For example the following code would then
        create a new <classname>Customer</classname> object within another
        method:</para>

        <programlisting format="linespecific">Customer newCust = getContainer().newTransientInstance(Customer.class);
newCust.setName("Charlie");
getContainer().persist(newCust);</programlisting>

        <para>If you are able to make your domain object inherit from <literal
        moreinfo="none">org.apache.isis.applib.AbstractDomainObject</literal>
        then you have direct access to those methods, so the code would
        become:</para>

        <programlisting format="linespecific">Customer newCust = newTransientInstance(Customer.class);
newCust.setName("Charlie");
persist(newCust);</programlisting>

        <para>As an alternative to putting the creation logic within your
        domain objects, you could alternatively delegate to an injected
        factory (see <xref linkend="chp.DomainServices" />). Ultimately
        factories just delegate back to
        <classname>DomainObjectContainer</classname> in the same way, so from
        a technical standpoint there is little difference. However it is
        generally worth introducing a factory because it provides a place to
        centralize any business logic. It also affords the opportunity to
        introduce a domain term (eg <classname>ProductCatalog</classname> or
        <classname>StudentRegister</classname>), thereby reinforcing the
        "ubiquitous language".</para>

        <para>These methods are actually provided by the
        <classname>org.apache.isis.applib.AbstractContainedObject</classname>
        and so are also available on <literal
        moreinfo="none">org.apache.isis.applib.AbstractService</literal> (and,
        hence, on <literal
        moreinfo="none">org.apache.isis.applib.AbstractFactoryAndRepository</literal>)
        for creating objects within a service.</para>

        <warning>
          <para>It is possible to create a transient object within another
          transient object. When the framework persists any transient object,
          by default it will automatically persist any other transient object
          referenced by that object. However, if any of these transient
          objects are to be exposed to the user (while in their transient
          state), then you need to write your code very carefully -
          anticipating the fact that the user could elect to save any of the
          transient objects at any point - which could cause the graph of
          related objects to be persisted in an invalid state.</para>

          <para>The recommended approach is, if possible, to mark these
          supplementary classes as not persistable by the user (see <xref
          linkend="not-persistable" />), or not to permit the user to create a
          new transient object that is a child of an existing transient
          object, but, rather, to require the user to save the parent object
          first.</para>
        </warning>
      </sect1>

      <sect1 id="sec.LifecycleMethods">
        <title>How to insert behaviour into the object life cycle</title>

        <para><emphasis>Apache Isis</emphasis> is responsible for managing the
        object lifecycle, persisting, updating or removing objects from the
        persistent object store as required. For many applications the domain
        objects are unaware of this. If required, though, an object can
        provide callback methods (all optional) so that the framework can
        notify it of its persistence state.</para>

        <para>For example, the <literal
        moreinfo="none"><methodname>persisted</methodname></literal>() method
        is called after an object has been persisted. This could be used to
        setup a reverse association that should only be created once the new
        object has been persisted.</para>

        <para>The full list of callbacks is shown below.</para>

        <table>
          <title>Object lifecycle methods</title>

          <tgroup cols="2">
            <colspec align="left" />

            <thead>
              <row>
                <entry align="center">Method</entry>

                <entry align="center">When called by framework</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><methodname>created()</methodname></entry>

                <entry>following the logical creation of the object (that is,
                after <methodname>newTransientInstance()</methodname> has been
                called)</entry>
              </row>

              <row>
                <entry><methodname>loading()</methodname></entry>

                <entry>when a persistent object is about to be loaded into
                memory</entry>
              </row>

              <row>
                <entry><methodname>loaded()</methodname></entry>

                <entry>once the persistent object has just been loaded into
                memory</entry>
              </row>

              <row>
                <entry><methodname>persisting()</methodname> or
                <methodname>saving()</methodname></entry>

                <entry>just before a transient object is first
                persisted.</entry>
              </row>

              <row>
                <entry><methodname>persisted()</methodname> or
                <methodname>saved()</methodname></entry>

                <entry>just after a transient object is first
                persisted.</entry>
              </row>

              <row>
                <entry><methodname>updating()</methodname></entry>

                <entry>after any property on a persistent object has been
                changed and just before this change is persisted</entry>
              </row>

              <row>
                <entry><methodname>updated()</methodname></entry>

                <entry>after a changed property on a persistent object has
                been persisted</entry>
              </row>

              <row>
                <entry><methodname>removing()</methodname> or
                <methodname>deleting()</methodname></entry>

                <entry>when a persistent object is just about to be deleted
                from the persistent object store.</entry>
              </row>

              <row>
                <entry><methodname>removed()</methodname> or
                <methodname>deleted()</methodname></entry>

                <entry>when a persistent object has just been deleted from the
                persistent object store.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect1>

      <sect1 id="sec.ResolveAndObjectChanged">
        <title>How to perform lazy loading (generally done
        automatically)</title>

        <para>The DomainObjectContainer provides the resolve() method in order
        to lazily resolve the value of a property or a collection. In earlier
        versions of the framework it was necessary to call this method prior
        to accessing or mutating any property or collection. This is no longer
        required because <emphasis>Apache Isis</emphasis> uses bytecode
        enhancement to automatically call this method.</para>

        <para>While it is possible to disable this bytecode enhancement using
        <filename>isis.properties</filename> file, this is not generally
        recommended. If it is disabled then the
        <methodname>resolve()</methodname> method may need to be called
        manually.</para>
      </sect1>

      <sect1>
        <title>How to perform dirty object tracking (generally done
        automatically)</title>

        <para>The <classname>DomainObjectContainer</classname> provides the
        <methodname>objectChanged()</methodname> method in order to mark an
        object's state as having changed, and therefore requiring an update to
        the persistent object store. In earlier versions of the framework it
        was necessary to call this method after mutating any the property or
        collection. This is no longer required because <emphasis>Apache
        Isis</emphasis> uses bytecode enhancement to automatically call this
        method.</para>

        <para>While it is possible to disable this bytecode enhancement using
        <filename>isis.properties</filename> file, this is not generally
        recommended. If it is disabled then the
        <methodname>objectChanged()</methodname> method may need to be called
        manually.</para>
      </sect1>

      <sect1>
        <title>How to ensure object is in valid state</title>

        <para>A <methodname>validate()</methodname> method may be added to
        provided validation at object level, prior to making an object
        persistent.</para>

        <para>The syntax is:</para>

        <programlisting>public String validate()</programlisting>

        <para>A non-<code>null</code> value is the taken to be the reason why
        the object cannot be saved.</para>

        <para>This is particularly useful for validating fields in relation to
        each other.</para>

        <para>For example:</para>

        <programlisting>public class Booking {
    private Date fromDate;
    public Date getFromDate() {...}
    public void setFromDate(Date d) {...}
    
    private Date toDate;
    public Date getToDate() {...}
    public void setToDate(Date d) {...}

    public String validate() {
        if (fromDate.getTicks() &gt; toDate.getTicks()) {
            return "From Date cannot be after To Date";
        }
        return null;
    }
    ...
}</programlisting>

        <para>This will prevent the user from saving a transient
        <code>Booking</code> where the From Date falls after the To Date. Note
        that in this example, the two date properties could also have their
        own individual validate methods - for example in order to test that
        each date was after today.</para>

        <warning>
          <para>At the time of writing, the <code>validate()</code> method is
          called only when the object is first saved, not when it is
          subsequently updated. For validation of subsequent updates, the
          workaround is necessary to build the validation logic into the
          individual property validation methods (though these could delegate
          to a common <code>validate()</code> method).</para>

          <para>See <ulink
          url="https://issues.apache.org/jira/browse/ISIS-18">ISIS-18</ulink>
          for the status of this issue.</para>
        </warning>
      </sect1>
    </chapter>

    <chapter id="chp.Properties">
      <title>Domain Entity Properties</title>

      <abstract>
        <para>How-to's relating to an domain entity's properties.</para>
      </abstract>

      <para>The following conventions are concerned with specifying the
      properties of a domain entity, and the means by which a user can
      interact with those properties.</para>

      <sect1>
        <title>How to add a property to an object</title>

        <para>Properties are specified using the JavaBean conventions,
        recognizing a standard accessor/mutator pair (<code>get</code> and
        <code>set</code>).</para>

        <para>The syntax is:</para>

        <para><programlisting>public PropertyType getPropertyName() 

public void setPropertyName(PropertyType param)</programlisting></para>

        <para>where <literal moreinfo="none">PropertyType</literal> is a
        primitive, a value object or an entity object.</para>

        <para>Properties may either be for a value type or may reference
        another entity. Values include Java primitives, and JDK classes with
        value semantics (eg <literal
        moreinfo="none">java.lang.Strings</literal> and <literal
        moreinfo="none">java.util.Dates</literal>; see <xref
        linkend="chp.ValueTypes" /> for the full list). It is also possible to
        write your own value types (see <xref linkend="chp.ValueTypes" />). A
        property referencing another domain object is sometimes called an
        association.</para>

        <para>For example, the following example contains both a value
        (<literal moreinfo="none">String</literal>) property and a reference
        (<literal moreinfo="none">Organisation</literal>) property:</para>

        <programlisting format="linespecific">public class Customer {
    private String firstName;
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    private Organisation organisation;
    public Organisation getOrganisation() {
        return organisation;
    }
    public void setOrganisation(Organisation organisation) { 
        this.organisation = organisation;
    }

    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to specify a name and/or description for a property</title>

        <sect2>
          <title>Specifying the name for a property</title>

          <para>By default the framework will use the property name itself to
          label the property on the user interface. If you wish to override
          this, use the <literal moreinfo="none">@Named </literal>annotation
          on the property.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer() {
    @Named("Given Name")
    public String getFirstName() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Specifying a description for a property</title>

          <para>An additional description can be provided on a property using
          the <literal moreinfo="none">@DescribedAs</literal> annotation. The
          framework will take responsibility to make this description
          available to the user, for example in the form of a tooltip.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer() {
    @DescribedAs("The given name by which this customer is known")
    public String getFirstName() { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1 id="sec.MemberOrderForProperties">
        <title>How to specify the order in which properties are
        displayed</title>

        <para>The <literal moreinfo="none">@MemberOrder</literal> annotation
        provides a hint to the viewer as to the order in which the properties
        (and also collections, see <xref
        linkend="sec.MemberOrderForCollections" />) should appear in the
        <acronym>GUI</acronym>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer() {
    @MemberOrder("1")
    public String getFirstName() { ... }
    ...

    @MemberOrder("2")
    public String getLastName() { ... }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to make a property optional (when saving an object)</title>

        <para>By default, when a new transient (unsaved) object is presented
        to the user, values must be specified for all properties before the
        object may be saved.</para>

        <para>To specify that a particular property is optional, use the
        <literal moreinfo="none">@Optional</literal> annotation.</para>
      </sect1>

      <sect1 id="sec.SizeProperties">
        <title>How to specify the size of <classname>String</classname>
        properties</title>

        <para>Use:</para>

        <itemizedlist>
          <listitem>
            <para>the <literal moreinfo="none">@MaxLength</literal> to specify
            the maximum number of characters that may be stored within a
            <classname>String</classname> property.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@TypicalLength</literal> to
            specify the typical number of characters that are likely to be
            stored within a <classname>String</classname> property. Viewers
            are expected to use this as a hint as to the size of the field to
            render for the property.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@MultiLine</literal> annotation
            as a hint to indicate that the property should be displayed over
            multiple lines (eg as a text area rather than a text
            field).</para>
          </listitem>
        </itemizedlist>

        <para>For example:</para>

        <programlisting format="linespecific">public class Ticket {
    @TypicalLength(50)
    @MaxLength(255)
    public String getDescription() { ... }
    ...

    @MaxLength(2048)
    @MultiLine
    public String getNotes() { ... }
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.DerivedProperty">
        <title>How to make a derived property</title>

        <sect2>
          <title>Lazily derived</title>

          <para>Omitting the mutator (<code>setXxx()</code>) method for a
          property indicates both that the field is will not be persisted, and
          it will <emphasis>also</emphasis> be unmodifiable. This is the
          standard approach to derive a property from other information
          available to the object. It also happens to be compatible with Java
          Persistence Api (JPA) semantics.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Employee {
    public Department getDepartment() { ... }
    ...

    // this is the derived property
    public Employee getManager() {
        if (getDepartment() == null) { return null; }
        return getDepartment().getManager();
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Eagerly derived</title>

          <para>An alternative to omitting the mutator is to mark a property
          is to keep the mutator, but to annotate the property with
          <classname>@NotPersisted</classname>.</para>

          <para>Because the data is non-persisted, some other mechanism must
          be used to initialize the property. Typically this will be a
          lifecycle method (see <xref linkend="sec.LifecycleMethods" />),
          which eagerly derive the value of the property.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Employee {
    public void loaded() {
        if (getDepartment() != null) { 
            setManager(getDepartment().getManager());
        }
    }

    public Department getDepartment() { ... }
    ...

    @NotPersisted
    public Employee getManager() { ... }
    private void setManager(Employee manager) { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to make an (eagerly-) derived property</title>

        <note>
          <para>Using eager derivation can be problematic, because a change in
          an underlying value must be reflected wherever it is
          required.</para>
        </note>
      </sect1>

      <sect1 id="sec.HiddenProperty">
        <title>How to hide a property from the user</title>

        <para>The mechanism for hiding a property is broadly the same as for
        hiding a collection (see <xref linkend="sec.HiddenCollection" />) or
        an action (see <xref linkend="sec.HiddenActions" />).</para>

        <sect2>
          <title>Hiding a property always</title>

          <para>To prevent a user from viewing a property at all, use the
          <literal moreinfo="none">@Hidden</literal> annotation. A common use
          case is to hide an internal Id, eg perhaps as required by the object
          store.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class OrderLine {
    private Integer id;
    @Hidden
    public Integer getId() { ... }
    public void setId(Integer id) { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a property based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a property may be optionally
          hidden using the <classname>@Hidden</classname> annotation based on
          the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to hide the property when the object is transient, use
              <code>@Hidden(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to hide the property when the object is persistent, use
              <code>@Hidden(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Hiding a property under certain conditions</title>

          <para>A <literal moreinfo="none">hideXxx()</literal> method can be
          used to indicate that a particular object's property should be
          hidden under certain conditions, typically relating to the state of
          that instance.</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public boolean hidePropertyName()</literal> </programlisting>

          <para>Returning a value of <code>true</code> indicates that the
          property should be hidden.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public String getShippingInstructions() { ... }
    public void setShippingInstructions(String shippingInstructions) { ... }
    public boolean hideShippingInstructions() {
        return hasShipped();
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a property for specific users or roles</title>

          <para>It is possible to hide properties for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" />for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.DisabledProperty">
        <title>How to prevent a property from being modified</title>

        <para>Preventing the user from modifying a property value is known as
        'disabling' the property. Note that this doesn't prevent the property
        from being modified programmatically.</para>

        <para>The mechanism for disabling a property is broadly the same as
        for disabling a collection (see <xref
        linkend="sec.DisabledCollection" />) or a collection (see <xref
        linkend="sec.DisabledCollection" />).</para>

        <sect2>
          <title>Disabling a property permanently</title>

          <para>To prevent a user from being able to modify the property at
          all, use the <literal moreinfo="none">@Disabled</literal>
          annotation.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class OrderLine {
    private int quantity;
    @Disabled
    public String getQuantity() { ... }
    public void setQuantity(int quantity) { ... }
    ...
}</programlisting>

          <para>Note that a setter is still required; this is used by the
          framework to recreate the object when pulled back from the
          persistent object store.</para>
        </sect2>

        <sect2>
          <title>Disabling a property based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a property may be optionally
          disabled using the <classname>@Disabled</classname> annotation based
          on the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to disable the property when the object is transient, use
              <code>@Disabled(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to disable the property when the object is persistent, use
              <code>@Disabled(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Disabling a property under certain conditions</title>

          <para>A supporting <literal moreinfo="none">disableXxx()</literal>
          method can be used to disable a particular instance's member under
          certain conditions</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public String disablePropertyName()</literal></programlisting>

          <para>A non-<code>null</code> return value indicates the reason why
          the property cannot be modified. The framework is responsible for
          providing this feedback to the user.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class OrderLine {
    public String getQuantity() { ... }
    public void setQuantity(int quantity) { ... }
    public String disableQuantity() { 
        if (isSubmitted()) {
            return "Cannot alter any quantity after Order has been submitted"; 
        }
        return null;
    }
}</programlisting>

          <para>If there are multiple reasons to disable a property, take a
          look at the
          <classname>org.apache.isis.applib.util.ReasonBuffer</classname>
          helper.</para>
        </sect2>

        <sect2>
          <title>Disabling a property for certain users/roles</title>

          <para>It is possible to disable properties for certain users/roles
          by calling the
          <methodname>DomainObjectContainer#getUser()</methodname> method. See
          <xref linkend="sec.BusinessRulesForCertainUsersOrRoles" />for
          further discussion.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>How to validate user input for a property</title>

        <sect2>
          <title>Declarative validation</title>

          <para>For properties that accept a text input string, such as
          <code>String</code> and <code>Date</code>, there are convenient
          mechanisms to validate and/or normalise the values typed in:</para>

          <itemizedlist>
            <listitem>
              <para>For <literal moreinfo="none">Date</literal> and number
              values the <literal moreinfo="none">@Mask</literal> annotation
              may be used.</para>
            </listitem>

            <listitem>
              <para>For <literal moreinfo="none">String</literal> properties
              the <literal moreinfo="none">@RegEx</literal> annotation may be
              used.</para>
            </listitem>
          </itemizedlist>

          <para>More complex validation can also be performed imperatively
          (below).</para>
        </sect2>

        <sect2>
          <title>Imperative validation</title>

          <para>A supporting <literal moreinfo="none">validateXxx()</literal>
          method is used to check that a new value for a property is
          valid.</para>

          <para>If the proffered value is deemed to be invalid then the
          property will not be changed. A non-null return <code>String</code>
          indicates the reason why the member cannot be modified/action be
          invoked; the framework is responsible for providing this feedback to
          the user.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String validatePropertyName(PropertyType param)</programlisting></para>

          <para>where <literal moreinfo="none">PropertyType</literal> is the
          same type as that of the property itself.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Exam {
    public int getMark() { ... }
    public void setMark(int mark) { ... }
    public validateMark(int mark) {
        return !withinRange(mark)? "Mark must be in range 0 to 30":null;
    }
    private boolean withinRange(int mark) { return mark &gt;= 0 &amp;&amp; mark &lt;= 30; }
}</programlisting>
        </sect2>
      </sect1>

      <sect1 id="sec.DefaultPropertyValue">
        <title>How to set up the initial value of a property
        programmatically</title>

        <para>After an object has been created (see <xref
        linkend="sec.HowToCreateAnObject" />), there are several different
        ways to setup the initial values for an object's properties.</para>

        <sect2>
          <title>By each property's default values</title>

          <para>Firstly, the default value for a property can be supplied
          using a supporting <methodname>defaultXxx()</methodname> method. The
          syntax for specifying a default value is:</para>

          <para><programlisting>public PropertyType defaultPropertyName()</programlisting></para>

          <para>where <literal moreinfo="none">PropertyType</literal> is the
          same type as that of the property itself.</para>

          <programlisting format="linespecific">public class Order {
    public Address getShippingAddress() { ... }
    public void setShippingAddress() { ... }
    public Address defaultShippingAddress() {
        return getCustomer().normalAddress();
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>By the <methodname>created()</methodname> lifecycle
          method</title>

          <para>Alternatively, the domain object may choose to initialize its
          property values in the <literal moreinfo="none">created()</literal>
          lifecycle method (see <xref linkend="sec.LifecycleMethods" />). This
          is called after any <methodname>defaultXxx()</methodname> methods
          are called.</para>
        </sect2>

        <sect2>
          <title>Programmatically, by the creator</title>

          <para>Third, and perhaps most obviously, the creator of the object
          could initialize the properties of the object immediately after
          calling <methodname>newTransientInstance(...)</methodname>. This
          would be appropriate if the creator had reason to override any
          values setup in the <methodname>defaultXxx()</methodname> or
          <methodname>created()</methodname> methods discussed above.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify a set of choices for a property</title>

        <para>The simplest way to provide the user with a set of choices for a
        property (possibly rendered as a drop-down list, for example) is to
        ensure that the type used by the property is marked up as
        <code>@Bounded</code> (see <xref linkend="sec.Bounded" />).</para>

        <para>However, this is not always appropriate. For example you might
        wish to provide the user with the choice of all the
        <classname>Address</classname>es known for that
        <classname>Customer</classname>, with the most recently-used address
        as the default.</para>

        <para>The syntax for specifying a list of choices is either:</para>

        <para><programlisting>public Collection&lt;PropertyType&gt; choicesPropertyName()</programlisting></para>

        <para>or alternatively</para>

        <programlisting>public PropertyType[] choicesPropertyName()</programlisting>

        <para>where <literal moreinfo="none">PropertyType</literal> is the
        same type as that of the property itself.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Order {
    public Address getShippingAddress() { ... }
    public void setShippingAddress() { ... }
    public List&lt;Address&gt; choicesShippingAddress() {
        return getCustomer().allActiveAddresses();
    }
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.ModifyAndClear">
        <title>How to trigger other behaviour when a property is
        changed</title>

        <para>If you want to invoke functionality whenever a property is
        changed by the user, then you should create a supporting <literal
        moreinfo="none">modifyXxx()</literal> method and include the
        functionality within that. The syntax is:</para>

        <programlisting>public void modifyPropertyName(PropertyType param)</programlisting>

        <para>Why not just put this functionality in the setter? Well, the
        setter is used by the object store to recreate the state of an already
        persisted object. Putting additional behaviour in the setter would
        cause it to be triggered incorrectly.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Order() {
    public Integer getAmount() { ... }
    public void setAmount(Integer amount) { ... }
    public void modifyAmount(Integer amount) {
        setAmount(amount);
        addToTotal(amount);
    }
    ...
}</programlisting>

        <para>Here the <literal moreinfo="none">modifyAmount()</literal>
        method also calls the <literal moreinfo="none">addToTotal()</literal>
        call as well as the <literal moreinfo="none">setAmount()</literal>
        method. We don't want this <methodname>addToCall()</methodname> method
        to be called when pulling the object back from the object store, so we
        put it into the modify, not the setter.</para>

        <para>You may optionally also specify a <code>clearXxx()</code> which
        works the same way as modify <literal moreinfo="none">modify</literal>
        <literal moreinfo="none">Xxx()</literal> but is called when the
        property is cleared by the user (i.e. the current value replaced by
        nothing). The syntax is:</para>

        <programlisting>public void clearPropertyName()</programlisting>

        <para>To extend the above example:</para>

        <programlisting format="linespecific">public class Order() {
    public Integer getAmount() { ... }
    public void setAmount(Integer amount) { ... }
    public void modifyAmount(Integer amount) { ... }
    public void clearAmount() {
        removeFromTotal(this.amount);
        setAmount(null);
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to setup a bidirectional relationship</title>

        <para>The <methodname>modifyXxx()</methodname> and
        <methodname>clearXxx()</methodname> methods (see <xref
        linkend="sec.ModifyAndClear" />) can be used to setup bidirectional
        relationships. This is typically done with 1:m relationships, eg
        between <classname>Order</classname> and
        <classname>OrderLine</classname>, or <classname>Department</classname>
        and <classname>Employee</classname>.</para>

        <para>For further discussion and a complete example, see <xref
        linkend="sec.MutualRegistrationPattern" />.</para>
      </sect1>
    </chapter>

    <chapter id="chp.Collections">
      <title>Domain Entity Collections</title>

      <abstract>
        <para>How-to's relating to a domain entity's collections.</para>
      </abstract>

      <para>A collection is a list of references to several entity that have a
      common type. The following conventions are concerned with specifying the
      collections of an object, and the means by which a user can interact
      with those collections.</para>

      <sect1>
        <title>How to add a collection to an object</title>

        <para>A collection is recognized via an accessor/mutator method pair
        (<code>get</code> and set) for any type of collection provided by the
        programming language.</para>

        <para>The syntax is either:</para>

        <para><programlisting>public Collection&lt;EntityType&gt; getCollectionName()
private void setCollectionName(Collection&lt;EntityType&gt; param)</programlisting></para>

        <para>or:</para>

        <para><programlisting>public List&lt;EntityType&gt; getCollectionName()
private void setCollectionName(List&lt;EntityType&gt; param)</programlisting></para>

        <para>or:</para>

        <para><programlisting>public Set&lt;EntityType&gt; getCollectionName()
private void setCollectionName(Set&lt;EntityType&gt; param)</programlisting></para>

        <para>A mutator is required, but it need only have
        <code>private</code> visibility.</para>

        <para>Note:</para>

        <note>
          <para><classname>Map</classname>s cannot be used for
          collections.</para>
        </note>

        <para>It is recommended that the collections be specified using
        generics (for example: <literal
        moreinfo="none">List&lt;Customer&gt;</literal> ). That way the
        framework will be able to display the collection based on that type
        definition. If a raw type is used then the framework will attempt to
        infer the type from the addToXxx() / removeFromXxx() supporting
        methods, if specified (see <xref linkend="sec.AddToRemoveFrom" />). If
        the framework is unable to determine the type of the collection, it
        will mean that some viewers will represent the collection is a less
        sophisticated manner (eg a simple list of titles rather than a
        table).</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Employee { ... }

public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List &lt;Employee&gt; getEmployees() {
        return employees;
    }
    private void setEmployees(List&lt;Employee&gt; employees) { 
        this.employees = employees;
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to specify a name and/or description for a
        collection</title>

        <sect2>
          <title>Specifying the name for a collection</title>

          <para>By default the framework will use the collection name itself
          to label the collection on the user interface. If you wish to
          override this, use the <literal moreinfo="none">@Named</literal>
          annotation on the collection.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @Named("Placed Orders")
    public List&lt;Order&gt; getOrders() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Specifying a description for a collection</title>

          <para>An additional description can be provided on a collection
          using the <literal moreinfo="none">@DescribedAs</literal>
          annotation. The framework will take responsibility to make this
          description available to the user, for example in the form of a
          tooltip.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @DescribedAs("Those orders that have been placed (and possibly shipped) " + 
                 "by this customer given name by which this customer is known")
    public List&lt;Order&gt; getOrders() { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1 id="sec.MemberOrderForCollections">
        <title>How to specify the order in which collections are
        displayed</title>

        <para>The <literal moreinfo="none">@MemberOrder</literal> annotation
        provides a hint to the viewer as to the order in which the collections
        (and also properties, see <xref
        linkend="sec.MemberOrderForProperties" />) should appear in the
        <acronym>GUI</acronym>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    @MemberOrder("3")
    public Collection&lt;Order&gt; getRecentOrders() { ... }
    ...

    @MemberOrder("4")
    public Collection&lt;Order&gt; getOrders() { ... }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to make a derived collection</title>

        <para>Collections can be derived by omitting the mutator (the same way
        as properties, see <xref linkend="sec.DerivedProperty" />). Derived
        collections are not persisted, and are represented as read only
        collections.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Department {
    // Standard collection
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt;) { ... }

    // Derived collection
    public List&lt;Employee&gt; getTerminatedEmployees() {
        List&lt;Employee&gt; terminatedEmployees = new ArrayListt&lt;Employee&gt;();
        for(Employee e: employees) {
            if (e.isTerminated()) {
                addTo(terminatedEmployees, e);
            }
        }
        return terminatedEmployees;
    }
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.HiddenCollection">
        <title>How to hide a collection</title>

        <para>The mechanism for hiding a collection is broadly the same as for
        hiding a property (see <xref linkend="sec.HiddenProperty" />) or an
        action (see <xref linkend="sec.HiddenActions" />).</para>

        <sect2>
          <title>Hiding a collection permanently</title>

          <para>To prevent a user from viewing a collection at all, use the
          <literal moreinfo="none">@Hidden</literal> annotation.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    private List&lt;Order&gt; cancelledOrders = new ArrayList&lt;Order&gt;();
    @Hidden
    public List&lt;Order&gt; getCancelledOrders() { ... }
    private void setCancelledOrders(List&lt;Order&gt; cancelledOrders) { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a collection based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a collection may be optionally
          hidden using the <classname>@Hidden</classname> annotation based on
          the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to hide the collection when the object is transient, use
              <code>@Hidden(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to hide the collection when the object is persistent, use
              <code>@Hidden(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Hiding a collection under certain conditions</title>

          <para>A <literal moreinfo="none">hideXxx()</literal> method can be
          used to indicate that a particular object's collection should be
          hidden under certain conditions, typically relating to the state of
          that instance.</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public boolean hideCollectionName()</literal> </programlisting>

          <para>Returning a value of <code>true</code> indicates that the
          collection should be hidden.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    @Hidden
    public List&lt;Order&gt; getRushOrders() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a collection for specific users or roles</title>

          <para>It is possible to hide collections for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.DisabledCollection">
        <title>How to prevent a collection from being modified</title>

        <para>Preventing the user from adding to or removing from a collection
        is known as 'disabling' the collection.</para>

        <para>The mechanism for disabling a collection is broadly the same as
        for disabling a property (see <xref linkend="sec.DisabledProperty" />)
        or a action (see <xref linkend="sec.DisabledAction" />).</para>

        <sect2>
          <title>Disabling a collection permanently</title>

          <para>Some, though not all, viewers allow the user to directly
          manipulate the contents of a collection. For example, the DnD viewer
          will allow new objects to be "dropped" into a collection, and
          existing objects removed from a collection.</para>

          <para>Although it is possible to associate behaviour with such
          actions (see <xref linkend="sec.AddToRemoveFrom" />), it may be
          preferred to only allow modification through actions. Or, the
          application may be deployed using a viewer that doesn't fully
          support direct manipulation of collections.</para>

          <para>In either case, annotate the collection using the <literal
          moreinfo="none">@Disabled</literal> annotation.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    private List&lt;Order&gt; cancelledOrders = new ArrayList&lt;Order&gt;();
    @Disabled
    public List&lt;Order&gt; getCancelledOrders() { ... }
    private void setCancelledOrders(List&lt;Order&gt; cancelledOrders) { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Disabling a collection based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a collection may be optionally
          disabled using the <classname>@Disabled</classname> annotation based
          on the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to disable the collection when the object is transient,
              use <code>@Disabled(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to disable the collection when the object is persistent,
              use <code>@Disabled(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Disabling a collection under certain conditions</title>

          <para>A <literal moreinfo="none">disableXxx()</literal> method can
          be used to disable a particular instance's collection under certain
          conditions:</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public String disableCollectionName()</literal> </programlisting>

          <para>For example:</para>

          <programlisting format="linespecific">public class Department {
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public void disableEmployees() {
        return isClosed()? "This department is closed" : null;
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Disabling a collection for specific users or roles</title>

          <para>It is possible to disable collections for certain users/roles
          by calling the
          <methodname>DoymainObjectContainer#getUser()</methodname> method.
          See <xref linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for
          further discussion.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>How to validate an object being added or removed</title>

        <para>A <literal moreinfo="none">validateAddToXxx()</literal> method
        can be used to check that an object is valid to be added to a
        collection. Conversely, the
        <methodname>validateRemoveFromXxx()</methodname> method can be used to
        check that it is valid to remove an object from a collection is
        valid.</para>

        <para>The syntax is:</para>

        <para><programlisting>public String validateAddToCollectionName(EntityType param)</programlisting></para>

        <para>and</para>

        <programlisting>public String validateRemoveFromCollectionName(EntityType param)</programlisting>

        <para>A non-<code>null</code> return <code>String</code> indicates the
        reason why the object cannot be added/removed, and the viewing
        mechanism will display this to the user.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Department {
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public String validateAddToEmployee(Employee employee) {
        return employee.isRetired()?
            "Cannot add retired employees to department"
            :null;
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.AddToRemoveFrom">
        <title>How to trigger other behaviour when an object is added or
        removed</title>

        <para>A collection may have a corresponding <literal
        moreinfo="none">addToXxx()</literal> and/or <literal
        moreinfo="none">removeFromXxx()</literal> method. If present, and
        direct manipulation of the contents of the connection has not been
        disabled (see <xref linkend="sec.DisabledCollection" />), then they
        will be called (instead of adding/removing an object directly to the
        collection returned by the accessor).</para>

        <para>The reason for this behaviour is to allow other behaviour to be
        triggered when the contents of the collection is altered. That is, it
        is directly equivalent to the supporting <literal
        moreinfo="none">modifyXxx()</literal> and <literal
        moreinfo="none">clearXxx()</literal> methods for properties (see <xref
        linkend="sec.ModifyAndClear" />).</para>

        <para>The syntax is:</para>

        <para><programlisting>public void addTo&lt;CollectionName&gt;(EntityType param)</programlisting></para>

        <para>and</para>

        <programlisting>public void removeFromCollectionName(EntityType param)</programlisting>

        <para>where <literal moreinfo="none">EntityType</literal> is the same
        type as the generic collection type.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Employee { ... }

public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List &lt;Employee&gt; getEmployees() {
        return employees;
    }
    private void setEmployees(List&lt;Employee&gt; employees) { 
        this.employees = employees;
    }
    public void addToEmployees(Employee employee) {
        numMaleEmployees += countOneMale(employee);
        numFemaleEmployees += countOneFemale(employee);
        employees.add(employee);
    }
    public void removeFromEmployees(Employee employee) {
        numMaleEmployees -= countOneMale(employee);
        numFemaleEmployees -= countOneFemale(employee);
        employees.remove(employee);
    }
    private int countOneMale(Employee employee) { return employee.isMale()?1:0; }
    private int countOneFemale(Employee employee) { return employee.isFemale()?1:0; }

    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.MutualRegistrationPattern">
        <title>How to maintain bidirectional relationships</title>

        <para>The recommended way of maintaining a bidirectional relationship
        is to use the 'mutual registration pattern', a write-up of which can
        be found at <ulink
        url="???">http://www.two-sdg.demon.co.uk/curbralan/papers/MutualRegistration.pdf</ulink>.
        The general idea is that one side of the relationship is responsible
        for maintaining the associations, while the other side simply
        delegates.</para>

        <para>To implement this in <emphasis>Isis</emphasis> for a 1:m
        relationship, use the <methodname>addToXxx()</methodname> /
        <methodname>removeFromXxx()</methodname> and
        <methodname>modifyXxx()</methodname> /
        <methodname>clearXxx()</methodname> methods.</para>

        <para>For example:</para>

        <programlisting>public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public void addToEmployees(Employee e) {
        if(e == null || employees.contains(e)) return;
        e.setDepartment(this);
        employees.add(e);
    }
    public void removeFromEmployees(Employee e) {
        if(e == null || !employees.contains(e)) return;
        e.setDepartment(null);
        employees.remove(e);
    }
    ...
}</programlisting>

        <para>and</para>

        <programlisting>public class Employee {
    private Department department;
    public Department getDepartment() { ... }
    private void setDepartment(Department department) { ... }
    public void modifyDepartment(Department d) {
        if(d==null || department==d) return;
        if(department != null) {
            department.removeFromEmployees(this);
        }
        d.addToEmployees(this);
    }
    public void clearDepartment() {
        if(department==null) return;
        department.removeFromEmployees(this);
    }
    ...
}</programlisting>
      </sect1>
    </chapter>

    <chapter id="chp.Actions">
      <title>Domain Entity Actions</title>

      <abstract>
        <para>How-to's relating to a domain entity's actions.</para>
      </abstract>

      <para>An 'action' is a method that we expect the user to be able to
      invoke on a domain entity via the user interface, though it may also be
      invoked programmatically within the object model. The following
      conventions are used to determine when and how methods are made
      available to the user as actions, and the means by which a user can
      interact with those actions.</para>

      <sect1>
        <title>How to add an action to an object</title>

        <para>By default, any <literal moreinfo="none">public</literal>
        instance method that you add to a class will be treated as a user
        action, unless it represents a property, collection, or another
        reserved method defined in this guide.</para>

        <para>The syntax is:</para>

        <para><programlisting>public void actionName([ValueOrEntityType param] ...)</programlisting></para>

        <para>or</para>

        <para><programlisting>public ReturnType actionName([ValueOrEntityType param] ...)</programlisting></para>

        <para>When a method returns a reference the viewer will attempt to
        display that object. If the return value is <code>null</code> then
        nothing is displayed.</para>

        <para>We refer to all methods that are intended to be invoked by users
        as 'action methods'.</para>

        <para>If you have a method that you don't want to be made available as
        a user-action you can either:</para>

        <itemizedlist>
          <listitem>
            <para>make it non-<literal>public</literal> (eg <literal
            moreinfo="none">protected</literal> or <literal
            moreinfo="none">private</literal>)</para>
          </listitem>

          <listitem>
            <para>annotate it with <classname>@Ignore</classname></para>
          </listitem>

          <listitem>
            <para>annotate it with <classname>@Hidden</classname> (discussed
            further in <xref linkend="sec.HiddenActions" />)</para>
          </listitem>
        </itemizedlist>

        <para>Note also that <literal moreinfo="none">static</literal> methods
        are ignored: such functionality should reside in a service, such as a
        repository or factory (see <xref
        linkend="chp.DomainServices" />).</para>
      </sect1>

      <sect1>
        <title>How to specify names and/or description for an action</title>

        <sect2>
          <title>Specifying the name for an action</title>

          <para>By default the framework will use the action name itself to
          label the menu item on the user interface. If you wish to override
          this, use the <literal moreinfo="none">@Named</literal> annotation
          on the action.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @Named("Place Order")
    public void createOrder() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Specifying a description for a collection</title>

          <para>An additional description can be provided on an action using
          the <literal moreinfo="none">@DescribedAs</literal> annotation. The
          framework will take responsibility to make this description
          available to the user, for example in the form of a tooltip.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @DescribedAs("Places an order, causing a shipping note "+
                 "to be generated and invoice to be dispatched")
    public void createOrder() { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify the order in which actions appear on the
        menu</title>

        <para>The <literal moreinfo="none">@MemberOrder</literal> annotation
        provides a hint to the viewer as to the order in which the actions
        should be displayed, eg in a menu.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    @MemberOrder("3")
    public void placeOrder(Product p) { ... }
    ...

    @MemberOrder("4")
    public void blackList() { ... }
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.HiddenActions">
        <title>How to hide an action</title>

        <para>The mechanism for hiding an action is broadly the same as for
        hiding a property (see <xref linkend="sec.HiddenProperty" />) or a
        collection (see <xref linkend="sec.HiddenCollection" />).</para>

        <sect2>
          <title>Hiding an action permanently</title>

          <para>To prevent a user from viewing an action at all, use the
          <literal moreinfo="none">@Hidden</literal> annotation. This is
          generally used where a <literal moreinfo="none">public</literal>
          method on an object is not intended to be a user action</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    @Hidden
    public void markAsCancelled() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding an action based on the persistence state of the
          object</title>

          <para>As a refinement of the above, an action may be optionally
          hidden using the <classname>@Hidden</classname> annotation based on
          the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to hide the action when the object is transient, use
              <code>@Hidden(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to hide the action when the object is persistent, use
              <code>@Hidden(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Hiding an action under certain conditions</title>

          <para>A <literal moreinfo="none">hideXxx()</literal> method can be
          used to indicate that a particular object's action should be hidden
          under certain conditions, typically relating to the state of that
          instance.</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public boolean hideActionName([ValueOrEntityType param] ...)</literal> </programlisting>

          <para>where the parameter types should match the action itself
          (allowing for overloading)</para>

          <para>or</para>

          <programlisting><literal moreinfo="none">public boolean hideActionName()</literal> </programlisting>

          <para>which applies to (all overloaded versions of) the
          action.</para>

          <para>in both cases, returning a value of <code>true</code>
          indicates that the action should be hidden.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public void applyDiscount(int percentage) { ... }
    public boolean hideApplyDiscount() {
        return isWholesaleOrder();
    }
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding an action for specific users or roles</title>

          <para>It is possible to hide actions for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.DisabledAction">
        <title>How to prevent an action from being invoked</title>

        <para>Preventing the user from invoking an action is known as
        'disabling' the action.</para>

        <para>The mechanism for disabling an action is broadly the same as for
        disabling a property (see <xref linkend="sec.DisabledProperty" />) or
        a collection (see <xref linkend="sec.DisabledCollection" />).</para>

        <sect2>
          <title>Disabling an action permanently</title>

          <para>It is possible to prevent an action from ever being invoked
          using the <classname>@Disabled</classname> annotation, exactly
          equivalent to the use of the annotation for properties and
          collections. However, it's not a particularly meaningful usecase:
          why display an action that can never be invoked? The only reason we
          can think of is as a placeholder during prototyping - to indicate to
          the user that an action is planned, but has not yet been
          implemented.</para>
        </sect2>

        <sect2>
          <title>Disabling an action based on the persistence state of the
          object</title>

          <para>Whereas annotating an action simply as
          <classname>@Disabled</classname> probably does not make sense (see
          above), it does make sense to optionally disable an action using the
          <classname>@Disabled</classname> annotation based on the persistence
          state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to disable the action when the object is transient, use
              <code>@Disabled(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to disable the action when the object is persistent, use
              <code>@Disabled(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Based on the state of the object</title>

          <para>There may be circumstances in which we do not want the user to
          be able to initiate the action at all - for example because that
          action is not appropriate to the current state of the object on
          which the action resides. Such rules are enforced by means of a
          <literal moreinfo="none">disableXxx()</literal> supporting
          method.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String disableActionName([ValueOrEntityType param]...)</programlisting></para>

          <para>A non-<literal>null</literal> return <code>String</code>
          indicates the reason why the action may not be invoked. The
          framework takes responsibility to provide this feedback to the
          user.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String disablePlaceOrder(Product p, int quantity) { 
        return isBlackListed()?
            "Blacklisted customers cannot place orders"
            :null;
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Disabling an action for certain users or roles</title>

          <para>It is possible to disable actions for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify names and/or descriptions for an action
        parameter</title>

        <para>Unlike with properties, the framework cannot pick up the names
        of parameters that you use within the domain code. By default
        parameters will be labelled only with the type of the object required
        (e.g. 'String:' or 'Customer:)</para>

        <para>If you want a parameter to have a different name (such as 'First
        Name', 'Last Name') then that parameter should be marked up with an
        <literal moreinfo="none">@Named</literal> annotation - very often
        taking the same form as the parameter name used in the code.
        Alternatively though, you could create a user-defined value type,
        using <literal>@Value</literal> (see <xref
        linkend="chp.ValueTypes" />).</para>

        <para>Similarly, any parameter may be given a short user-description
        using the <literal moreinfo="none">@DescribedAs</literal> annotation.
        The framework takes responsibility to make this available to the
        user.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
            Product p, 
            @Named("Quantity")
            @DescribedAs("The number of units of the specified product in this order")
            int quantity) {
        ...
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to specify the size of <classname>String</classname> action
        parameters</title>

        <para>As for properties (see <xref linkend="sec.SizeProperties" />),
        use:</para>

        <itemizedlist>
          <listitem>
            <para>the <literal moreinfo="none">@MaxLength</literal> to specify
            the maximum number of characters that may be stored within a
            <classname>String</classname> parameter.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@TypicalLength</literal> to
            specify the typical number of characters that are likely to be
            stored within a <classname>String</classname> parameter. Viewers
            are expected to use this as a hint as to the size of the field to
            render for the parameter.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@MultiLine</literal> annotation
            as a hint to indicate that the parameter should be displayed over
            multiple lines (eg as a text area rather than a text
            field).</para>
          </listitem>
        </itemizedlist>

        <para>For example:</para>

        <programlisting format="linespecific">public class TicketRaiser {

    public void raiseTicket(
            @TypicalLength(50) @MaxLength(255) @Named("Description")
            String getDescription,
            @MaxLength(2048) @MultiLine @Named("Notes")
            String notes) {
        ...
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to make an action parameter optional</title>

        <para>By default, the framework assumes that when an action method is
        to be invoked, all the parameters are mandatory. You may over-ride
        this behaviour by marking up one or more of the paramaters with the
        <literal moreinfo="none">@Optional</literal> annotation.</para>
      </sect1>

      <sect1>
        <title>How to validate an action parameter argument</title>

        <sect2>
          <title>Declarative validation</title>

          <para>For parameters that accept a text input string, such as
          <code>String</code> and <code>Date</code>, there are convenient
          mechanisms to validate and/or normalise the values typed in:</para>

          <itemizedlist>
            <listitem>
              <para>For <literal moreinfo="none">Date</literal> and number
              values the <literal moreinfo="none">@Mask</literal> annotation
              may be used.</para>
            </listitem>

            <listitem>
              <para>For <literal moreinfo="none">String</literal> parameters
              the <literal moreinfo="none">@RegEx</literal> annotation may be
              used.</para>
            </listitem>
          </itemizedlist>

          <para>More complex validation can also be performed imperatively
          (below).</para>
        </sect2>

        <sect2>
          <title>Imperative validation</title>

          <para>A <literal moreinfo="none">validateXxx()</literal> method is
          used to check that the set of arguments used by an action method is
          valid. If the arguments are invalid then the framework will not
          invoke the action.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String validate&lt;ActionName&gt;([ValueOrEntityType param]...)</programlisting></para>

          <para>A non-<code>null</code> return <classname>String</classname>
          indicates the reason why the member cannot be modified/action be
          invoked, and the viewing mechanism will display this feedback to the
          user.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String validatePlaceOrder(Product p, int quantity) {
        if (p.isOutOfStock()) { return "Product is out of stock"; }
        if (quantity &lt;= 0) { return "Quantity must be a positive value"; }
        return null;
    }
    ...
}</programlisting>

          <para>For complex validation, you may wish to use the
          <classname>org.apache.isis.applib.util.ReasonBuffer</classname>
          helper class.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify default values for an action parameter</title>

        <para>When an action is about to be invoked, then default values can
        be provided for any or all of its parameters.</para>

        <para>There are two different ways to specify parameters; either per
        parameter, or for all parameters.</para>

        <sect2>
          <title>Per-parameter syntax (preferred)</title>

          <para>The per-parameter form is simpler and generally to be
          preferred.</para>

          <para>The syntax is:</para>

          <programlisting>public ParameterType defaultNActionName()</programlisting>

          <para>where N indicates the 0-based parameter number. For
          example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
             Product product,
             @Named("Quantity") 
             int quantity) {
        ...
    }
    public Product default0PlaceOrder() {
        return productMostRecentlyOrderedBy(this.getCustomer());
    }
    public int default1PlaceOrder() {
        return 1;
    }
}</programlisting>
        </sect2>

        <sect2>
          <title>All parameters syntax</title>

          <para>The syntax for specifying all the parameter default values in
          one go is:</para>

          <para><programlisting>public Object[] defaultActionName([ValueOrEntityType param]...)</programlisting></para>

          <para>returning an array which must have one element per parameter
          in the action method signature of corresponding default
          values.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
            Product product,
            @Named("Quantity") 
            int quantity) {
        ...
    }
    public Object[] defaultPlaceOrder(
            Product product,
            int quantity) {
        return new Object[] {
            productMostRecentlyOrderedBy(this.getCustomer()),
            1
        };
    }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify a set of choices for an action parameter</title>

        <para>The programmer may provide a set of choices for the value of any
        or all of the parameters of an action. These will be made available to
        the user - for example as a drop-down list.</para>

        <para>If the type of the parameter is annotated with <literal
        moreinfo="none">@Bounded</literal>, then it is not necessary to
        specify the choices for that parameter, as the user will automatically
        be offered the full set to choose from.</para>

        <para>If this isn't the case, then - as for defaults - there are two
        different ways to specify parameters; either per parameter, or for all
        parameters.</para>

        <sect2>
          <title>Per parameter syntax (preferred)</title>

          <para>The per-parameter form is simpler and generally
          preferred.</para>

          <para>The syntax is:</para>

          <programlisting>public List&lt;ParameterType&gt; choicesNActionName()</programlisting>

          <para>where N indicates the 0-based parameter number.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public Order placeOrder(
            Product product,
            @Named("Quantity") 
            int quantity) {
        ...
    }
    public List&lt;Product&gt; choices0PlaceOrder() {
        return lastFiveProductsOrderedBy(this.getCustomer());
    }
    public List&lt;Integer&gt; choices1PlaceOrder() {
        return Arrays.asList(1,2,3,4,5);
    }
    ....
}</programlisting>
        </sect2>

        <sect2>
          <title>All parameters syntax</title>

          <para>The alternative mechanism is to supply all the parameter
          choices in one go:</para>

          <para><programlisting>public Object[] choices&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

          <para>returning an array, which must have one element per parameter
          in the method signature. Each element of the array should itself
          either be an array or a list, containing the set of values
          representing the choices for that parameter, or <literal
          moreinfo="none">null</literal> if there are no choices to be
          specified for that parameter.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public Order placeOrder(
            Product product,
            @Named("Quantity") 
            int quantity) {
        ...
    }
    public Object[] choicesPlaceOrder(
            Product product,
            int quantity) {
        return new Object[] {
            lastFiveProductsOrderedBy(this.getCustomer()).toArray(), 
            Arrays.asList(1,2,3,4,5)
        };
    }
    ...
}</programlisting>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title>Further Business Rule How-Tos</title>

      <abstract>
        <para>Further validation how-to's that apply across all class
        members</para>
      </abstract>

      <para>This chapter has some additional recipes/how-tos relating to
      implementing business rules. They apply across all class members.</para>

      <sect1 id="sec.MustSpecify">
        <title>@MustSatisfy Specification</title>

        <para>The <literal>@MustSatisfy</literal> annotation is an alternative
        to using imperative validation, allowing validation rules to be
        captured in an (implementation of a)
        <classname>org.apache.isis.applib.spec.Specification</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class DomainObjectWithMustSatisfyAnnotations extends AbstractDomainObject {

    private String lastName;
    @MustSatisfy(SpecificationRequiresFirstLetterToBeUpperCase.class)
    public String getLastName() {
        resolve(lastName);
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        objectChanged();
    }

    public void changeLastName(
            @MustSatisfy(SpecificationRequiresFirstLetterToBeUpperCase.class)
            String lastName
            ) {
        setLastName(lastName);
    }

}</programlisting>

        <para>To help you write your own
        <classname>Specification</classname>s, there are some adapter classes
        in <package>org.apache.isis.applib.specs</package>:</para>

        <itemizedlist>
          <listitem>
            <para><classname>AbstractSpecification</classname>, which
            implements <classname>Specification</classname> and takes
            inspiration from the <ulink
            url="http://code.google.com/p/hamcrest/">Hamcrest</ulink>
            library's <classname>TypeSafeMatcher</classname> class</para>
          </listitem>

          <listitem>
            <para><classname>SpecificationAnd</classname>, which allows a set
            of <classname>Specification</classname>s to be grouped together
            and require that <emphasis>all</emphasis> of them are
            satisfied</para>
          </listitem>

          <listitem>
            <para><classname>SpecificationOr</classname>, which allows a set
            of <classname>Specification</classname>s to be grouped together
            and require that <emphasis>at least one</emphasis> of them is
            satisfied</para>
          </listitem>

          <listitem>
            <para><classname>SpecificationNot</classname>, which requires that
            the provided <classname>Specification</classname> is
            <emphasis>not</emphasis> satisfied</para>
          </listitem>
        </itemizedlist>
      </sect1>

      <sect1 id="sec.BusinessRulesForCertainUsersOrRoles">
        <title>Hiding, disabling or validating for specific users or
        roles</title>

        <para>Generally it is not good practice to embed knowledge of roles
        and/or users into the domain classes; instead, this should be the
        responsibility of the framework or platform and should be specified
        and administered externally to the domain model. However, in rare
        circumstances it might be necessary or pragmatic to implement access
        control within the domain model.</para>

        <para>The current user can be obtained from
        <classname>DomainObjectContainer</classname>, using its
        <methodname>getUser()</methodname> method. Alternatively, if the
        domain object inherits from
        <classname>AbstractDomainObject</classname>, then
        <methodname>getUser()</methodname> is also inherited. In either case
        the method returns an object of type
        <methodname>org.apache.isis.security.UserMemento</methodname>, which
        holds both username and the set of roles for that user. The full
        details of the security classes can be found in <xref
        linkend="apx.SecurityClasses" />.</para>

        <para>The mechanism to apply a business rule is just to return an
        appropriate value from a supporting
        <methodname>hideXxx()</methodname>,
        <methodname>disableXxx()</methodname> or
        <methodname>validateXxx()</methodname> method.</para>

        <para>For example, the following requires that the MODIFY_SALARY role
        is assigned to the current user in order to update a salary property
        beyond a certain value:</para>

        <programlisting format="linespecific">public class Employee extends AbstractDomainObject {
    public BigDecimal getSalary() { ... }
    public void setSalary(BigDecimal salary) { ... }
    public String validateSalary() {
        return salary.doubleValue() &gt;= 30000 &amp;&amp;
              !getUser().hasRole("MODIFY_SALARY")?
              "Need MODIFY_SALARY role to increase salary above 30000": null;
    }
}</programlisting>
      </sect1>

      <sect1>
        <title>How to pass a messages and errors back to the user</title>

        <para>Sometimes, within an action it is necessary or desirable to pass
        a message to the user, for example to inform them of the results of
        their action ('5 payments have been issued') or that the action was
        not successful ('No Customer found with name John Smith').</para>

        <para><code>DomainObjectContainer</code> defines three methods for
        this purpose:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>informUser(String message)</methodname></para>

            <para>Inform the user of some event. The user should not be
            expected to acknowledge the message; typically the viewer will
            display the message for a period of time in a non-modal
            notification window.</para>
          </listitem>

          <listitem>
            <para><methodname>warnUser(String message)</methodname></para>

            <para>Warn the user of some event. Because this is more serious,
            the viewer should require the user to acknowledge the
            message.</para>
          </listitem>

          <listitem>
            <para><methodname>raiseError(String message)</methodname></para>

            <para>Indicate that a serious application error has occurred. The
            viewer should again require the user to acknowledge the message,
            and quite possibly indicate further steps that the user should
            perform (eg notify the help desk).</para>
          </listitem>
        </itemizedlist>

        <para>The precise mechanics of how each of these messages is rendered
        visible to the user is determined by the viewer being used.</para>
      </sect1>
    </chapter>

    <chapter id="chp.DomainServices">
      <title>Domain Services, Repositories and Factories</title>

      <abstract>
        <para>How-to's relating to writing services, repositories and
        factories.</para>
      </abstract>

      <para>This chapter contains how-to's for programming conventions that
      writing domain services (by which we also mean repositories and
      factories); ie everything that isn't a domain object or a value
      type.</para>

      <para>Domain services are instantiated once and once only by the
      framework, and are used to centralize any domain logic that does not
      logically belong in a domain entity or value. <emphasis>Isis</emphasis>
      will automatically inject services into every domain entity that
      requests them, and into each other.</para>

      <sect1 id="sec.AbstractService">
        <title>How to not inherit from framework classes</title>

        <para>Like entities, it isn't mandatory for domain services to inherit
        from any framework superclass; they can be plain-old pojos if
        required. However, again, like entities, they do at a minimum need to
        have a
        <classname>org.apache.isis.applib.DomainObjectContainer</classname>
        injected into them (an interface), from which other framework services
        can be accessed.</para>

        <para>If you don't have a requirement to inherit from any other
        superclass, then it usually makes sense to inherit from one of the
        abstract classes in the applib, either
        <classname>org.apache.isis.applib.AbstractService</classname> or
        <classname>org.apache.isis.applib.AbstractRepositoryAndFactory</classname>.
        These already supports the
        <classname>DomainObjectContainer</classname> and have a number of
        convenience helper methods.</para>

        <para>The <acronym>UML</acronym> class diagram below shows the
        relationship between these types and the
        <classname>DomainObjectContainer</classname>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/AbstractContainedObject-hierarchy.png"
                       scale="60" />
          </imageobject>
        </mediaobject>

        <para>What this means is that <emphasis>Apache Isis</emphasis> treats
        factories and repositories as just another type of domain
        service.</para>
      </sect1>

      <sect1 id="sec.Services">
        <title>How to register domain services, repositories and
        factories</title>

        <para>All domain services (which includes repositories and factories)
        should be registered in the isis.properties configuration file, under
        the <varname>isis.services.prefix</varname> (a common package name)
        and <varname>isis.services</varname> key (a comma-separated
        list).</para>

        <para>For example:</para>

        <programlisting>isis.services.prefix = org.apache.isis.support.prototype.objstore.dflt
isis.services = employee.EmployeeRepositoryDefault, claim.ClaimRepositoryDefault</programlisting>

        <para>This will instantiate a single instance of each of the two
        services listed.</para>
      </sect1>

      <sect1>
        <title>How to inject services into entities</title>

        <para>All that is required to inject a service into an entity (or
        indeed into another service) is to provide an appropriately typed
        setter. The name of the method does not matter, only that it is
        prefixed "set", is public, and has a single parameter of the correct
        type.</para>

        <para>For example:</para>

        <programlisting>public class Customer {
    private OrderRepository orderRepository;
    public void setOrderRepository(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }
    ...
}</programlisting>

        <para>Note that we consider
        <classname>DomainObjectContainer</classname> to be a service too;
        hence it can be injected in exactly the same manner.</para>
      </sect1>

      <sect1>
        <title>How to write a typical domain service</title>

        <para>Services consist of a set of logically grouped actions, and as
        such follow the same conventions as for entities (see <xref
        linkend="chp.Actions" />). However, a service cannot have (persisted)
        properties, nor can it have (persisted) collections.</para>

        <para>For convenience you can inherit from
        <classname>AbstractService</classname> or one of its subclasses (see
        <xref linkend="sec.AbstractService" />), but this is not
        mandatory.</para>

        <sect2>
          <title>The <methodname>getId()</methodname> method</title>

          <para>Optionally, a service may provide a
          <methodname>getId()</methodname> method:</para>

          <programlisting>public String getId()</programlisting>

          <para>This method returns a logical identifier for a service,
          independent of its implementation. Currently it used only by
          perspectives, providing a label by which to record the services that
          are available for a current user's profile. See <xref
          linkend="chp.UserProfiles" /> for more about profiles and
          perspectives.</para>
        </sect2>

        <sect2>
          <title>(Suppressing) contributed actions</title>

          <para>Any n-parameter action provided by a service will
          automatically be contributed to the list of actions for each of its
          (entity) parameters. From the viewpoint of the entity the action is
          called a contributed action.</para>

          <para>For example, given a service:</para>

          <programlisting>public interface Library {
    public Loan borrow(Loanable l, Borrower b);
}</programlisting>

          <para>and the entities:</para>

          <programlisting>public class Book implements Loanable { ... }y</programlisting>

          <para>and</para>

          <programlisting>public class LibraryMember implements Borrower { ... }</programlisting>

          <para>then the <methodname>borrow(...)</methodname> action will be
          contributed to both <classname>Book</classname> and to
          <classname>LibraryMember</classname>.</para>

          <para>This is an important capability because it helps to decouple
          the concrete classes from the services.</para>

          <para>If necessary, though, this behaviour can be suppressed by
          annotating the service action with
          <classname>@org.apache.isis.applib.annotations.NotContributed</classname>.</para>

          <para>For example:</para>

          <programlisting>public interface Library {
    @NotContributed
    public Loan borrow(Loanable l, Borrower b);
}</programlisting>

          <para>If annotated at the interface level, then the annotation will
          be inherited by every concrete class. Alternatively the annotation
          can be applied at the implementation class level and only apply to
          that particular implementation.</para>

          <para>Note that an action annotated as being
          <classname>@NotContributed</classname> will still appear in the
          service menu for the service. If an action should neither be
          contributed nor appear in service menu items, then simply annotate
          it as <classname>@Hidden</classname>.</para>
        </sect2>

        <sect2>
          <title>(Suppressing) service menu items</title>

          <para>By default every action of a service (by which we also mean
          repositories and factories) will be rendered in the viewer, eg as a
          menu item for that service menu. This behaviour can be suppressed by
          annotating the action using
          <classname>@org.apache.isis.applib.annotations.NotInServiceMenu</classname>.</para>

          <para>For example:</para>

          <programlisting>public interface Library {
    @NotInServiceMenu
    public Loan borrow(Loanable l, Borrower b);
}</programlisting>

          <para>Note that an action annotated as being
          <classname>@NotInServiceMenu</classname> will still be contributed.
          If an action should neither be contributed nor appear in service
          menu items, then simply annotate it as
          <classname>@Hidden</classname>.</para>
        </sect2>

        <sect2>
          <title>(Suppressing) service menus</title>

          <para>If none of the service menu items should appear, then the
          service itself should be annotated as @Hidden.</para>

          <para>For example:</para>

          <programlisting>@Hidden
public interface EmailService {
    public void sendEmail(String to, String from, String subject, String body);
    public void forwardEmail(String to, String from, String subject, String body);
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to use a generic repository</title>

        <para>To speed up initial prototype the framework allows so-called
        generic repositories to be defined, one per entity. Such a repository
        will, for its specified type, provide methods to:</para>

        <itemizedlist>
          <listitem>
            <para>Create a new transient instance</para>
          </listitem>

          <listitem>
            <para>Create a new persisted instance</para>
          </listitem>

          <listitem>
            <para>Find all persisted instances</para>
          </listitem>

          <listitem>
            <para>Find instances with a specified title</para>
          </listitem>
        </itemizedlist>

        <para>To register such a service prefix the class name with the prefix
        <literal>repository#</literal>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">isis.services = repository#dom.Booking</programlisting>

        <para>Over time, you should expect most if not all of these generic
        repositories will be replaced with regular repository types (see <xref
        linkend="sec.CustomRepository" />).</para>
      </sect1>

      <sect1 id="sec.CustomRepository">
        <title>How to write a custom repository</title>

        <para>Repositories are defined as interfaces within the domain, and
        their implementation will vary by object store. During prototyping and
        for much of development, you will probably find it easiest to use an
        in-memory object store or perhaps the <acronym>XML</acronym> object
        store, with only a small number of instances. The
        <classname>DomainObjectContainer</classname> provides a set of methods
        that make it easy to pull back all instances from the object store
        which can then be filtered as required. Later on, you can replace the
        implementation depending upon the specifics of the object store that
        you'll be using for production.</para>

        <para>If you inherit from the <literal
        moreinfo="none">org.apache.isis.applib.AbstractFactoryAndRepository</literal>
        adapter class then this will automatically have the
        <classname>DomainObjectContainer</classname> injected, and provides
        convenience methods that delegate to the container. Using this is not
        mandatory, however.</para>

        <para>The methods provided by the
        <classname>DomainObjectContainer</classname> to support repositories
        are:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>allInstances(Class&lt;T&gt;
            ofType)</methodname></para>

            <para>Returns all instances of the specified type. Note that this
            includes all instances of any subtypes.</para>
          </listitem>

          <listitem>
            <para><methodname>allMatches(...)</methodname></para>

            <para>Returns all instances matching the provided
            arguments.</para>
          </listitem>

          <listitem>
            <para><methodname>firstMatch(...)</methodname></para>

            <para>Returns the first instance matching the provided
            arguments.</para>
          </listitem>

          <listitem>
            <para><methodname>uniqueMatch(...)</methodname></para>

            <para>Returns the one-and-only instance matching the provided
            arguments (else is an exception).</para>
          </listitem>
        </itemizedlist>

        <para>The last three methods, <methodname>*Match(...)</methodname> are
        all overloaded in order to return a subset of object instances. Some
        of these are "naive"; all instances are returned from the object
        store, and the filtering is performed within the repository. Others
        are designed to pass the query predicate back to the object store so
        that only the matching rows are returned.</para>

        <para>Each of these options are discussed in more detail below.</para>

        <sect2>
          <title>Finding by Title</title>

          <para>The first version of finding instances is to specify the
          required title for the matching objects:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Class&lt;T&gt; ofType, String
              title)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Class&lt;T&gt; ofType, String
              title)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Class&lt;T&gt; ofType, String
              title)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>Although easy and intuitive, this isn't generally recommended
          for production use because (a) the matching is performed within the
          repository rather than the object store, and (b) the title string
          can often change as business requirements are refined.</para>

          <para>That said, it is possible to eliminate the first disadvantage
          by using the <classname>Query</classname> API, discussed below; this
          provides an implementation that is equivalent to find by
          title.</para>
        </sect2>

        <sect2>
          <title>Finding by Pattern</title>

          <para>The next technique of finding instances is to specify pattern
          object to match against (sometimes called "query-by-example", or
          <acronym>QBE</acronym>):</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Class&lt;T&gt; ofType, Object
              pattern)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Class&lt;T&gt; ofType, Object
              pattern)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Class&lt;T&gt; ofType, Object
              pattern)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>Any non-null value of the pattern object is used as the
          predicate.</para>

          <para>Although more robust that searching by title, this technique
          is also not likely to be valid for production code because the
          matching is still performed within the repository rather than within
          the object store.</para>

          <para>That said, it is possible to eliminate the first disadvantage
          by using the <classname>Query</classname> API, discussed below; this
          provides an implementation that is equivalent to find by
          pattern.</para>

          <note>
            <para>If the pattern object is created using
            <methodname>newTransientInstance(...)</methodname>, then any
            default values for properties will automatically be set (see <xref
            linkend="sec.DefaultPropertyValue" />). If this isn't required,
            they will need to be manually cleared.</para>
          </note>
        </sect2>

        <sect2>
          <title>Finding using the <classname>Filter</classname> API</title>

          <para>The third overloaded version of the matching methods to find
          instances all take an
          <classname>org.apache.isis.applib.Filter&lt;T&gt;</classname>
          instance:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Class&lt;T&gt; ofType,
              Filter&lt;T&gt; filter)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Class&lt;T&gt; ofType,
              Filter&lt;T&gt; filter)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Class&lt;T&gt; ofType,
              Filter&lt;T&gt; filter)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>The <classname>Filter&lt;T&gt;</classname> interface is very
          straightforward:</para>

          <programlisting>public interface Filter&lt;T&gt; {
    public boolean accept(T obj);
}</programlisting>

          <para>Every object of the given type (and subclasses) is passed into
          the <classname>Filter</classname> instance; only those
          <methodname>accept()</methodname>'ed are returned from the
          <methodname>*Match()</methodname> method.</para>

          <para>Although flexible, with this technique the matching is also
          performed within the repository rather than the object store, and so
          is also likely not to be suitable for production use where there are
          many instances of the given type.</para>
        </sect2>

        <sect2>
          <title>Finding using the <classname>Query</classname> API</title>

          <para>The finaly overloaded version of the matching methods take an
          instance of
          <classname>org.apache.isis.applib.query.Query&lt;T&gt;</classname>
          interface:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Query&lt;T&gt;
              query)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Query&lt;T&gt;
              query)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Query&lt;T&gt;
              query)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>Unlike all the other matching mechanisms, the point of the
          <classname>Query</classname> interface is for it to be passed back
          to the object store and evaluated there.</para>

          <para>The applib provides several implementations that implement the
          <classname>Query&lt;T&gt;</classname> interface. Probably the most
          important of these is <classname>QueryDefault&lt;T&gt;</classname>,
          which provides a set of factory methods for constructing
          <classname>Query</classname> instances that represent a named query
          with a map of parameter/argument pairs.</para>

          <para>For example:</para>

          <programlisting>public class CustomerRepositoryImpl implements CustomerRepository {
    public List&lt;Customer&gt; findCustomers(
            @Named("Last Name") String lastName,
            @Named("Postcode")  String postCode
        ) {
        QueryDefault&lt;Customer&gt; query = 
            QueryDefault.create(
                Customer.class, 
                "findCustomers", 
                "lastName", lastName, 
                "postCode", postCode);

        return getContainer().allMatches(query);
    }
    ...
}</programlisting>

          <para>Above it was noted that the other overloaded versions of the
          matching <acronym>API</acronym> have the disadvantage that the
          matching is performed within the repository. As an alternative to
          using "find by title" or "find by pattern", you may wish to use
          QueryFindByTitle and QueryFind</para>

          <itemizedlist>
            <listitem>
              <para><classname>QueryFindByTitle&lt;T&gt;</classname>, which
              corresponds to the <methodname>allMatches(...)</methodname> for
              searching by title</para>
            </listitem>

            <listitem>
              <para><classname>QueryFindByPattern&lt;T&gt;</classname>, which
              corresponds to the <methodname>allMatches(...)</methodname> for
              searching by pattern</para>
            </listitem>
          </itemizedlist>

          <para>There is also a
          <classname>QueryFindAllInstances&lt;T&gt;</classname>, which
          corresponds to the <methodname>allInstances()</methodname>
          method.</para>

          <para>The interpretation of a <classname>Query</classname> instance
          ultimately depends on the object store. All object stores will
          support <classname>QueryFindAllInstances</classname>, and most will
          provide a mechanism to support <classname>QueryDefault</classname>.
          Check the object store documentation to determine whether they
          support other <classname>Query</classname> implementations (ie,
          <classname>QueryFindByTitle</classname> and
          <classname>QueryFindByPattern</classname>).</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Factories</title>

        <para>Like repositories, factories are defined by interface in the
        domain, decoupling the domain objects from their actual
        implementation. Unlike repositories, there is no particular need to
        change the implementation when moving from one object store to
        another, because in all cases the factory can simply delegate to its
        injected <classname>DomainObjectContainer</classname>.</para>

        <para>The methods for <classname>DomainObjectContainer</classname>
        that are relevant for a factory are:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>&lt;T&gt; T newTransientInstance(final
            Class&lt;T&gt; ofClass)</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>&lt;T&gt; T newPersistentInstance(final
            Class&lt;T&gt; ofClass)</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>persist(Object)</methodname></para>
          </listitem>
        </itemizedlist>

        <para>These are discussed in more detail in <xref
        linkend="sec.HowToCreateAnObject" />. See also <xref
        linkend="apx.DomainObjectContainer" /> for full coverage of the
        methods available in
        <classname>DomainObjectContainer</classname>.</para>
      </sect1>
    </chapter>

    <chapter id="chp.ValueTypes">
      <title>Value Types</title>

      <abstract>
        <para>Built-in value types, writing your own value types, and
        supporting third-party value types.</para>
      </abstract>

      <para>The state of any given entity is characterized by properties
      (<xref linkend="chp.Properties" />) and collections (<xref
      linkend="chp.Collections" />). A collections is a one-to-many reference
      to another entities, while a property is either a one-to-one reference
      to another entity, or it is a value.</para>

      <para>But what's a value? Well, it's an atomic piece of state. A string
      is a value, so is a number, so is a date. Values should be designed to
      be immutable (though some system value types, such as
      <classname>java.util.Date</classname>, famously are not).</para>

      <para><emphasis>Isis</emphasis> supports all the standard JDK value
      types, and defines a number of its own (eg
      <classname>Percentage</classname> and <classname>Color</classname>). It
      also allows you to define your own value types, such as
      <classname>LastName</classname>, or <classname>Celsius</classname>, or
      <classname>ComplexNumber</classname>.</para>

      <para>Finally, it's also possible to make Isis integrate with
      third-party value types, such as <ulink
      url="http://joda-time.sourceforge.net/">JodaTime</ulink>.</para>

      <para><note>
          <para><emphasis>Isis</emphasis>' support for a particular value type
          does not necessarily imply that there is a custom widget for that
          type in a particular viewer. Rather, it means that the state of the
          object can be serialized, is expected to have equal-by-content
          semantics, and is expected to be immutable. It may also be parseable
          from a string.</para>
        </note></para>

      <sect1>
        <title>Built-in Value Types</title>

        <para>The following are the value types supported by
        <emphasis>Isis</emphasis> out-of-the-box.</para>

        <sect2>
          <title>JDK Types</title>

          <para>The following <acronym>JDK</acronym> types are supported by
          <emphasis>Isis</emphasis>.</para>

          <sect3>
            <title>Primitive Types</title>

            <para>All the primitive types may be used as values:
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname>,
            <classname>float</classname>, <classname>double</classname>,
            <classname>char</classname>, and
            <classname>boolean</classname>.</para>
          </sect3>

          <sect3>
            <title>Wrapper Types</title>

            <para>The wrapper types for each of the primitives can also be
            used as value types: <classname>java.lang.Byte</classname>,
            <classname>java.lang.Short</classname>,
            <classname>java.lang.Integer</classname>,
            <classname>java.lang.Long</classname>,
            <classname>java.lang.Float</classname>,
            <classname>java.lang.Double</classname>,
            <classname>java.lang.Character</classname>,
            <classname>java.lang.Boolean</classname>.</para>
          </sect3>

          <sect3>
            <title>Java Classes</title>

            <para>The following java classes have value semantics and may be
            used as value types:</para>

            <itemizedlist>
              <listitem>
                <para><classname>java.lang.String</classname></para>
              </listitem>

              <listitem>
                <para><classname>java.math.BigInteger</classname> and
                <classname>java.math.BigDecimal</classname></para>
              </listitem>

              <listitem>
                <para><classname>java.util.Date</classname> (date and time),
                <classname>java.sql.Date</classname> (date only), and
                <classname>java.sql.Time</classname> (time only)</para>
              </listitem>

              <listitem>
                <para><classname>java.sql.Timestamp</classname></para>
              </listitem>

              <listitem>
                <para><classname>java.awt.Image</classname></para>
              </listitem>
            </itemizedlist>
          </sect3>

          <sect3>
            <title>Isis AppLib</title>

            <para><emphasis>Isis</emphasis> itself also provides a number of
            its own value types. These are all in the
            <classname>org.apache.applib.value</classname> package:</para>

            <itemizedlist>
              <listitem>
                <para><classname>Color</classname></para>
              </listitem>

              <listitem>
                <para><classname>Date</classname> (date only),
                <classname>DateTime</classname> (date and time) and
                <classname>Time</classname> (time only)</para>
              </listitem>

              <listitem>
                <para><classname>TimeStamp</classname></para>
              </listitem>

              <listitem>
                <para><classname>Image</classname></para>
              </listitem>

              <listitem>
                <para><classname>Money</classname></para>
              </listitem>

              <listitem>
                <para><classname>Password</classname></para>
              </listitem>

              <listitem>
                <para><classname>Percentage</classname></para>
              </listitem>
            </itemizedlist>
          </sect3>
        </sect2>

        <sect2>
          <title>Value formats</title>

          <para><emphasis>Isis</emphasis> provides default formats for the
          inbuilt value types, according to type. These can be modified using
          <filename>isis.properties</filename>.</para>

          <para>These formats cut across the above categories; for example the
          byte format relates to both <classname>byte</classname> (primitive)
          and <classname>java.lang.Byte</classname> (wrapper). In all cases
          this setting can be overriden for a specific field using the <link
          linkend="mask-annotation"> <literal moreinfo="none">@Mask</literal>
          annotation</link>.</para>

          <sect3>
            <title>Byte format</title>

            <para>The format for all bytes can be set, replacing the default
            format derived from the system, using the following property to
            specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.byte=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Date Format</title>

            <para>The format for all dates can be set, replacing the default
            format derived from the system, using the following property to
            specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.date=dd/MM/yy</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Date/time Format</title>

            <para>The format for all date/time values can be set, replacing
            the default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.datetime=dd/MM/yy</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Decimal format</title>

            <para>The format for <classname>BigDecimal</classname> values can
            be set, replacing the default format derived from the system,
            using the following property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.decimal=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Double format</title>

            <para>The format for all double values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.double=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Float format</title>

            <para>The format for all float values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.float=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Integer format</title>

            <para>The format for all integers (including
            <classname>BigInteger</classname>) can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.int=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Long format</title>

            <para>The format for all long values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.long=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Short format</title>

            <para>The format for all short values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.short=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Time Format</title>

            <para>The format for all time values can be set, replacing the
            default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.time=ddMMyyyy hhmm</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Timestamp Format</title>

            <para>The format for time stamp values can be set, replacing the
            default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.timestamp=hh:mm</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>
        </sect2>
      </sect1>

      <sect1>
        <title>Custom Value Types</title>

        <para>In addition to the built-in value types it is also possible to
        define user-defined value types. This is typically done using the
        <classname>@Value</classname> annotation.</para>

        <para>The <literal>@Value</literal> annotation is used to provide an
        implementation of the
        <classname>org.apache.isis.applib.adapters.ValueSemanticsProvider</classname>
        interface. In turn this provides objects that allow the framework to
        interact with the value, specifically:</para>

        <itemizedlist>
          <listitem>
            <para>the <classname>EncoderDecoder</classname> is used to convert
            the value into and back out of serializable form</para>

            <para>This is used by some object stores (eg the
            <acronym>XML</acronym> Object Store), for remoting and also by the
            XML Snapshot capability (see <xref
            linkend="chp.XmlSnapshots" />);</para>
          </listitem>

          <listitem>
            <para>the <classname>Parser</classname> is used to convert
            <classname>String</classname>s into the value type</para>

            <para>This is used as a fallback by viewers that do not have any
            specific widgets to support the particular value type, and make do
            with a simple text field instead.</para>

            <para>An obvious example is to parse a date. But it could be used
            to parse "TRUE" and "FALSE" into a boolean (as opposed to using a
            checkbox).</para>
          </listitem>

          <listitem>
            <para>the <classname>DefaultsProvider</classname> is used to
            provide a meaningful default for the value</para>

            <para>Not every value type will have a default, but some do (eg
            false for a boolean, 0 for a number). This is used as the default
            value for non-<classname>@Optional</classname> properties and
            parameters.</para>
          </listitem>
        </itemizedlist>

        <para>Each of these interfaces also reside in
        <classname>org.apache.isis.applib.adapters</classname>.</para>

        <para>For more details, explore the built-in types within the applib,
        for example
        <classname>org.apache.isis.applib.value.Money</classname>.</para>

        <programlisting format="linespecific">@Value(semanticsProviderName = 
         "org.apache.isis.core.progmodel.facets.value.MoneyValueSemanticsProvider")
public class Money extends Magnitude {
    ...
}</programlisting>

        <para>where <classname>MoneyValueSemanticsProvider</classname> is the
        implementation of <classname>ValueSemanticsProvider</classname>
        described above.</para>

        <para><note>
            <para>Using value types generally removes the need for using
            <literal>@MustSatisfy</literal> annotation (see <xref
            linkend="sec.MustSpecify" />); the rules can instead move down
            into a <methodname>validate()</methodname> method on the value
            type itself.</para>
          </note></para>
      </sect1>

      <sect1>
        <title>Third-party Value Types</title>

        <para>Third party value types, such as those in <ulink
        url="http://joda-time.sourceforge.net/">JodaTime</ulink>, can also
        supported, again through the use of a
        <classname>ValueSemanticsProvider</classname>. However, since the
        source code cannot be altered, the provider must be supplied using a
        key value in <methodname>isis.properties</methodname> configuration
        file.</para>

        <para>For example, the following would register a semantics provider
        for <classname>org.jodatime.time.DateTime</classname>:</para>

        <programlisting>isis.core.progmodel.value.org.jodatime.time.DateTime.semanticsProviderName=\
    com.mycompany.values.CalendarIntervalValueSemanticsProvider</programlisting>

        <note>
          <para>At the time of writing <emphasis>Apache Isis</emphasis> does
          not currently ship with any
          <classname>ValueSemanticsProvider</classname>s, though doing so is
          on the roadmap.</para>
        </note>
      </sect1>
    </chapter>
  </part>

  <part>
    <title>Supporting Features</title>

    <chapter id="chp.Clock">
      <title>Clock</title>

      <abstract>
        <para>The default Clock and alternative implementations.</para>
      </abstract>

      <para>Many if not all enterprise applications deal with dates and times
      in one way or another. For example, if an Order is placed, then the
      Customer may have 30 days to pay the Invoice, otherwise a penalty may be
      levied. However, this can complicate automated testing: "today+30" will
      be a different date every time the test is run.</para>

      <para>A common solution is to require that domain objects do not go
      directly to the system for the current date (ie don't simply instantiate
      a new <classname>java.util.Date</classname> in order to get the current
      time); instead they should call some sort of facade.</para>

      <para>The <emphasis>Apache Isis</emphasis> framework provides such a
      facade through the
      <classname>org.apache.isis.applib.clock.Clock</classname> class. The
      defaults for all values refer back to the <classname>Clock</classname>,
      and - because the <classname>Clock</classname> is a singleton - it is
      easy for any application code to obtain the current time also.</para>

      <para>For example:</para>

      <programlisting>public class Customer {
     public Order placeOrder(Product p) {
         Date now = Clock.getTimeAsDate();
         ...
     }
     ...
}</programlisting>

      <sect1>
        <title>Lazily Instantiated</title>

        <para>The first call to <methodname>Clock.getTime()</methodname> will
        lazily instantiate the singleton, with the default implementation
        being one that simply delegates to the system's internal clock. To use
        a different <classname>Clock</classname> implementation, eg one that
        delegates to an NNTP server, all that is required is to instantiate it
        any time prior to bootstrapping <emphasis>Isis</emphasis>
        itself.</para>

        <para>One notable implementation that notably takes advantage of this
        is <classname>FixtureClock</classname>, used for testing. See <xref
        linkend="chp.Fixtures" /> for more information.</para>
      </sect1>

      <sect1>
        <title>Possibly Replaceable</title>

        <para>Clock implementations can indicate whether they are replaceable
        as the singleton, or not.</para>

        <para>Most (all?) production implementations (eg the default system
        clock) are <emphasis>not</emphasis> replaceable; once instantiated,
        any attempt to instantiate another subclass will be rejected with an
        exception.</para>

        <para>However implementations to work with tests (such as
        <classname>FixtureClock</classname>, already mentioned) are more
        likely to be replaceable, so that they can be setup multiple times as
        required.</para>
      </sect1>
    </chapter>

    <chapter id="chp.UserProfiles">
      <title>Profiles</title>

      <abstract>
        <para>Support for user profiles</para>
      </abstract>

      <para>As well as allowing domain entities to be persisted into object
      stores, <emphasis>Apache Isis</emphasis> also allows user
      <emphasis>profiles</emphasis> to be persisted into a profile
      store.</para>

      <para>Every user can have one profile associated with them, a profile
      consisting of:</para>

      <itemizedlist>
        <listitem>
          <para>a set of options or preferences</para>
        </listitem>

        <listitem>
          <para>a set of perspectives</para>
        </listitem>
      </itemizedlist>

      <para>A perspective is something akin to a layout or desktop,
      representing a configuration of relevant objects as might be displayed
      on the home page of the viewer. The elements that make up a perspective
      are:</para>

      <itemizedlist>
        <listitem>
          <para>a set of services (identified by the string returned from each
          service's <methodname>getId()</methodname> method, see <xref
          linkend="chp.DomainServices" />)</para>

          <para>These are the services (eg icons) that can be accessed from
          that perspective</para>
        </listitem>

        <listitem>
          <para>a set of objects</para>

          <para>These might represent bookmarks to objects saved from a
          previous session.</para>
        </listitem>
      </itemizedlist>

      <para>The applib contains types to define these two concepts;
      specifically <classname>Profile</classname> and
      <classname>Perspective</classname>. These are actually interfaces, the
      implementation is provided by framework itself.</para>

      <para>To use profiles in an application, the system should be run using
      a persistent implementation of the <classname>profilestore</classname>
      component (the default is the in-memory profilestore that does not
      persist any information between sessions). Also, not every viewer
      understands or uses perspectives; the most notable one that does support
      the idea is the <acronym>DnD</acronym> viewer.</para>
    </chapter>

    <chapter id="chp.Fixtures">
      <title>Fixtures and SwitchUser</title>

      <abstract>
        <para>Using fixtures to setup the system, generally for testing
        purposes.</para>
      </abstract>

      <para>Fixtures are used to setup the framework into a known state. This
      is predominantly done for testing, and in particular when running with
      the in-memory object store. However, fixtures can also be used to
      specify the user that has "logged on", and to set the clock.</para>

      <para>Whether a fixture has any effect will depend on several
      factors:</para>

      <itemizedlist>
        <listitem>
          <para>the first is the <classname>DeploymentType</classname>;
          specifying the logged on user will only be honoured if running in
          exploration mode (or more precisely, where
          <methodname>DeploymentType#isExploring()</methodname> returns
          true);</para>
        </listitem>

        <listitem>
          <para>the second is the object store; most persistent object stores
          will either ignore fixtures, or only allow them to be installed once
          or if run with an (object store-specific) flag set</para>
        </listitem>
      </itemizedlist>

      <sect1 id="sec.HowToRegisterFixtures">
        <title>How to register fixtures</title>

        <para>All domain services (which includes repositories and factories)
        should be registered in the <emphasis>isis.properties</emphasis>
        configuration file, under the <varname>isis.fixtures.prefix</varname>
        and <varname>isis.fixtures</varname> keys.</para>

        <para>For example:</para>

        <programlisting>isis.fixtures.prefix= org.apache.isis.support.prototype.fixture
isis.fixtures= ClaimsFixture,LogOnAsCliveFixture</programlisting>

        <para>It is also possible to specify fixtures from the command line,
        using the --fixture flag.</para>
      </sect1>

      <sect1>
        <title>How to write custom fixtures</title>

        <para>The applib defines several interfaces and classes for writing
        fixtures. The following UML diagram shows their relationships:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Fixtures.png" scale="50" />
          </imageobject>
        </mediaobject>

        <sect2>
          <title><classname>InstallableFixture</classname> and
          <classname>FixtureType</classname></title>

          <para>The <classname>InstallableFixture</classname> interface
          defines the general contract between a fixture and the framework:
          the <classname>FixtureType</classname>, and an
          <methodname>install()</methodname> method.</para>

          <para>The <classname>FixtureType</classname> is used to characterize
          whether the fixture:</para>

          <itemizedlist>
            <listitem>
              <para>if <classname>FixtureType.DOMAIN_OBJECTS</classname> (the
              default), then the fixture will be installed only so long as the
              configured object store does not indicate that fixtures have
              already been installed</para>
            </listitem>

            <listitem>
              <para>if <classname>FixtureType.USER_PROFILES</classname>, then
              the fixture will be installed only so long as the configured
              profile store does not indicate that fixtures have already been
              installed</para>
            </listitem>

            <listitem>
              <para>if <classname>FixtureType.OTHER</classname>, then the
              fixture will always be installed. This usually refers to setting
              the clock or user.</para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title><classname>BaseFixture</classname> and
          <classname>AbstractFixture</classname></title>

          <para>The <classname>BaseFixture</classname> class is not API, but
          is responsible for instantiating
          <classname>FixtureClock</classname>. This is an implementation of
          <classname>Clock</classname> singleton, which (as described in <xref
          linkend="chp.Clock" />), is used by the rest of the
          <emphasis>Isis</emphasis> framework delegates to in order to obtain
          the current time. The <classname>FixtureClock</classname>'s purpose
          is to allow the current date/time to be set by other
          fixtures.</para>

          <para>The <classname>AbstractFixture</classname> class (inheriting
          from <classname>BaseFixture</classname>) is an general-purpose
          adapter for writing fixtures. It implements
          <classname>CompositeFixture</classname> interface, meaning that
          hierarchies of fixtures can be created following the composite
          design pattern. It also provides a number of convenience
          methods:</para>

          <itemizedlist>
            <listitem>
              <para>the <methodname>setDate(...)</methodname> and
              <methodname>setTime(...)</methodname> method allow the date/time
              to be set.</para>

              <para>This is done using by obtaining the
              <classname>FixtureClock</classname> (from
              <classname>BaseFixture</classname>). There are also some
              convenience methods to move the date/time either earlier or
              later.</para>
            </listitem>

            <listitem>
              <para>the <methodname>switchUser(...)</methodname> method allow
              the logged-on user to be changed</para>

              <para>This changes the user logged-on while the fixtures are
              being installed. This is to facilitate tests that have complex
              setup requirements, eg verifying workflow between different user
              roles.</para>
            </listitem>
          </itemizedlist>

          <para>An alternative to using
          <methodname>setDate(...)</methodname>/<methodname>setTime(...)</methodname>
          is to use <classname>DateFixture</classname>, and an alternative to
          using <methodname>switchUser(...)</methodname> is to use
          <classname>SwitchUserFixture</classname>. Which you use is largely a
          matter of personal preference.</para>
        </sect2>

        <sect2>
          <title><methodname>DateFixture</methodname></title>

          <para>The <classname>DateFixture</classname> provides an alternative
          to <classname>AbstractFixture</classname>, just allowing the current
          date/time to be set.</para>

          <para>The main difference is one of style;
          <classname>DateFixture</classname> can be used in a declarative way,
          whereas <classname>AbstractFixture</classname> is more imperative.
          For example:</para>

          <programlisting>public class DateIs13Jan2007Fixture extends DateFixture {
    public DateIs13Jan2007Fixture() {
        super(2007,1,13);
    }
}</programlisting>

          <para>A fixture in this style could then be used within a composite
          fixture hierarchy.</para>
        </sect2>

        <sect2>
          <title><methodname>SwitchUserFixture</methodname></title>

          <para>The SwitchUserFixture provides an alternative to
          <classname>AbstractFixture</classname>, just allowing the current
          user to be switched.</para>

          <para>The main difference is one of style;
          <classname>SwitchUserFixture</classname> can be used in a
          declarative way, whereas <classname>AbstractFixture</classname> is
          more imperative. For example:</para>

          <programlisting>public class SwitchToFrankSupervisorFixture extends SwitchUserFixture {
    public SwitchToFrankSupervisorFixture() {
        super("frank", "user", "supervisor");
    }
}</programlisting>

          <para>A fixture in this style could then be used within a composite
          fixture hierarchy.</para>
        </sect2>

        <sect2>
          <title><classname>LogonFixture</classname></title>

          <para>Unlike the very similar
          <classname>SwitchUserFixture</classname>, this fixture does not
          affect the currently logged on user while the fixtures are being
          installed. Instead, it is used to specify the user to logon as once
          all the fixtures have been installed.</para>

          <para>If more than one <classname>LogonFixture</classname> is
          specified, the last one encountered is used.</para>
        </sect2>

        <sect2>
          <title><classname>UserProfileFixture</classname></title>

          <para>The <classname>UserProfileFixture</classname> is used to
          populate the configured profile store. See <xref
          linkend="chp.UserProfiles" /> for more details on profiles and
          perspectives.</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="chp.XmlSnapshots">
      <title>XML Snapshots</title>

      <abstract>
        <para>Generating <acronym>XML</acronym> snapshots from domain
        objects.</para>
      </abstract>

      <para>The <emphasis>Apache Isis</emphasis> framework provides the
      capability to generate <acronym>XML</acronym> snapshots (and if required
      corresponding <acronym>XSD</acronym> schemas) based on graphs of domain
      objects. This is done using the
      <classname>org.apache.isis.core.runtime.snapshot.XmlSnapshot</classname>
      class.</para>

      <sect1>
        <title>Generating an XML Snapshot</title>

        <para>The <classname>XmlSnapshot</classname> can be created either
        directly or using a builder.</para>

        <sect2>
          <title>Standard Usage</title>

          <para>The standard usage is to instantiate directly.</para>

          <programlisting>XmlSnapshot snapshot = new XmlSnapshot(customer);
Element customerAsXml = snapshot.getXmlElement();</programlisting>

          <para></para>

          <para>returns customer's fields, titles of simple references, number
          of items in collections</para>

          <para></para>

          <para>In order to use the <classname>XmlSnapshot</classname>, the
          domain object must implement
          <classname>org.apache.isis.applib.snapshot.Snapshottable</classname>.
          This is just a marker interface.</para>

          <para>Notes:</para>

          <orderedlist>
            <listitem>
              <para>navigates to another domain object represented by simple
              reference &amp;quot;placeOfBirth&amp;quot;</para>
            </listitem>

            <listitem>
              <para>navigates to all <classname>Order</classname>s of
              <classname>Customer</classname>, and from them for their
              <classname>Product</classname>s</para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>
          </orderedlist>
        </sect2>

        <sect2>
          <title>Including</title>

          <para></para>

          <para>Note that XmlSnapshot is mutable; it's possible</para>

          <programlisting>XmlSnapshot snapshot = new XmlSnapshot(customer);
snapshot.include("placeOfBirth"); // (1)
snapshot.include("orders/product"); // (2)
Element customerAsXml = snapshot.getXmlElement(); // (3)</programlisting>

          <para></para>
        </sect2>

        <sect2>
          <title>Fluent Usage</title>

          <para>There is also an alternative "fluent" use:</para>

          <programlisting>XmlSnapshot snapshot = 
     XmlSnapshot.create(customer)
                .includePath("placeOfBirth")
                .include("orders/product")
                .build();
Element customerAsXml = snapshot.getXmlElement();</programlisting>

          <para>Alternatively, the domain object can also implement</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Fluent Usage</title>

        <para>There is also an alternative "fluent" use:</para>

        <programlisting>XmlSnapshot snapshot = 
     XmlSnapshot.create(customer)
                .includePath("placeOfBirth")
                .include("orders/product")
                .build();
Element customerAsXml = snapshot.getXmlElement();</programlisting>

        <para>In order to use the <classname>XmlSnapshot</classname>, the
        domain object must implement
        <classname>org.apache.isis.applib.snapshot.Snapshottable</classname>.
        This is just a marker interface.</para>

        <para>Alternatively, the domain object can also implement</para>

        <para></para>

        <para></para>
      </sect1>
    </chapter>
  </part>

  <part>
    <title>Reference Appendices</title>

    <appendix>
      <title>Recognized Methods and Prefixes</title>

      <abstract>
        <para>Methods and method prefixes recognized by <emphasis>Apache
        Isis</emphasis> using the default programming model.</para>
      </abstract>

      <para>The following table lists all of the methods or method prefixes
      that are recognized by <emphasis>Apache Isis</emphasis>' default
      programming model:</para>

      <table>
        <title>Recognized Method Prefixes</title>

        <tgroup cols="6">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">Prefix</entry>

              <entry align="center">object</entry>

              <entry align="center">property</entry>

              <entry align="center">collection</entry>

              <entry align="center">action</entry>

              <entry align="center">action param</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>addTo</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y (see also removeFrom)</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>choices</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y</entry>
            </row>

            <row>
              <entry>clear</entry>

              <entry></entry>

              <entry>Y (see also modify)</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>created</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>default</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y</entry>
            </row>

            <row>
              <entry>disable</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>
            </row>

            <row>
              <entry>get</entry>

              <entry></entry>

              <entry>Y (see also set)</entry>

              <entry>Y (see also set)</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>getId</entry>

              <entry>Y (service only)</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>hide</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>
            </row>

            <row>
              <entry>iconName</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>loaded</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>loading</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>modify</entry>

              <entry></entry>

              <entry>Y (see also clear)</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>persisted</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>persisting</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>removing</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>removed</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>removeFrom</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y (see also addTo)</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>set</entry>

              <entry></entry>

              <entry>Y (see also get)</entry>

              <entry>Y (see also get)</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>toString</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>title</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>updating</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>updated</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>validate</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry>Y</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>There are also a number of deprecated methods:</para>

      <table>
        <title>Deprecated Method Prefixes</title>

        <tgroup cols="6">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">Prefix</entry>

              <entry align="center">object</entry>

              <entry align="center">property</entry>

              <entry align="center">collection</entry>

              <entry align="center">action</entry>

              <entry align="center">action param</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>deleted</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>deleting</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>saved</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>saving</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In order to be recognized, all methods must be
      <code>public</code>. Any methods that do not match are deemed to be
      action methods that the user can invoke from the user interface.</para>
    </appendix>

    <appendix>
      <title>Recognized Annotations</title>

      <abstract>
        <para>All the annotations recognized in the <emphasis>Apache
        Isis</emphasis> default programming model.</para>
      </abstract>

      <para>This chapter defines the set of annotations that are recognised by
      the <emphasis>Apache Isis</emphasis> default programming model.</para>

      <sect1>
        <title>@ActionOrder</title>

        <para><emphasis>Note: The recommended mechanism for specifying the
        order in which actions are listed to the user is
        <code>@MemberOrder</code> (see <xref
        linkend="sec.MemberOrderAnnotation" />).</emphasis></para>

        <para><code>@ActionOrder</code> provides a mechanism to specify the
        order in which actions appear in the user interface, in which the
        order is specified in one place in the class.</para>

        <para>The syntax is:</para>

        <programlisting><literal moreinfo="none">@ActionOrder("&lt;comma separated list of action names&gt;")</literal> </programlisting>

        <para>The action names are not case sensitive.</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("PlaceNewOrder, CheckCredit")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

...
}</programlisting>

        <para>Compared to <classname>@MemberOrder</classname>, there is
        (currentlyon) one additional advantage in that you can easily specify
        groupings (which may be rendered by the viewer as sub-menus). This
        information may be used by the viewing mechanism to render actions
        into sub-menus.</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("(Account Management: PlaceOrder, CheckCredit), (Personal Details: ChangeOfAddress, AddEmail)")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

    public void changeOfAddress() {}

    public void addEmail(String emailAddress) {}

    ...
}</programlisting>

        <para>However, <code>@ActionOrder</code> is more 'brittle' to change:
        if you change the name of an existing action you will need to ensure
        that the corresponding name within the <code>@ActionOrder</code>
        annotation is also changed.</para>
      </sect1>

      <sect1>
        <title>@Aggregated</title>

        <para>***</para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>@Bounded</title>

        <para>For immutable objects where there is a bounded set of instances,
        the <literal moreinfo="none">@Bounded</literal> annotation can be
        used.</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Bounded</emphasis>
public class County {
    // members and actions here
}</programlisting>

        <para>The number of instances is expected to be small enough that all
        instance can be held in memory. The viewer will use this information
        to render all the instances of this class in a drop-down list or
        equivalent.</para>

        <note>
          <para>Although this is not enforced, <literal
          moreinfo="none">@Bounded</literal> is intended for use on <literal
          moreinfo="none">final</literal> classes. Its behaviour when used on
          interfaces, or classes with sub-classes is not specified</para>
        </note>
      </sect1>

      <sect1>
        <title>@Debug</title>

        <para>The <classname>@Debug </classname>annotation marks an action
        method as available in debug mode only, and so will not normally be
        displayed by the user interface.</para>

        <para>The exact means to access <classname>@Debug</classname> actions
        depends on the viewer.</para>
      </sect1>

      <sect1>
        <title>@Defaulted</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@DescribedAs</title>

        <para>The <literal moreinfo="none">@DescribedAs</literal> annotation
        is used to provide a short description of something that features on
        the user interface. How this description is used will depend upon the
        viewing mechanism - but it may be thought of as being like a 'tool
        tip'.</para>

        <para>Descriptions may be provided for objects, members (properties,
        collections and actions), and for individual parameters within an
        action method. <literal moreinfo="none">@DescribedAs</literal>
        therefore works in a very similar manner to <literal
        moreinfo="none">@Named</literal> (see <xref
        linkend="sec.NamedAnnotation" />).</para>

        <sect2>
          <title>Providing a description for an object</title>

          <para>To provide a description for an object, use the <literal
          moreinfo="none">@DescribedAs</literal> annotation immediately before
          the declaration of that object class.</para>

          <para>For example:</para>

          <programlisting format="linespecific"><emphasis role="strong">@DescribedAs("A Customer who may have originally become known to us via " +
             "the marketing system or who may have contacted us directly.")</emphasis>
public class ProspectiveSale {
   ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Providing a description for an object member</title>

          <para>Any member (property, collection or action) may provide a
          description. To specify this description, use the <literal
          moreinfo="none">@DescribedAs</literal> annotation immediately before
          the declaration of that member.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@DescribedAs("The name that the customer has indicated that they wish to be " +
                 "addressed as (e.g. Johnny rather than Jonathan)")</emphasis>
    public String getFirstName() { ... }
}</programlisting>
        </sect2>

        <sect2>
          <title>Providing a description for an action parameter</title>

          <para>To provide a description for an individual action parameter,
          use the <literal moreinfo="none">@DescribedAs</literal> annotation
          in-line i.e. immediately before the parameter declaration.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity")
                      <emphasis role="strong">@DescribedAs("The quantity of the product being ordered")</emphasis>
                      int quantity) {

        Order order = new Order();
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>@Disabled</title>

        <para>The <literal moreinfo="none">@Disabled</literal> annotation
        means that the member cannot be used in any instance of the class.
        When applied to the property it means that the user may not modify the
        value of that property (though it may still be modified
        programmatically). When applied to an action method, it means that the
        user cannot invoke that method.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>
    public void assessCreditWorthiness() { ... }

    <emphasis role="strong">@Disabled</emphasis>
    public int getInitialCreditRating(){ ... }
    public void setInitialCreditRating(int initialCreditRating) { ... }
}</programlisting>

        <para>Note that if an action is marked as <literal
        moreinfo="none">@Disabled</literal>, it will be shown on the user
        interface but cannot ever be invoked. The only possible reason we can
        think to do this is during prototyping, to indicate an action that is
        still to be developed. If a method is intended for programmatic use,
        but not intended ever to be invoked directly by a user, then it should
        be marked as <literal moreinfo="none">@Hidden</literal>
        instead.</para>

        <para>This annotation can also take a single parameter indicating when
        it is to be hidden, for example the following code would disable the
        action until the object has been saved.</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>(When.UNTIL_PERSISTED)
    public void assessCreditWorthiness() { ... }
}</programlisting>

        <para>The acceptable values for the parameter are:
        <code>When.ALWAYS</code>, <code>When.NEVER</code>,
        <code>When.ONCE_PERSISTED</code> and
        <code>When.UNTIL_PERSISTED</code>. By default the annotated property
        or action is always disabled i.e. it is implicitly
        <code>When.ALWAYS.</code></para>
      </sect1>

      <sect1>
        <title>@Encodable</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@EqualByContent</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@Executed</title>

        <para>The <classname>@Executed</classname> annotation overrides the
        default location where a method is executed.</para>

        <bridgehead>Forcing a method to be executed on the client</bridgehead>

        <para>The <classname>@Executed(Where.LOCALLY)</classname> annotation
        marks an action method so that it executes on the client, rather than
        being forwarded to the server for execution. This is useful for
        methods that invoke a service that must be run client-side, for
        example spawning off a separate process (such as a web browser or
        Acrobat Reader).</para>

        <bridgehead>Forcing a method to be executed on the server</bridgehead>

        <para>The <classname>@Executed(Where.REMOTELY)</classname> annotation
        marks an action method so that it executes on the server, even though
        it would normally be executed on the client (as methods for transient
        objects are). This is useful for methods that although based on
        transient objects need access to persistent objects.</para>
      </sect1>

      <sect1>
        <title>@Exploration</title>

        <para>The <classname>@Exploration</classname> annotation marks an
        action method as available in exploration mode only, and therefore not
        intended for use in the production system</para>
      </sect1>

      <sect1>
        <title>@Facets</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@FieldOrder</title>

        <para>Note: The recommended mechanism for specifying the order in
        which fields are listed to the user is <code>@MemberOrder</code> (see
        below). <code>@FieldOrder</code> provides an alternative mechanism, in
        which the order is specified in one place in the class. However,
        <code>@FieldOrder</code> is more 'brittle' to change: if you change
        the name of an existing property you will need to ensure that the
        corresponding name within the <code>@FieldOrder</code> annotation is
        also changed.</para>

        <para>The syntax is: <literal moreinfo="none">@FieldOrder("&lt;comma
        separated list of field names&gt;") </literal>(the field names are not
        case sensitive.).</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@FieldOrder("Name, Address, DateOfBirth, RecentOrders")</emphasis>
public class Customer {

    public Date getDateOfBirth() {...}

    public List&lt;Order&gt; getRecentOrders() {...}

    public String getAddress() {...}

    public String getName() {...}

    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@Hidden</title>

        <para>The <literal moreinfo="none">@Hidden</literal> annotation
        indicates that the member (property, collection or action) to which it
        is applied should never be visible to the user. For example:</para>

        <programlisting format="linespecific">public class Customer {
    private int internalId;

    <emphasis role="strong">@Hidden</emphasis>
    public int getInternalId() {
        return internalId;
    }

    <emphasis role="strong">@Hidden</emphasis>
    public void updateStatus() { ... }
}</programlisting>

        <para>This annotation can also take a single parameter indicating when
        it is to be hidden, for example the following code would show the Id
        until the object has been saved, and then would hide it.</para>

        <programlisting format="linespecific">public class Customer {
    private int internalId;

    <emphasis role="strong">@Hidden</emphasis>(When.ONCE_PERSISTED)
    public int getInternalId() {
        return internalId;
    }
}</programlisting>

        <para>The acceptable values for the parameter are:
        <code>When.ALWAYS</code>, <code>When.NEVER</code>,
        <code>When.ONCE_PERSISTED</code> and
        <code>When.UNTIL_PERSISTED</code>. By default the annotated property
        or action is always hidden i.e. it is implicitly
        <code>When.ALWAYS.</code></para>
      </sect1>

      <sect1>
        <title>@Ignore</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@Immutable</title>

        <para>The <literal moreinfo="none">@Immutable</literal> annotation may
        be applied to a class. The framework does not allow the state of such
        objects to be changed through the UI, and it should be considered a
        programmer error to do so programmatically. The ObjectStorePersistor,
        as used to run the in-memory and Hibernate object stores will actually
        fail if the programmer tries to change an object in a way that cause
        the persistor to try and save it. For example the following class
        would prevent the user from changing the object even when
        transient:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Immutable</emphasis>
public class Country {
    ...
}</programlisting>

        <para>This annotation can also take a single parameter indicating when
        it is to become immutable, for example the following code would allow
        the user to create an email object and set it up, and then prevent any
        changes once it has been saved.</para>

        <programlisting format="linespecific"><emphasis role="strong">@Immutable</emphasis>(When.ONCE_PERSISTED)
public class Email {
    ...
}</programlisting>

        <para>The acceptable values for the parameter are:
        <code>When.ALWAYS</code>, <code>When.NEVER</code>,
        <code>When.ONCE_PERSISTED</code> and
        <code>When.UNTIL_PERSISTED</code>. By default the annotated property
        or action is always immutable i.e. it is implicitly
        <code>When.ALWAYS.</code></para>
      </sect1>

      <sect1>
        <title id="mask-annotation">@Mask</title>

        <para>The <literal moreinfo="none">@Mask </literal>annotation may be
        applied to any property, or to any parameter within an action method,
        that allows the user to type in text as input. The mask serves to
        validate, and potentially to normalise, the format of the input. The
        characters that can be used are based on Swing's MaskFormatter, and
        also Java's SimpleDateFormat. When applying a mask to a value
        property, the annotation should be applied to the 'getter'. For
        example:</para>

        <programlisting format="linespecific">public class Email {
    private String telNo;

    <emphasis role="strong">@Mask("(NNN)NNN-NNNN")</emphasis>
    public String getTelephoneNumber() {...}

    public void setTelephoneNumber(String telNo) {...}
    ...
}</programlisting>

        <para>When applying a mask to a value parameter within an action
        method, the annotation should be applied 'in-line' before that
        parameter). For example:</para>

        <programlisting format="linespecific">public void newContact(
     @Named("Contact Name")
     String contactName,
     @Named("Telephone Number")
     <emphasis role="strong">@Mask("(NNN)NNN-NNNN")</emphasis>
     String telNo) {}</programlisting>
      </sect1>

      <sect1>
        <title>@MaxLength</title>

        <para>The <literal moreinfo="none">@MaxLength</literal> annotation
        indicates the maximum number of characters that the user may enter
        into a <literal moreinfo="none">String</literal> property, or a
        <literal moreinfo="none">String</literal> parameter in an action. (It
        is ignored if applied to a property or parameter of any other type.)
        For example:</para>

        <programlisting format="linespecific">public class Customer {

    <emphasis role="strong">@MaxLength(30)</emphasis>
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
    ...
}</programlisting>

        <para>If the model is being persisted on a relational database then
        <literal moreinfo="none">@MaxLength</literal> should be specified for
        all <literal moreinfo="none">String</literal> properties and action
        parameters.</para>
      </sect1>

      <sect1 id="sec.MemberOrderAnnotation">
        <title>@MemberOrder</title>

        <para><code>@MemberOrder</code> is the recommended mechanism for
        specifying the order in which fields and/or actions are presented to
        the user. (<code>@ActionOrder</code> and <code>@FieldOrder</code>
        provide alternative mechanisms).</para>

        <para><code>@MemberOrder</code> is specified at the individual member
        level, on a 'relative' basis. The syntax is:</para>

        <programlisting>@MemberOrder(sequence = "&lt;relative order&gt;")</programlisting>

        <para>where <code>&lt;relative order&gt;</code> may be any string. The
        actual sequence is determined by comparing all the values of the
        sequence specifier string, using the standard <code>String</code>
        comparator.</para>

        <para>The simplest convention is to use numbers - 1, 2, 3 - though it
        is a better idea to leave gaps in the numbers - 10, 20, 30 perhaps -
        such that a new member may be added without having to edit existing
        numbers. A useful alternative is to adopt the 'dot-decimal' notation -
        1, 1.1, 1.2, 2, 3, 5.1.1, 5.2.2, 5.2, 5.3 - which allows for an
        indefinite amount of future insertion. For example:</para>

        <programlisting>Public Class Customer {
    @MemberOrder(sequence="2.1")
    Public String getAddress() {...}
    Public void setAddress(value as String) {...}

    @MemberOrder(sequence="1.1")
    Public String getFirstName() {...}
    Public void setFirstName(value as String) {...}

    @MemberOrder(sequence="1.2")
    Public String getLastName() {...}
    Public void setLastName(value as String) {...}

    @MemberOrder(sequence="3")
    Public Date getDateOfBirth() {...}
    Public void setDateOfBirth(value as Date) {...}
    ...
}   </programlisting>

        <para>If a member does not have a specified order then it will be
        placed after those that are specified. Two members may have the same
        sequence specifier, but in such a case the relative ordering of those
        members will be indeterminate.</para>

        <para>This approach is especially useful when dealing with inheritance
        hierarchies, as it allows sub-classes to specify where their
        additional members should be placed in relation to those inherited
        from the super-class.</para>

        <para>Note that certain styles of user interface will lay out an
        object's properties and its collections separately, in which case the
        relative member order of properties and collections will be evaluated
        separately. However, since other styles of user interface may
        interleave properties and collections, it is safer to assume the
        latter.</para>
      </sect1>

      <sect1>
        <title>@MultiLine</title>

        <para>The <literal moreinfo="none">@MultiLine</literal> annotation
        provides information about the carriage returns in a <literal
        moreinfo="none">String</literal> property or action parameter. The
        annotation indicates that:</para>

        <para>- the <code>String</code> property or parameter may contain
        carriage returns, and</para>

        <para>- (optionally) the typical number of such carriage returns,
        and</para>

        <para>- (optionally) that the text should be wrapped (the default is
        that text is not wrapped).</para>

        <warning>
          <para>Currently the <literal
          moreinfo="none">preventWrapping</literal> functionality is not fully
          implemented.</para>
        </warning>

        <para>This may be used by the viewing mechanism to render the property
        as a multi-line textbox (or text-editor when changes are permitted),
        with appropriate wrapping and/or scrollbars. The syntax is:</para>

        <para><literal
        moreinfo="none">@MultiLine([numberOfLines=&lt;typicalNumberOfCRs&gt;]
        [,preventWrapping=&lt;false|true&gt;])</literal></para>

        <para>For example:</para>

        <programlisting format="linespecific">public class BugReport {
    <emphasis role="strong">@MultiLine(numberOfLines=10)</emphasis>
    public String getStepsToReproduce() { ... }
    public void setStepsToReproduce(String stepsToReproduce) { ... }
    ...
}</programlisting>

        <para>Here the <literal moreinfo="none">stepsToReproduce</literal> may
        be displayed in a text area of 10 rows, with no wrapping. A horizontal
        scrollbar may appear if the number of characters on any given row
        exceeds the width. Another example:</para>

        <programlisting format="linespecific">public class Email {
    <emphasis role="strong">@MultiLine(numberOfLines=20, preventWrapping=false)</emphasis>
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

        <para>Here the body should be displayed in a text area of 20 rows,
        with wrapping. If this attribute is combined with the <literal
        moreinfo="none">&lt;TypicalLength&gt;</literal>, then the expected
        width of the text area in the user interface will be determined by the
        value of the typical length divided by the number of specified lines.
        For example:</para>

        <programlisting format="linespecific">public class Email {
    <emphasis role="strong">@MultiLine(numberOfLines=20, preventWrapping=false)</emphasis>
    @TypicalLength(800)
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

        <para>Here the body will (likely be) displayed in a text area of 20
        rows, with 40 columns.</para>
      </sect1>

      <sect1>
        <title>@MustSatisfy</title>

        <para>The <literal moreinfo="none">@MustSatisfy</literal> annotation
        allows validation to be applied to properties using an (implementation
        of a) <classname>org.apache.isis.applib.spec.Specification</classname>
        object.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@MustSatisfy(StartWithCapitalLetterSpecification.class)</emphasis>
    public String getFirstName() { ... }

    ...
}</programlisting>

        <para>The <classname>Specification</classname> is consulted during
        validation, being passed the proposed value.</para>
      </sect1>

      <sect1 id="sec.NamedAnnotation">
        <title>@Named</title>

        <para>The <literal moreinfo="none">@Named</literal> annotation is used
        when you want to specify the way something is named on the user
        interface i.e. when you do not want to use the name generated
        automatically by the system. It can be applied to objects, members
        (properties, collections, and actions) and to parameters within an
        action method.</para>

        <para><warning>
            <para>Generally speaking it is better to rename the property,
            collection or action. The only common case where
            <literal>@Named</literal> is common is to rename parameters for
            built-in value types. Even here though a custom value type can be
            defined using <classname>@Value</classname> so that the value type
            is used as the parameter name. @Named may also be used if the name
            needs punctuation or other symbols in the name presented to the
            user.</para>
          </warning></para>

        <bridgehead>Specifying the name of an object</bridgehead>

        <para>By default the name of an object is derived, reflectively from
        the class name. To specify a different name for an object, use the
        <literal moreinfo="none">@Named</literal> annotation in front of the
        class declaration. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Named("Customer")</emphasis>
public class CustomerImpl implements Customer{
   ...
}</programlisting>

        <para>See also: <literal moreinfo="none">@Plural</literal>.</para>

        <bridgehead>Specifying the name of a member</bridgehead>

        <para>By default, the name of a member (a property, collection or
        action) presented to the user is derived, reflectively, from the name
        of the member defined in the program code. To specify a different name
        use the <literal moreinfo="none">@Named </literal>annotation
        immediately before the member declaration. For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Named("Given Name")</emphasis>
    public String getFirstName() { ... }

    <emphasis role="strong">@Named("Family Name")</emphasis>
    public String getSurname() { ... }

    public CreditRating getCreditRating() { ... }
}</programlisting>

        <para>Note that the framework provides a separate and more powerful
        mechanism for internationalisation.</para>

        <bridgehead>Specifying the name for an action parameter</bridgehead>

        <para>The most common usage of <literal moreinfo="none">@Named
        </literal>will be to specify names for the parameters of an action:
        because, by default, the user interface will use the type of the
        parameter as the name. (This is because the parameter name declared in
        the code for the action method cannot be picked up reflectively.) To
        specify the name of a parameter, the <literal
        moreinfo="none">@Named</literal> annotation is applied 'in-line' (i.e.
        preceding the individual parameter declaration). For example:</para>

        <programlisting format="linespecific">public class Customer {

    public Order placeOrder(
                      Product product,
                      <emphasis role="strong">@Named("Quantity")</emphasis>
                      int quantity) {

        Order order = new Order();
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@NotContributed</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@NotInServiceMenu</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1 id="not-persistable">
        <title>@NotPersistable</title>

        <para>This annotation indicates that transient instances of this class
        may be created but may not be persisted. The framework will not
        provide the user with an option to 'save' the object, and attempting
        to persist such an object programmatically would be an error. For
        example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@NotPersistable</emphasis>
public class InputForm {
    // members and actions here
}</programlisting>

        <para>This annotation can also take a single parameter indicating
        whether it is only the user that cannot persist the object, for
        example the following code would prevent the user from saving the
        object (via the viewer) but still allow the program to persist the
        object. By default the annotated object is effectively transient, e.g.
        it is implicitly
        <classname>By</classname>.<varname>USER_OR_PROGRAM</varname>.</para>

        <programlisting format="linespecific"><emphasis role="strong">@NotPersistable</emphasis>(By.USER)
public class InputForm {
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@NotPersisted</title>

        <para>This indicates that the property is not to be persisted. Note
        that in many cases the same thing could be achieved by providing the
        property with a 'getter' but no 'setter'. For example:</para>

        <remark>Check that this is acceptable for Hibernate</remark>

        <programlisting format="linespecific">public class Order {

    private Order previousOrder;

    <emphasis role="strong">@NotPersisted</emphasis>
    public Order getPreviousOrder() {...}

    public void setPreviousOrder(Order previousOrder) {...}

    // rest of code
}</programlisting>
      </sect1>

      <sect1>
        <title>@Optional</title>

        <para>By default, the system assumes that all properties of an object
        are required, and therefore will not let the user save a new object
        unless a value has been specified for each property. Similarly, by
        default, the system assumes that all parameters in an action are
        required and will not let the user execute that action unless values
        have been specified for each parameter. To indicate that either a
        property, or an action parameter, is optional, use the <literal
        moreinfo="none">@Optional</literal> annotation.</para>

        <bridgehead>Making a property optional</bridgehead>

        <para>To indicate that a property is optional (i.e. that the user may
        save the object without necessarily specifying a value for this
        property), use the @Optional annotation immediately before the
        declaration of that property. For example:</para>

        <programlisting format="linespecific">public class Order {
    public Product getProduct() { ... }
    
    public java.util.Date getShipDate() { ... }
    public void setShipDate(Date java.util.shipDate) { ... }

    <emphasis role="strong">@Optional</emphasis>
    public String getComments() { ... }
    public void setComments(String comments) { ... }
}</programlisting>

        <para>Here the <literal moreinfo="none">product</literal> and <literal
        moreinfo="none">shipDate</literal> properties are both required, but
        the <literal moreinfo="none">comments</literal> property is
        optional.</para>

        <bridgehead>Making an action parameter optional</bridgehead>

        <para>To indicate that an action may be invoked without having to
        specify a value for a particular parameter, the
        <literal>@Optional</literal> annotation should be used in-line i.e.
        immediately before the declaration of that parameter. For
        example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
              Product product,
              @Named("Quantity") int quantity, 
              @Optional @Named("Special Instructions") String instr) {
        ....
    }
    ...
}</programlisting>

        <para>Note that the <literal
        moreinfo="none">@Optional</literal>annotation has no meaning for a
        primitive property (or parameter) such as <literal
        moreinfo="none">int</literal> - because primitives will always return
        a default value (e.g. zero). If optionality is required, then use the
        corresponding wrapper class (e.g. java.lang.Integer).</para>
      </sect1>

      <sect1>
        <title>@Parseable</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@Plural</title>

        <para>Where Apache Isis displays a collection of several objects it
        may use the plural form of the object type in the title. By default
        the plural name will be created by adding an 's' to the end of the
        singular name (whether that is the class name or another name
        specified using <literal moreinfo="none">@Named</literal>). Where the
        single name ends in 'y' then the default plural name will end in 'ies'
        - for example a collection of <literal
        moreinfo="none">Country</literal> objects will be titled 'Countries'.
        Where these conventions do not work, the programmer may specify the
        plural form of the name using @Plural. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Plural("Children")</emphasis>
public class Child {
    // members and actions here
}</programlisting>
      </sect1>

      <sect1>
        <title>@Prototype</title>

        <para></para>

        <para>***</para>

        <para></para>
      </sect1>

      <sect1>
        <title>@RegEx</title>

        <para>The <literal moreinfo="none">@RegEx</literal> annotation may be
        applied to any property, or to any parameter within an action method,
        that is a value type (i.e. that allows the user to type in text as
        input). It serves both to validate and potentially to normalise the
        format of the input. <literal moreinfo="none">@Regex</literal> is
        therefore similar in use to <literal moreinfo="none">@Mask</literal>
        but provides more flexibility. The syntax is:</para>

        <para><literal moreinfo="none">@RegEx(validation = &lt;regEx
        string&gt;, format = &lt;regEx string&gt;, caseSensitive =
        &lt;true|false&gt;)</literal></para>

        <para>The first parameter is required; the format defaults to 'no
        formatting'; caseSensitive defaults to false. When applying Regex to a
        value property, the annotation should be applied to the 'getter'. For
        example:</para>

        <programlisting format="linespecific">    private String email;

<emphasis role="strong">    @RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")</emphasis>
    public String getEmail() {}

    public void setEmail(String email) {}</programlisting>

        <para>When applying a RegEx expression to a value parameter within an
        action method, the annotation should precede that parameter:</para>

        <programlisting format="linespecific">    public void newContact(
        @Named("Contact Name")
        String contactName,
        @Named("Email")
        <emphasis role="strong">@RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")</emphasis>
        String email) {}</programlisting>
      </sect1>

      <sect1>
        <title>@TypeOf</title>

        <para>The <literal moreinfo="none">@TypeOf</literal> annotation is
        used to specify the type of elements in a collection, when it is not
        possible to use generics - for example when invoking an external
        method that does not use generics.</para>

        <programlisting format="linespecific"><emphasis role="strong">@TypeOf(Customer.class)</emphasis>
public List allNewCustomers() {
    return CustomerDatabase.allNewCustomers();
}</programlisting>
      </sect1>

      <sect1>
        <title>@TypicalLength</title>

        <para>The <literal moreinfo="none">@TypicalLength</literal> annotation
        indicates the typical length of a <literal
        moreinfo="none">String</literal> property or <literal
        moreinfo="none">String</literal> parameter in an action. This may be
        used by the viewing mechanism to determine the space that should be
        given to that property or parameter in the appropriate view. For
        example:</para>

        <programlisting format="linespecific">public class Customer {
    @MaxLength(30)
    <emphasis role="strong">@TypicalLength(20)</emphasis>
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
}</programlisting>

        <para>If the typical length is the same as the <literal
        moreinfo="none">&lt;MaxLength&gt;</literal> then there is no need to
        specify <literal moreinfo="none">&lt;TypicalLength&gt;</literal> as
        well. If the value specified is zero or negative then it will be
        ignored.</para>
      </sect1>

      <sect1>
        <title>@Value</title>

        <para>The <literal moreinfo="none">@Value</literal> annotation
        indicates that a class should be treated as a value type rather than
        as a reference (or entity) type. It does this providing an
        implementation of a
        <classname>org.apache.isis.applib.adapters.ValueSemanticsProvider</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@Value(semanticsProviderClass=ComplexNumberValueSemanticsProvider.class)
public class ComplexNumber {
    ...
}</programlisting>

        <para>The <classname>ValueSemanticsProvider</classname> allows the
        framework to interact with the value, parsing strings and displaying
        as text, and encoding/decoding (for serialization).</para>

        <para></para>

        <para></para>

        <para></para>

        <para>AbstractValueSemanticsProvider</para>

        <para></para>

        <para>DefaultsProvider</para>

        <para>EncoderDecoder</para>

        <para>Parser</para>

        <para></para>
      </sect1>
    </appendix>

    <appendix id="apx.DomainObjectContainer">
      <title><classname>DomainObjectContainer</classname> interface</title>

      <abstract>
        <para>Provides a single point of contact from domain objects into the
        <emphasis>Apache Isis</emphasis> framework.</para>
      </abstract>

      <para>The <classname>DomainObjectContainer</classname> interface
      provides a single point of contact from domain objects into the
      <emphasis>Isis</emphasis> framework. It can also be used as a
      lightweight general purpose repository during prototyping.</para>

      <table>
        <title>DomainObjectContainer methods</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Method</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="2">Object creation</entry>

              <entry>newTransientInstance(Class&lt;T&gt;)</entry>

              <entry>Creates new non-persisted object</entry>
            </row>

            <row>
              <entry>newPersistentInstance(Class&lt;T&gt;)</entry>

              <entry>Creates new object, will be persisted at end of
              action</entry>
            </row>

            <row>
              <entry>newInstance(Class&lt;T&gt;, Object)</entry>

              <entry>Creates object in state persistence state as that
              provided</entry>
            </row>

            <row>
              <entry morerows="1">Validation</entry>

              <entry>isValid(Object o)</entry>

              <entry>whether object is valid</entry>
            </row>

            <row>
              <entry>validate(Object o)</entry>

              <entry>reason why object is invalid (if any)</entry>
            </row>

            <row>
              <entry morerows="4">Object persistence</entry>

              <entry>isPersistent(Object)</entry>

              <entry>whether object is persistent</entry>
            </row>

            <row>
              <entry>persist(Object)</entry>

              <entry>persist the transient object</entry>
            </row>

            <row>
              <entry>persistIfNotAlready(Object)</entry>

              <entry>persist the object (provided is not already
              persisted)</entry>
            </row>

            <row>
              <entry>remove(Object)</entry>

              <entry>remove the persisted object</entry>
            </row>

            <row>
              <entry>removeIfNotAlready(Object)</entry>

              <entry>remove the object (provided is not already
              transient)</entry>
            </row>

            <row>
              <entry morerows="6">Generic Repository</entry>

              <entry>allInstances(Class&lt;T&gt;)</entry>

              <entry>All persisted instances of specified type</entry>
            </row>

            <row>
              <entry>allMatches(Class&lt;T&gt;, Filter&lt;T&gt;)</entry>

              <entry>All persistenced instances of specified type matching
              filter</entry>
            </row>

            <row>
              <entry>allMatches(Class&lt;T&gt;, String)</entry>

              <entry>All persisted instances with the specified string as
              their title</entry>
            </row>

            <row>
              <entry>allMatches(Class&lt;T&gt;, Object)</entry>

              <entry>All persisted instances matching object
              (query-by-example)</entry>
            </row>

            <row>
              <entry>allMatches(Query&lt;T&gt;)</entry>

              <entry>All instances satisfying the provided query</entry>
            </row>

            <row>
              <entry>firstMatch(...)</entry>

              <entry>As for allMatches, but returning first instance</entry>
            </row>

            <row>
              <entry>uniqueMatch(...)</entry>

              <entry>As for firstMatch(...), but requiring there to be only
              one match</entry>
            </row>

            <row>
              <entry morerows="2">Messages and warnings</entry>

              <entry>informUser(String)</entry>

              <entry>Inform the user</entry>
            </row>

            <row>
              <entry>warnUser(String)</entry>

              <entry>Warn the user about a situation, requiring
              acknowledgement.</entry>
            </row>

            <row>
              <entry>raiseError(String)</entry>

              <entry>Notify user of a serious application error, typically
              requiring further action on behalf of the user</entry>
            </row>

            <row>
              <entry>Security</entry>

              <entry>getUser()</entry>

              <entry>The currently-logged on user</entry>
            </row>

            <row>
              <entry morerows="1">Properties</entry>

              <entry>getProperty(String)</entry>

              <entry>Value of configuration property</entry>
            </row>

            <row>
              <entry>getPropertyNames()</entry>

              <entry>All configuration properties available</entry>
            </row>

            <row>
              <entry morerows="1">Lazy loading, dirty object tracking
              (*)</entry>

              <entry>resolve(Object)</entry>

              <entry>Lazy load object (overloaded to optionally load a
              property of object)</entry>
            </row>

            <row>
              <entry>objectChanged(Object)</entry>

              <entry>Mark object as dirty</entry>
            </row>

            <row>
              <entry morerows="1">Object store control (**)</entry>

              <entry>flush()</entry>

              <entry>Flush all pending changes to object store</entry>
            </row>

            <row>
              <entry>commit()</entry>

              <entry>Commit all pending changes to object store</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><note>
          <para>(*) generally not necessary to call - performed by bytecode
          proxies</para>
        </note><note>
          <para>(**) the use of these methods is discouraged - they are
          typically used only for tests</para>
        </note></para>

      <sect1>
        <title>Lazy Loading, Dirty Object Tracking</title>

        <para></para>
      </sect1>
    </appendix>

    <appendix id="apx.SecurityClasses">
      <title>Security Classes</title>

      <para></para>

      <sect1>
        <title>User details</title>

        <sect2>
          <title>UserMemento</title>

          <para>sdfsf</para>
        </sect2>

        <sect2>
          <title>RoleMemento</title>

          <para>asdad</para>

          <para></para>
        </sect2>
      </sect1>
    </appendix>

    <appendix id="apx.UtilityClasses">
      <title>Utility Classes</title>

      <abstract>
        <para>***</para>
      </abstract>

      <para></para>

      <para></para>

      <sect1>
        <title>Title creation</title>

        <para>asdfsd</para>

        <para>The TitleBuffer helper class</para>

        <para></para>
      </sect1>

      <sect1>
        <title>Reason text creation (for disable and validate methods)</title>

        <para>There are two different classes provided to help build reasons
        returned by <methodname>disableXxX()</methodname> and
        <methodname>validateXxx()</methodname> methods:</para>

        <itemizedlist>
          <listitem>
            <para>the
            <classname>org.apache.isis.applib.util.ReasonBuffer</classname>
            helper class</para>
          </listitem>

          <listitem>
            <para>the
            <classname>org.apache.isis.applib.util.Reasons</classname> helper
            class</para>
          </listitem>
        </itemizedlist>

        <para>For example:</para>

        <programlisting>public class Customer {
    ...
    public String validatePlaceOrder(Product p, int quantity) {
        return Reasons.coalesce(
            whetherCustomerBlacklisted(this),
            whetherProductOutOfStock(p)
        );
    }
}</programlisting>

        <para>Which you use (if any) is up to you.</para>
      </sect1>
    </appendix>

    <appendix>
      <title>Events</title>

      <para></para>

      <para>org.apache.isis.applib.events.InteractionEvent</para>

      <para></para>

      <para></para>

      <para></para>
    </appendix>
  </part>
</book>
