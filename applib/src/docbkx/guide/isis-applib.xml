<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>

      <author>
        <firstname>Robert</firstname>

        <surname>Matthews</surname>
      </author>

      <author>
        <firstname>Kevin</firstname>

        <surname>Meyer</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para><emphasis>Apache Isis</emphasis> is designed to allow programmers
    rapidly develop domain-driven applications following the <ulink
    url="http://en.wikipedia.org/wiki/Naked_Objects">Naked Objects</ulink>
    pattern. It is made up of a core framework plus a number of alternate
    implementations, and supports various viewers and object stores. Apache
    Isis is hosted at the <ulink url="http://incubator.apache.org/isis">Apache
    Foundation</ulink>, and is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>

    <para>This guide is written for programmers looking to understand the
    programming conventions, annotations and supporting utilities within the
    <emphasis>Apache Isis</emphasis> application library (or
    <emphasis>applib</emphasis>), in order that the framework can correctly
    pick up and render the business rules and logic encoded within their
    domain objects.</para>
  </preface>

  <!-- main content -->

  <chapter id="chp.Intro">
    <title>Overview</title>

    <abstract>
      <para>This chapter gives an overview of the main principles and patterns
      that underly the Apache Isis approach.</para>
    </abstract>

    <sect1>
      <title>Introduction</title>

      <para><emphasis>Apache Isis</emphasis> is a full-stack open source
      application development framework, designed to let you rapidly develop
      enterprise business applications following a domain-driven philosophy.
      Developing an application in Isis is - at least initially - about
      focusing on the bit that matters to the business, the core domain logic.
      It</para>

      <para></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Principles</title>

      <para><emphasis></emphasis></para>

      <para><emphasis></emphasis><note>
          <para>TODO: distill some of the material on the trunk site.</para>

          <para></para>
        </note></para>

      <sect2>
        <title>Ubiquitous Language</title>

        <para></para>

        <para></para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Rapid Application Development</title>

        <para></para>

        <para></para>

        <note>
          <para>TODO: discuss</para>
        </note>

        <para>feedback loop</para>

        <para>requirements traceability</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Problem Solver, not Process Follower</title>

        <para></para>

        <para></para>

        <note>
          <para>TODO: discuss</para>
        </note>

        <para>Sovereign Applications vs Transient Applications</para>

        <para></para>

        <para>for sovereign applications</para>

        <para></para>

        <para>incredible machine</para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Commonly Trodden Paths</title>

        <para></para>

        <para></para>

        <note>
          <para>TODO: discuss</para>
        </note>

        <para>for transient apps</para>

        <para></para>

        <para>Civil engineering analogy.... put in the paths afterwards</para>

        <para></para>

        <para>Christopher Alexander - cardboard cutouts of where the windows
        go</para>

        <para></para>

        <para>Database denormalization</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Opinionated</title>

        <para></para>

        <para></para>

        <note>
          <para>TODO: discuss</para>
        </note>

        <para></para>

        <para>convention over configuration</para>

        <para></para>

        <para>framework, domain services, dependency injection</para>

        <para></para>

        <para>JSR-299</para>

        <para>don't want too many degrees of freedom. Work out of the box,
        specify alternates later as needed</para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Patterns</title>

      <para>The framework is designed around two patterns:</para>

      <para></para>

      <sect2>
        <title>Naked Objects Pattern</title>

        <para>The first architectural pattern is the naked objects pattern,
        whereby the framework automatically generates an object-oriented user
        interface (OOUI) for your domain objects. If required, this OOUI can
        then be customized.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Hexagonal Architecture</title>

        <para>The second core pattern implemented by <emphasis>Apache
        Isis</emphasis> is the hexagonal architecture. This means it allows
        the same domain model to be run with different viewers, either as a
        desktop app or as a webapp. Equally, you can choose which object store
        to use in order to persist your domain objects. The diagram below
        shows the hexagonal architecture as it is implemented by Apache
        Isis.</para>

        <para></para>

        <para></para>

        <note>
          <para>TODO: discuss</para>
        </note>

        <para>*** picture of the hexagonal architecture here.</para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Dependency Injection</title>

        <para></para>

        <para></para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Benefits and Consequences</title>

      <para></para>

      <para><note>
          <para>TODO: review stuff below, copied-n-pasted from site
          docs.</para>
        </note></para>

      <para>As you might imagine, not needing to write any GUI code
      substantially speeds up development, and shortens the feedback loop to
      allow you to improve your core domain model without lots of GUI code
      slowing you down.</para>

      <para>The OOUIs generated by Apache Isis are especially suitable to
      "expert" users, typically those internal to your organization who have a
      good understanding of the domain and just want to get their job done.
      But for less expert users (or for a webapp deployed on the internet), a
      more scripted UI may be called for. Isis therefore lets you customize
      the user interface according to your users' needs.</para>

      <para>Alternatively, you might want to just use Isis as a design tool.
      The framework goes to a lot of trouble to ensure that the domain objects
      you build have no dependencies on the framework: they are basically
      annotated pojos that follow a number of straightforward programming
      conventions. So, you can use Isis to rapidly evolve your domain objects,
      and then deploy them within some other runtime framework if you
      wish.</para>

      <para></para>

      <para></para>

      <note>
        <para>TODO: include some of the benefits cited for NO pattern, from
        website: faster development cycle, greater agility, empowering style
        of UI, requirements analysis/traceability; play to developer
        strengths</para>
      </note>

      <para></para>

      <sect2>
        <title>Playing to Developer Strengths</title>

        <para></para>

        <para></para>

        <note>
          <para>TODO: discuss</para>
        </note>

        <para>domain programmer/business analyst</para>

        <para></para>

        <para>application integration expert (domain services)</para>

        <para></para>

        <para>customizer (UI expert)</para>

        <para></para>

        <para>architectural integration</para>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Developing Isis Applications</title>

    <abstract>
      <para>This chapter describes the general approach to follow that we
      recommend for developing domain-driven applications on Isis.</para>
    </abstract>

    <sect1>
      <title>Where to Start?</title>

      <para>There's quite a lot to <emphasis>Apache Isis</emphasis>, with lots
      of optional components (which we call alternates, in keeping with
      JSR-299 terminology). To keep things manageable, the Isis documentation
      is scoped closest to where it's relevant.</para>

      <para>On the other hand, it can be difficult to know exactly where to go
      in the first place... hence these notes. If you read them from top to
      bottom then you'll (a) have a pretty good idea of the general process we
      recommend for developing domain applications in <emphasis>Apache
      Isis</emphasis> and (b) know where to look for more detailed
      documentation.</para>
    </sect1>

    <sect1 id="sec.ApplicationArchetypes">
      <title>Application Archetypes</title>

      <para>We tend to structure Apache Isis applications following a standard
      structure, and you can use the <emphasis>application</emphasis> Maven
      archetype (in <filename>support/archetypes/application</filename>) to
      set this up for you. Some of the optional plugins also provide their own
      Maven archetypes which you can run afterwards, for example to setup a
      particular new viewer or object store. The idea is that these are run
      alongside your own application, and provide additional Maven
      (sub)modules which you can then reference.</para>

      <para>Going back to the application archetype though, this sets up a
      simple application that can be run out-of-the-box in exploration mode
      (that is, with the in-memory object store), and using one of the two
      main viewers:</para>

      <itemizedlist>
        <listitem>
          <para>the Drag-n-Drop (<acronym>DnD</acronym>) viewer is a
          client-side viewer that renders the domain objects to a desktop
          metaphor.</para>
        </listitem>

        <listitem>
          <para>the <acronym>HTML</acronym> viewer is designed to run within a
          webapp, and renders a single domain object per page.</para>
        </listitem>
      </itemizedlist>

      <para>Each of these can be run from the command line (the
      <acronym>HTML</acronym> viewer boots up an instance of Jetty web
      server); the archetype documentation explains how; there's further
      documentation on these particular viewers themselves in their respective
      module documentation (see <xref linkend="sec.Viewers" />).</para>

      <para>Later on you'll want to deploy the application more formally, for
      example as a <acronym>WAR</acronym> archive (see <xref
      linkend="sec.DeployingAnIsisApplication" /> for more details).</para>
    </sect1>

    <sect1>
      <title>Programming Model</title>

      <para>Once you've got the archetype application running, you're ready to
      start developing your own domain objects. But no matter what application
      you are developing, you'll need to understand the <emphasis>Isis
      programming model</emphasis>.</para>

      <para>The programming model is the set of annotations and programming
      conventions that Isis recognizes. You'll find the programming model is
      documented in the Application Library module (in
      <filename>applib</filename>).</para>

      <para>In addition, the applib contains a small number of utilities which
      can be useful when writing your application: one such is the ability to
      create XML snapshots of your domain object graphs.</para>

      <para>The applib documentation also provides pointers to other features
      that can have an impact on the way in which you write your code, namely
      the cglib and javassist bytecode providers modules (<xref
      linkend="sec.BytecodeProviders" />), the
      <filename>alternates/headless</filename> viewer plugin (<xref
      linkend="sec.Headless" />), and the <ulink
      url="http://groovy.codehaus.org">Groovy</ulink> language support (<xref
      linkend="sec.OtherLanguages" />).</para>
    </sect1>

    <sect1>
      <title>Fixtures and Prototyping</title>

      <para>We suggest that the fastest way to develop your application is to
      start prototyping using the in-memory object store (that is, as set up
      by the application archetype, see <xref
      linkend="sec.ApplicationArchetypes" />). The nice thing about working
      this way is that there is no database schema to slow you down; you can
      make changes and then rapidly try them out.</para>

      <para>On the other hand, the in-memory object store doesn't persist
      objects between runs, so you'll soon tire of continually recreating test
      objects to try out your changes. You should therefore use fixtures:
      blocks of code that are used to setup objects in the in-memory object
      store prior to the app running.</para>

      <para>You can find more information about using fixtures in the
      <filename>applib</filename> module. It's also worth knowing about them
      because they are used when writing tests for your domain application
      (see <xref linkend="sec.AgileTesting" />).</para>
    </sect1>

    <sect1 id="sec.AgileTesting">
      <title>Agile Testing</title>

      <para><emphasis>Apache Isis</emphasis> is very much aligned to agile
      development practices, and provides two complementary mechanisms for you
      to test-drive the development of your application.</para>

      <sect2>
        <title>Story Testing</title>

        <para>Many agile practitioners use story tests as a means to capture
        the acceptance (or completion) criteria for high-level user stories.
        These story tests are typically captured in a non-programmatic form so
        that is understandable to domain experts as well as
        programmers.</para>

        <para>Isis provides integrations with two story testing
        frameworks:</para>

        <itemizedlist>
          <listitem>
            <para><ulink url="http://fitnesse.org">FitNesse</ulink>, where the
            story test is captured within a wiki, and</para>
          </listitem>

          <listitem>
            <para><ulink url="http://concordion.org">Concordion</ulink>, where
            the story test is captured as HTML.</para>
          </listitem>
        </itemizedlist>

        <para>For more information on using these integrations and their
        supporting archetypes, see the <filename>storytests</filename>
        module.</para>
      </sect2>

      <sect2 id="sec.UnitTesting">
        <title>Unit Testing</title>

        <para>Unlike story tests, unit tests are normally written in a
        programming language, typically in a framework such as <ulink
        url="http://junit.org">JUnit</ulink>. <emphasis>A story test ensures
        that the right system is built, while a unit tests ensures the system
        is built right</emphasis>.</para>

        <para>When writing unit tests, you have a choice. Since all the
        business logic in [[NAME]] applications is encapsulated in domain
        object pojos, you can just write unit tests using nothing more than
        JUnit and perhaps also a mocking library such as <ulink
        url="http://jmock.org">JMock</ulink>.</para>

        <para>A slightly more sophisticated approach is to use the JUnit
        integrations and supporting classes of the (so-called) Headless module
        (in <filename>alternates/headless</filename>) . The idea of these
        utilities is to wrap your domain objects in proxies that apply the
        same rules as an <emphasis>Apache Isis</emphasis> viewer. For example,
        if you try to change a property or invoke an action that is disabled,
        then the proxy will throw an exception. You write your test to pass if
        the exception is thrown, and failed otherwise (eg using
        <code>@Test(expected=DisabledException.class)</code>).</para>
      </sect2>
    </sect1>

    <sect1>
      <title>A Domain Library</title>

      <para>The idea behind the <filename>domain</filename> module is to
      provide some off-the-shelf code for you to use and adapt in your own
      applications. This code is fully tested (comes with tests), and is
      intended to be well-designed. Using code from the library should give
      you a kick-start in writing your own domain applications.</para>

      <note>
        <para>The library is currently very modest, but we hope it might build
        up in time.</para>
      </note>

      <para>Of course, there's a limit to the complexity of the code that's
      included in the library, because every domain is different. But having a
      full set of tests should allow you to safely refactor the code to your
      own requirements.</para>

      <para>There's also no guarantee that the library will contain code for
      your specific requirement. But if you do write some domain logic that
      you think might be reusable by others, why not consider donating it back
      to Isis when you've done so?</para>

      <para>The domain library breaks out into three: services, entities and
      values.</para>

      <sect2>
        <title>Domain Services</title>

        <para><emphasis>Apache Isis</emphasis> applications use
        <emphasis>domain service</emphasis>s (a domain-driven design pattern)
        to allow objects to interact with other domains (or <emphasis>bounded
        context</emphasis>s, to use the correct term). These domain services
        are automatically injected into each domain object as it is
        instantiated.</para>

        <para>Domain services split into two: those that interact with
        technical domains (such as sending email, or rendering
        <acronym>PDF</acronym>s), and those that interact with business
        domains (such as general ledger, <acronym>CRM</acronym>s or legacy
        systems).</para>

        <para>Obviously domain services that bridge to business domain
        services are always likely to be specific to each individual
        application. So the services in the
        <filename>domain/services</filename> module focus on providing
        off-the-shelf implementations for some of the more common
        <emphasis>technical</emphasis> domain services.</para>
      </sect2>

      <sect2>
        <title>Domain Values</title>

        <para></para>

        <note>
          <para>TODO</para>
        </note>
      </sect2>

      <sect2>
        <title>Domain Entities</title>

        <para></para>

        <note>
          <para>TODO</para>
        </note>
      </sect2>
    </sect1>

    <sect1>
      <title>Object Stores</title>

      <para>Although you can go a long way in developing your application
      using only fixtures and the in-memory object store, eventually you will
      need to integrate with a "real" object store that persists object to
      some sort of serialized store.</para>

      <para>There are several object stores to choose from. Some are easy to
      configure, some more complex; some are only suitable for single-user
      apps, others for multi-users. Each of the object stores has its own
      documentation, so you can select the correct object store to
      choose:</para>

      <itemizedlist>
        <listitem>
          <para>the <acronym>XML</acronym> object store (in
          <filename>alternates/objectstores/xml</filename>) is designed for
          single-user systems, and persists to its own internal (proprietary)
          <acronym>XML</acronym> format;</para>
        </listitem>

        <listitem>
          <para>the Berkeley object store (in
          <filename>alternates/objectstores/berkeley</filename>) is a
          multi-user object store, persists using <ulink
          url="http://www.oracle.com/technetwork/database/berkeleydb/overview/index.html">Berkeley
          DB</ulink>;</para>
        </listitem>

        <listitem>
          <para>the <acronym>SQL</acronym> object store (in
          <filename>alternates/objectstores/sql</filename>) is a multi-user
          object store that persists to an <acronym>RDBMS</acronym> (direct
          over <acronym>JDBC</acronym>);</para>
        </listitem>

        <listitem>
          <para>the <acronym>JPA</acronym> object store (in
          <filename>alternates/objectstores/</filename>jpa) is a multi-user
          object store, persists to an <acronym>RDBMS</acronym> (using a
          <acronym>JPA</acronym> provider for the heavy lifting);</para>
        </listitem>

        <listitem>
          <para>the <acronym>CouchDB</acronym> object store (in
          <filename>alternates/objectstores/</filename>couchdb) is a
          multi-user object store that persists to <ulink
          url="http://couchdb.apache.org">CouchDB</ulink>.</para>
        </listitem>
      </itemizedlist>

      <para>At the time of writing some of these object stores were still
      alpha/beta; check the documentation for each of the above object stores
      to confirm their exact status.</para>

      <para>You'll also find coverage of the object store
      <acronym>API</acronym> itself in this document, see <xref
      linkend="chp.ObjectStoreApi" />. Most users of the framework are
      unlikely to write their own object store, of course, though we hope that
      over time new implementations will be written by the community.</para>
    </sect1>

    <sect1 id="sec.Viewers">
      <title>Viewers</title>

      <para>In the same way that object stores provide pluggability for the
      "back-end", <emphasis>Apache Isis</emphasis> also offers pluggability on
      the front-end too.</para>

      <para>We already noted that there are two main viewers, the
      <acronym>DnD</acronym> viewer and the <acronym>HTML</acronym> viewer
      (configured by the application archetype, see <xref
      linkend="sec.ApplicationArchetypes" />). In addition, there are a number
      of other viewers. Here's the full list:</para>

      <itemizedlist>
        <listitem>
          <para>The <acronym>DnD</acronym> viewer (in
          <filename>alternates/viewers/dnd</filename>) is one of the two main
          viewers setup by the application archetype, and is currently the
          only viewer designed to run client-side (ie not as a webapp).</para>

          <para>Out-of-the-box it provides a generic view of all domain
          objects, but provides its own API to allow more sophisticated views
          to be constructed.</para>
        </listitem>

        <listitem>
          <para>The <acronym>HTML</acronym> viewer (in
          <filename>alternates/viewers/html</filename>) is the second of the
          two main viewers setup by the application archetype, running as a
          webapp.</para>

          <para>Other than tweaking <acronym>CSS</acronym>, the views that it
          provides of objects cannot be customized.</para>
        </listitem>

        <listitem>
          <para>Scimpi (in <filename>alternates/viewers/scimpi</filename>)
          allows your application to be deployed as a webapp.</para>

          <para>Out-of-the-box you get a generic view (very similar to that
          provided by HTML viewer); you can then customize the view by
          providing custom pages that use Scimpi tags.</para>
        </listitem>

        <listitem>
          <para>The Wicket viewer (in
          <filename>alternates/viewers/wicket</filename>) uses <ulink
          url="http://wicket.apache.org">Apache Wicket</ulink> to render
          generic views of your domain objects in a webapp.</para>

          <para>Like Scimpi, it allows these views to be customized, this time
          by leveraging the Wicket <classname>Component</classname>
          <acronym>API</acronym>.</para>
        </listitem>

        <listitem>
          <para>The RESTful viewer (in
          <filename>alternates/viewers/restful</filename>) is designed to
          expose your domain objects through a <ulink
          url="http://en.wikipedia.org/wiki/Representational_State_Transfer">RESTful</ulink>
          interface.</para>

          <para>The intention is to allow programmatic access to your domain
          objects from other (perhaps non-Java) clients. The viewer does also
          render as <acronym>XHTML</acronym> for debugging purposes.</para>
        </listitem>
      </itemizedlist>

      <para>If deploying with the <acronym>DnD</acronym> viewer you also need
      to decide whether to deploy standalone (ie, each user has their own
      private object store) or in client/server mode (so all users share a
      server-based object store). If the latter case then you will need to set
      up remoting (see <xref linkend="sec.Remoting" />).</para>
    </sect1>

    <sect1 id="sec.Remoting">
      <title>Remoting</title>

      <para>If deploying the <acronym>DnD</acronym> viewer in client/server
      mode then you will need to set up remoting. The main consideration is
      what transport to use:</para>

      <itemizedlist>
        <listitem>
          <para>sockets</para>

          <para>In this configuration both client and server run as
          command-line programs. No plugins are needed, this is the
          default;</para>
        </listitem>

        <listitem>
          <para>http</para>

          <para>In this configuration the server runs as a webapp with a
          servlet used to listen for client-side requests. The client,
          meanwhile, is configured to send its requests via
          <acronym>HTTP</acronym>.</para>
        </listitem>
      </itemizedlist>

      <para>In addition, you can choose the marshalling mechanism by which
      objects are serialized across the wire to be varied. There are (again),
      two options:</para>

      <itemizedlist>
        <listitem>
          <para>encoding/serialization</para>

          <para>In this configuration <emphasis>Apache Isis</emphasis>
          encodes/serializes all objects into a succession of bytestreams.
          This is the default</para>
        </listitem>

        <listitem>
          <para>xstream</para>

          <para>In this configuration the <ulink
          url="http://xstream.codehaus.org">Xstream</ulink> library is used to
          serialize objects</para>
        </listitem>
      </itemizedlist>

      <para>You'll find further coverage of the remoting APIs in <xref
      linkend="chp.RemotingApi" />. Detailed documentation of the
      <acronym>http</acronym> transport implementation in the HTTP Remoting
      module (in <filename>alternates/http-remoting</filename>) module, and
      documentation for the xstream implementation is in the XStream
      Marshalling module (in
      <filename>alternates/xstream-marshalling</filename>).</para>

      <para>There's also further coverage of deploying applications in
      client/server mode in <xref
      linkend="chp.DeployingIsisApplications" />.</para>
    </sect1>

    <sect1>
      <title>Authentication and Authorization</title>

      <para><emphasis>Apache Isis</emphasis> provides an
      <acronym>API</acronym>s for both authentication and authorization, see
      <xref linkend="chp.SecurityApi" />.</para>

      <para>The core implementation of these <acronym>API</acronym>s are very
      basic file-based authentication and authorization mechanisms, the
      configuration of which is described in <xref
      linkend="chp.SecurityApi" />. These default mechanisms are suitable for
      simple applications, but are unlikely to meet the security requirements
      of larger enterprises.</para>

      <para>As an alternative, you can use implementations that integrate with
      <acronym>LDAP</acronym> (in <filename>alternates/ldap-auth</filename>)
      module, or consider writing your own.</para>
    </sect1>

    <sect1 id="sec.DeployingAnIsisApplication">
      <title>Deploying an Isis Application</title>

      <para>Deploying your application depends on whether it is a webapp,
      client/server (DnD) or standalone (DnD). With the current set of
      deployment options it is likely to be one of:</para>

      <itemizedlist>
        <listitem>
          <para>standalone client running with DnD viewer and a local object
          store</para>
        </listitem>

        <listitem>
          <para>client/server over sockets</para>

          <itemizedlist>
            <listitem>
              <para>client running DnD viewer, sockets connection</para>
            </listitem>

            <listitem>
              <para>server running as a standalone app, listening on
              sockets</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>client/server over HTTP</para>

          <itemizedlist>
            <listitem>
              <para>client running DnD viewer, HTTP requests</para>
            </listitem>

            <listitem>
              <para>server running as a webapp, with HTTP servlet listening
              for requests</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>webapp, meaning any of:</para>

          <itemizedlist>
            <listitem>
              <para>HTML viewer</para>
            </listitem>

            <listitem>
              <para>Scimpi</para>
            </listitem>

            <listitem>
              <para>Wicket</para>
            </listitem>

            <listitem>
              <para>RESTful</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Indeed, it's theoretically possible to combine the various webapp
      viewers; for example the server-side HTTP, Scimpi and RESTful might all
      be colocated.</para>

      <para>In all cases you're likely to want to enable authentication and
      authorization; the exact configuration to use here will depend both on
      the implementation chosen (file-based, LDAP or some other) and whether
      running in client/server mode or not.</para>

      <para>The main coverage of the topic of deployment options (which
      repeats some of the above) can be found in this document, in <xref
      linkend="chp.DeployingIsisApplications" />.</para>
    </sect1>

    <sect1>
      <title>Other Features</title>

      <para></para>

      <para></para>

      <note>
        <para>TODO: discuss other features, x-ref elsewhere in this doc</para>
      </note>

      <para></para>

      <sect2 id="sec.BytecodeProviders">
        <title>Lazy Loading / Dirty Tracking</title>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Extending the Isis Meta Model</title>

        <para></para>
      </sect2>

      <sect2 id="sec.Headless">
        <title>Using the Headless Viewer</title>

        <para></para>
      </sect2>

      <sect2 id="sec.OtherLanguages">
        <title>Other Languages</title>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="chp.OrigDocs">
    <title>TODO: move old NOF docs here</title>

    <abstract>
      <para>*** yada yada</para>
    </abstract>

    <sect1>
      <title>***</title>

      <para><emphasis>*** yada yada</emphasis></para>
    </sect1>
  </chapter>

  <appendix>
    <title>***</title>

    <abstract>
      <para>*** yada yada</para>
    </abstract>

    <sect1 id="sec.module-ui">
      <title>***</title>

      <para>*** yada yada</para>
    </sect1>
  </appendix>
</book>
