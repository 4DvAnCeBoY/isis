<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./src/docbkx/dtd-4.5/docbookx.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>

      <author>
        <firstname>Robert</firstname>

        <surname>Matthews</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para><emphasis>Apache Isis</emphasis> is designed to allow programmers
    rapidly develop domain-driven applications following the <ulink
    url="http://en.wikipedia.org/wiki/Naked_Objects">Naked Objects</ulink>
    pattern. It is made up of a core framework that supports supports various
    viewers, along with <acronym>API</acronym>s and implementations relating
    to security, the programming model, the runtime (persistence) and profile
    stores (user preferences). <emphasis>Apache Isis</emphasis> is hosted at
    the <ulink url="http://incubator.apache.org/isis">Apache
    Foundation</ulink>, and is licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>

    <para>This guide is written for programmers looking to understand how the
    core framework of <emphasis>Apache Isis</emphasis> fits together,
    including an understanding of its core <acronym>API</acronym>s. It is
    divided into the following chapters:<itemizedlist>
        <listitem>
          <para>Architectural Overview</para>

          <para>The introductory chapter discusses some of the main
          architecture elements of the framework's design, distinguishing and
          explaining the reason for the applib, the core modules, the viewers,
          and the main <acronym>API</acronym>s exposed by the core.</para>
        </listitem>

        <listitem>
          <para>Chapters for each of Core Modules and
          <acronym>API</acronym>s</para>

          <para>This part of the guide goes through each of the modules that
          make up the core framework, along with more detailed coverage of the
          <acronym>API</acronym>s exposed by the core.</para>
        </listitem>
      </itemizedlist></para>

    <para>You'll note that we <emphasis>don't</emphasis> describe the
    implementations of these <acronym>API</acronym>s; most notably we don't
    describe the default runtime implementation. What this means is that
    details of how to actually deploy an <emphasis>Isis</emphasis> application
    are not included here, because those details depend on which runtime is
    being used. See the relevant runtime documentation for details.</para>

    <para>You'll also find that <emphasis>this</emphasis> guide (the core
    documentation) does not cover the programming model in depth. Rather, it
    explains why we have an applib in the first place, and more generally
    covers the main principles and patterns of writing any <emphasis>Apache
    Isis</emphasis> application. It also goes in depth into the architecture
    and design of the framework. For details of the programming guide (that
    is, how to actually write <emphasis>Isis</emphasis> applications) you
    should look to the applib (application library) documentation.<footnote>
        <para>This is a slight simplification; the applib defines the
        programming conventions of the <emphasis>default</emphasis>
        programming model. As you will learn, Isis can be extended to support
        different programming models. Therefore the conventions your
        application code follows will actually depend on whether you have
        customized the programming mode or not.</para>
      </footnote></para>

    <para></para>

    <para></para>
  </preface>

  <chapter id="chp.Intro">
    <title>Architectural Overview</title>

    <abstract>
      <para>What's in this guide, it's relationship to the applib
      documentation.</para>
    </abstract>

    <para><emphasis>Apache Isis</emphasis> is a full-stack open source
    application development framework, designed to let you rapidly develop
    enterprise business applications following a domain-driven philosophy.
    Developing an application in <emphasis>Isis</emphasis> is - at least
    initially - about focusing on the bit that matters to the business, the
    core domain logic.</para>

    <sect1>
      <title>Hexagonal Architecture</title>

      <para></para>

      <para>*** update picture.</para>

      <para></para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/HexagonalArchitectureOverview.png"
                     scale="50" />
        </imageobject>
      </mediaobject>

      <para></para>
    </sect1>

    <sect1>
      <title>Core Framework</title>

      <para></para>

      <para>consists of:</para>

      <itemizedlist>
        <listitem>
          <para>common</para>
        </listitem>

        <listitem>
          <para>test support</para>
        </listitem>

        <listitem>
          <para>metamodel</para>
        </listitem>

        <listitem>
          <para>progmodel</para>
        </listitem>
      </itemizedlist>

      <para></para>

      <para></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Core APIs</title>

      <para></para>

      <sect2>
        <title>Programming Model</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Security</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Runtime (Persistence)</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Profile Stores</title>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Viewers</title>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Conventions</title>

    <para></para>

    <para></para>

    <para>The <emphasis>Isis</emphasis> framework provides a number of tools
    to help resolve problems and debug the system. These are mainly applicable
    to issues within system code, but some of them can be useful when
    developing applications. The framework provides the following:-</para>

    <itemizedlist>
      <listitem>
        <para>Extensive use of logging through the <ulink
        url="http://logging.apache.org/log4j/docs/">Log4j</ulink> framework,
        an open source logging framework made available as part of the Apache
        Jakarta project ;</para>
      </listitem>

      <listitem>
        <para>Additional logging decorators that can be explicitly added to
        specific component to capture details about the usage of those
        components;</para>
      </listitem>
    </itemizedlist>

    <para>In addition, the DnD viewer provides debug views that display
    details of components and anything else that implements the
    <classname>DebugInfo</classname> interface. There is further coverage of
    this last feature in the DnD viewer's documentation.</para>

    <para></para>

    <sect1>
      <title>Logging</title>

      <para>Logging using Log4j is used throughout the framework and the
      components the Isis development team have created, and it is recommended
      that you use it too. Logging allows you to look what the framework and
      components have been when you investigate a problem and help to identify
      what parts of the system where doing what before an problem arose. Often
      logging alone is enough to pin point a problem, but if not it help you
      target what to investigate.</para>

      <para>Log4j allows you to log log debug messages, information about the
      system's state, warnings and errors. These events can be displayed on
      the console, written to files, or sent out over the network for remote
      logging. These are output in a user defined format and also can be
      filtered (so only events from certain components are seen). All this is
      configured through a set of properties passed to Log4J.</para>

      <sect2>
        <title>Configuring Logging</title>

        <para>The complete options for outputting and formatting can be found
        in the relavent Log4J documentation (including the API). However, it
        crucial to smooth development of an NOF system that will cover some of
        it here. The NOF configures Log4j using properties files and will
        generally load <filename class="directory"
        moreinfo="none">log4j.properties</filename> or retrieve the properties
        from the that were loaded from <filename class="directory"
        moreinfo="none">isis.properties</filename> after that is loaded for
        framework configuration (these files need to be located in the working
        directory). If you are not using classes within the NOF to start the
        framework then how these properties are loaded could vary. The
        downside of putting the logging properities in the framework
        properties files is that there is no logging until it has been loaded.
        If this is necessary then it is better to use the separate properties
        file.</para>

        <para>The following file, or portion of a file, is a basic
        configuration for logging. It consists of two appenders and a basic
        logging configuration.</para>

        <programlisting format="linespecific">log4j.rootLogger=INFO, Console, File

# The console appender
log4j.appender.Console=org.apache.log4j.ConsoleAppender
log4j.appender.Console.Target=System.out
log4j.appender.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.Console.layout.ConversionPattern=%-5r [%-20c{1} %-10t %-5p]  \t\t%m%n

# The exploration.log file appender
log4j.appender.File=org.apache.log4j.FileAppender
log4j.appender.File.File=exploration.log
log4j.appender.File.layout=org.apache.log4j.PatternLayout
log4j.appender.File.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
log4j.appender.File.Append=false</programlisting>

        <para>The first line sets up logging to show events of level
        <emphasis>INFO</emphasis> and above through the
        <emphasis>Console</emphasis> and <emphasis>File</emphasis> appenders,
        which writes those events to the console and the file <filename
        class="directory" moreinfo="none">exploration.log</filename>
        respectively. The two blocks sepcifiy how to write to the console and
        the file. Other appenders can be used to change where the logs are
        written to. The number of appenders specified is unlimited, although
        there should be at least one. The console below (from Eclipse) shows
        the log. The file will contain the same thing although the formatting
        will be slightly different as the conversion pattern for the two
        appenders is different.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/console-log.png" />
          </imageobject>
        </mediaobject>

        <sect3>
          <title>Logging levels</title>

          <para>The types of events that are logged can be changed. This
          determines how large the files become or how much traffic is put
          over the network, and is reflected in the amount of processing that
          needs to be done to process the events into messages that can be
          written out. Levels in order of increasing verbosity and log size,
          and is decreasing order of severity are:-</para>

          <itemizedlist>
            <listitem>
              <para>OFF - no logging</para>
            </listitem>

            <listitem>
              <para>FATAL - something very serious has happened that requires
              the system to be shut down.</para>
            </listitem>

            <listitem>
              <para>ERROR - something serious has happened that might affect
              any subsequent actions.</para>
            </listitem>

            <listitem>
              <para>WARN - something has not been set up properly, or needs
              attention. Although subsequent action might function correctly,
              they might not function as expected.</para>
            </listitem>

            <listitem>
              <para>INFO - information to the developer about something that
              has taken place.</para>
            </listitem>

            <listitem>
              <para>DEBUG - detailed information for the developer.</para>
            </listitem>
          </itemizedlist>

          <para>So in the above example to increase the logging level to debug
          change the first part of the property to <emphasis>DEBUG</emphasis>
          from <emphasis>INFO</emphasis> as below:</para>

          <programlisting format="linespecific">log4j.rootLogger=DEBUG, Console, File</programlisting>

          <para>Logging should almost never be set to off, but should at least
          be set to log the errors (unsing level ERROR). Whilst developing we
          recommend that you set your basic level to INFO and switch to DEBUG
          if you need to investigate something.</para>

          <para>Setting the logging level via the properties file applies that
          level at startup and cannot be changed using the properties, ie,
          that level will be used to filter all logged event while the system
          is running. If you are using the Skylark viewer, however, you can
          use the debug options to change the logging level on the client at
          any time. By using Ctrl-Shift-right-click on the desktop you will be
          shown the debug menu and see the following options:-</para>

          <mediaobject>
            <imageobject>
              <imagedata align="left" fileref="images/logging-debug.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>

          <para>The greyed-out option indicates the current level. Selectiing
          one of the other levels will change the logging to that
          level.</para>
        </sect3>

        <sect3>
          <title>Limiting logging by class</title>

          <para>As well as limiting the level of events that are logged, we
          can also specify which classes we are interested in capturing log
          events for. In Log4j events are organised by loggers, which are set
          up programmatically, but as we create a logger for each class we
          talk about classes.</para>

          <para>To change the levels of events captured according to the class
          where the log event was created we can class based requirements
          after the root logger is specified. To set a logging level for a
          class add a property in the form</para>

          <programlisting format="linespecific">log4j.logger.&lt;package to log&gt;=&lt;level for package&gt;
log4j.logger.&lt;class to log&gt;=&lt;level for class&gt;</programlisting>

          <para>Events for the specified packages or class will be logged at
          the specified level, overriding the root level set up first. So for
          example the following configuration:</para>

          <programlisting format="linespecific">log4j.rootLogger=WARN, Console

log4j.logger.org.apache.isis.object=INFO
log4j.logger.org.apache.isis.object.reflect=DEBUG
log4j.logger.org.apache.isis.object.persistence=DEBUG

log4j.logger.org.apache.isis.object.loader.ObjectLoaderImpl=OFF</programlisting>

          <para>will capture warning and errors for all classes (as defined by
          the root logger), and information messages for those classes whose
          package begins with <classname>org.apache.isis.object</classname>.
          In addition those classes beginning with
          <classname>org.apache.isis.object.reflect </classname>or
          <classname>org.apache.isis.object.persistence</classname> will have
          their debug events captured as well. Finally, the class
          <classname>ObjectLoader</classname> will have all of its events
          ignored.</para>

          <para>It is important to make use of this feature when using the
          Skylark viewer as it logs events about it rendering. In Java
          rendering the screen (via the
          <methodname>paint(Graphics)</methodname> method) happens very often
          and can cause the logs to be swamped with superflous events. The
          logger for these events are prepended with the text 'ui.' so we can
          disable all of these events across all the viewing classes by adding
          the following to the properties:</para>

          <programlisting format="linespecific">log4j.logger.ui=OFF</programlisting>
        </sect3>

        <sect3>
          <title>Writing XML log files</title>

          <para>By writing out the logs to a file in XML rather than as text
          allows you to look at the log using Chainsaw, a Log4j viewer. This
          tool allows you to quickly look at events in specific classes and
          hide events that are of no interest by setting up simple
          conditions.</para>

          <para>To write out an XML file the same appender as before is used,
          but the layout is changed. The following configuration logs all
          events (DEBUG and greater) to a file with an XML layout.</para>

          <programlisting format="linespecific">log4j.rootLogger=DEBUG, XmlFile

log4j.appender.XmlFile=org.apache.log4j.FileAppender
log4j.appender.XmlFile.file=isis.log.xml
log4j.appender.XmlFile.layout=org.apache.log4j.xml.XMLLayout
log4j.appender.XmlFile.append=false</programlisting>
        </sect3>

        <sect3>
          <title>Writing HTML log files</title>

          <para>HTML files can be viewed in a web browser and will display
          nicely in most email clients. Change the appender to use the
          <classname>HTMLLayout</classname> class.</para>

          <programlisting format="linespecific">log4j.appender.Snapshot.layout=org.apache.log4j.HTMLLayout</programlisting>
        </sect3>
      </sect2>

      <sect2>
        <title>Using logging to get help</title>

        <para>When you are working with someone else it is often useful to
        send details of what is happening including screenshots, code, and
        logs. To make the other person's life easier provide as much
        information as possible:</para>

        <itemizedlist>
          <listitem>
            <para>Detail the version of the framework and the platform (Java
            or .Net) you are using</para>
          </listitem>

          <listitem>
            <para>Describe the problem in detail</para>
          </listitem>

          <listitem>
            <para>Provide screenshots (as a <filename class="directory"
            moreinfo="none">.gif</filename> or <filename class="directory"
            moreinfo="none">.png</filename>, avoid jpegs and Word documents)
            that shows the problem</para>
          </listitem>

          <listitem>
            <para>Provide log files from both the client and the server in an
            XML format so they can be viewed using Chainsaw</para>
          </listitem>

          <listitem>
            <para>Include your contact details, preferrably you email
            address</para>
          </listitem>
        </itemizedlist>

        <para>Collate all this information ensuring each file is clearly
        named. Then zip up (or tar) the whole set (as the logs, in particular,
        can be huge) and email the compressed file.</para>
      </sect2>

      <sect2>
        <title>Adding logging to your code</title>

        <para>It is recommended that you also add logging to your code,
        particularly if you are developing a component or extending the
        framework in some way. This way you will be able to see the
        interaction of your classes with those of the NOF. The following lays
        out how the framework uses Log4j, and hence how you should use it to
        be consistent.</para>

        <para>Simple ensure that any class that does any logging makes a
        <classname>Logger</classname> available. By convention the name is
        always <varname>LOG</varname>. The name of the logger should be the
        name of the class in its fully qualified form. To make this easy use
        the constructor that takes a <classname>Class</classname> object and
        pass in your class using as shown here. Don't forget to add an import
        to <classname>org.apache.log4j.Logger</classname>, not the class of
        the same name in the NOF or in Java itself.</para>

        <programlisting format="linespecific">private final static Logger LOG = Logger.getLogger(IsisClass.class);</programlisting>

        <para>Where you wish to add log message add a statement like the
        following, deciding first what level the event should be classified as
        (see above); the available methods are <methodname>debug</methodname>,
        <methodname>info</methodname>, <methodname>warn</methodname>,
        <methodname>error</methodname> and
        <methodname>fatal</methodname>.</para>

        <programlisting format="linespecific">LOG.debug("mark as dirty " + object);

LOG.error("failed to create instance of " + this, e);</programlisting>

        <para>The first statement in this example contains just a message,
        while the second version logs a message and, separately, the complete
        stack trace.</para>

        <sect3>
          <title>Making you classes useful in logs</title>

          <para>To make the most of logging, even if you don't log anything in
          you code, make sure that you declare a
          <methodname>toString</methodname> method in each of you classes.
          This way when a log message is created that references your object
          the message will show your object in detail rather than like
          this:</para>

          <screen format="linespecific">MyObject@33D4</screen>

          <para>A suitable toString can cause it to be rendered more usefully
          such as:</para>

          <screen format="linespecific">MyObject [name=windows,size=34x20]</screen>

          <para></para>

          <para></para>

          <para></para>

          <para></para>

          <para></para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Component loggers</title>

      <para>The NOF provides a set of component loggers that specifically log
      the use of a component, adding additional log messages to the Log4j log
      or write out to a separate file. Additional logger can also be defined
      for other components. These logger are designed to log the parameters
      passed to and the the results return from the requests to a component
      and tend to be more verbose than the general logging just discussed. At
      present the following components have loggers available:-</para>

      <itemizedlist>
        <listitem>
          <para>The object persistor -
          <classname>ObjectPersistorLogger</classname></para>
        </listitem>

        <listitem>
          <para>The object store -
          <classname>ObjectStoreLogger</classname></para>
        </listitem>

        <listitem>
          <para>The distibution interface -
          <classname>DistributionLogger</classname></para>
        </listitem>
      </itemizedlist>

      <para>To set up a logger create an instance of it passing in the object
      you are logging. Then use the logger instance in place of the original
      component. The constructors for each of the loggers are overloaded so
      they take a component to decorate and possibly a file name. If the
      filename is specified then the logging is done to that file. If there is
      no file name then the events are logged via Log4j. For example the
      object store persistor would logged by replacing:</para>

      <programlisting format="linespecific">ObjectAdapterPersistor persistor = new ObjectStorePersistor();
isis.setObjectPersistor(persistor);</programlisting>

      <para>with this, which will log request to the persistor the <filename
      class="directory" moreinfo="none">sever-persistor.log</filename>
      file:</para>

      <programlisting format="linespecific">ObjectAdapterPersistor persistor = new ObjectStorePersistor();
persistor = new ObjectManagerLogger(persistor, "server-persistor.log");
isis.setObjectPersistor(persistor);</programlisting>

      <para>Please note that the log files, when used, are created when the
      logger is instantiated and will overwrite any exsiting file. This is not
      normally a problem as we are interested in the activities during an
      entire session. However on a stateless server where the component is
      being recreated each time the continual recreation of the file could be
      a problem.</para>

      <sect2>
        <title>Defining a logger</title>

        <para>To define a logger extend the Logger class, providing a suitable
        constructor, and implement the
        <methodname>getDecoratedClass</methodname> so it passes back the
        <classname>Class</classname> object of the class being decorated (this
        allows the Log4j logger to log messages as that class rather than as a
        separate class). Within the subclass you can use the following
        methods:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis> <methodname>void log(String message)</methodname>
            </emphasis></para>

            <para>output a log entry with the specified message.</para>
          </listitem>

          <listitem>
            <para><emphasis> <methodname>void log(String message, Object
            result)</methodname> </emphasis></para>

            <para>output a log entry with the specified message and the
            specified result. This is useful when needing to show both the
            entry and exit states, or the paramters and the return
            value.</para>
          </listitem>

          <listitem>
            <para><emphasis> <methodname>void close()</methodname>
            </emphasis></para>

            <para>closes the file that is being written to.</para>
          </listitem>
        </itemizedlist>

        <para></para>

        <para></para>

        <para></para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>The Dump Utility</title>

      <sect2>
        <title>The Dump Utility</title>

        <para>The <classname>org.apache.isis.object.Dump</classname> class
        provides a simple way out outputting the details of adapters and
        specifications. The two <methodname>specification </methodname>methods
        detail the specified <classname>ObjectSpecification</classname> as
        follows:-</para>

        <screen format="linespecific">Full Name: bom.Location
Short Name: Location
Plural Name: Locations
Singular Name: Location

Abstract: false
Lookup: false
Object: true
Value: false
Persistable: User Persistable
Superclass: java.lang.Object
Subclasses: empty
Interfaces: bom.Common
Fields
    OneToOneAssociationImpl@1408a92 [type=VALUE,id=type,label='Type',derived=false,type=Option]
    :
    :</screen>

        <para>The two <methodname>object</methodname> methods detail the
        specified <classname>Isis</classname> object as follows:-</para>

        <screen format="linespecific">Specification: bom.Location
Class: bom.Location
Adapter: org.apache.isis.object.defaults.PojoAdapter
Hash: #dada24
Title: test, Fort Worth
Object: bom.Location@18e4327
OID: OID#2F
State: ResolveState@1e1be92 [name=Resolved,code=PR]
Version: LongNumberVersion#1 20051118-025400170
Icon: null
Persistable: User Persistable</screen>

        <para>The two <methodname>graph</methodname> methods detail the
        specified <classname>Isis</classname> object as follows, showing each
        adapter, it associated objects and values:-</para>

        <screen format="linespecific">PojoAdapter@dada24 [PR:OID#2F,specification=Location,version=LongNumberVersion#1 20051118-025400...
    +--type: POJO BusinessValueAdapter: One
    +--knownas: POJO TextStringAdapter: test
    +--streetaddress: POJO TextStringAdapter: address
    +--city: PojoAdapter@b51404 [PR:OID#C,specification=City,version=LongNumberVersion#1 ...
    |    +--name: POJO TextStringAdapter: Fort Worth
    +--customer: PojoAdapter@92dcdb [PR:OID#1C,specification=Customer,version=LongNumberVers...
    |    +--firstname: POJO TextStringAdapter: Richard
    |    +--lastname: POJO TextStringAdapter: Pawson
    |    +--phonenumbers: VectorCollectionAdapter@1d381d2 [PR:-,specification=Vector,version=...
    : 
    :</screen>

        <para></para>

        <para></para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Property naming conventions</title>

      <para>Properties used within the framework start with 'isis', which is
      available from the <literal moreinfo="none">Configuration.ROOT</literal>
      constant. Next is the category and optionally a component. Finally is
      the property name (which can be as many levels as needed) for the
      component. Examples are:</para>

      <programlisting format="linespecific">isis.viewer.cli.log
isis.services.prefix
isis.viewer.dnd.specification.view
isis.exploration.users
isis.viewer.html.header</programlisting>
    </sect1>
  </chapter>

  <!-- main content -->

  <part id="prt.CoreModules">
    <title>Core Framework Modules</title>

    <partintro>
      <abstract>
        <para>The modules that make up the core framework.</para>
      </abstract>

      <para>This part of the guide goes through each of the modules that make
      up the core framework.</para>

      <para></para>
    </partintro>

    <chapter>
      <title><emphasis>Test Support</emphasis> Module</title>

      <para>The testsupport module holds helper classes to support writing
      unit tests in either JUnit or JMock.</para>

      <para>It should only ever be added as a dependency with a scope of
      test.</para>

      <para></para>

      <para></para>

      <para></para>
    </chapter>

    <chapter>
      <title><emphasis>Common</emphasis> Module</title>

      <abstract>
        <para>***</para>
      </abstract>

      <para></para>

      <para></para>

      <para></para>

      <sect1>
        <title></title>

        <para></para>

        <para>The core commons module provides a set of common utilities and
        language extensions for use across the rest of the framework.</para>

        <para>It also defines a number of small APIs that are used
        throughout:</para>

        <itemizedlist>
          <listitem>
            <para>a set of interfaces for defining Components and their
            scope</para>
          </listitem>

          <listitem>
            <para>a debug framework</para>
          </listitem>

          <listitem>
            <para>an Ensure API</para>
          </listitem>

          <listitem>
            <para>a set of Hamcrest Matchers</para>
          </listitem>

          <listitem>
            <para>a ResourceStream API</para>
          </listitem>

          <listitem>
            <para>a Future API</para>
          </listitem>

          <listitem>
            <para>an Encoding API</para>
          </listitem>

          <listitem>
            <para>a Configuration Builder API</para>
          </listitem>

          <listitem>
            <para>definition of an AuthenticationSession</para>
          </listitem>
        </itemizedlist>

        <para></para>

        <para></para>

        <para>Package dependencies:</para>

        <para></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/common/composition-perspective.png"
                       scale="60" />
          </imageobject>
        </mediaobject>

        <para></para>

        <para></para>

        <para>Architecture layering:</para>

        <para></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/common/architecture-perspective.png"
                       scale="60" />
          </imageobject>
        </mediaobject>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Encoding</title>

        <para></para>

        <para></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/common/encoding-classdiagram.png"
                       scale="30" />
          </imageobject>
        </mediaobject>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Loading configurations</title>

        <para>Configurations are loaded by a
        <classname>ConfigurationBuilder</classname>. The builder should
        immediately create a <classname>Configuration</classname> object, and
        then can be used to add more confiration properties to the
        configuration object, ie properties cannot be added the
        <classname>Configuration</classname> object directly. Properties can
        loaded via the <classname>ConfigurationBuilder</classname> either from
        files, via Properties object, or as key-value pairs. When files are
        loaded they can be specified, via the addConfigurationFile(file name,
        ensure loaded) method, as mandatory or optional. If mandatory then the
        file must exist.</para>

        <para>Although properties can be accessed from the
        <classname>Configuration</classname> object at any point, it should be
        remembered that the properties that it contains only include
        properties that have been loaded so far.</para>

        <para>The default property loader (ConfigurationBuilderDefault) reads
        the file <filename>isis.properties</filename> from the directory
        <filename>config</filename>. The directory can be changed by
        specifying it as the parameter of the single parameter constructor.
        This loader uses Java style property files of the form</para>

        <programlisting>name=value
name2=value2 </programlisting>

        <para></para>

        <para></para>

        <para></para>

        <para>Using properties specified in the configuration files is done by
        get the <classname>IsisConfiguration</classname> singleton from the
        context and using one of the lookup methods to get a value, as the
        example below shows. The <literal
        moreinfo="none">Configuration.ROOT</literal> constant provides the
        base property name ("isis."). If no value is found with the specified
        property name exists then null (or 0 or false) will be
        returned.</para>

        <programlisting format="linespecific">String formatRequired = IsisContext.getConfiguration().getString(Configuration.ROOT + "value.format.date");</programlisting>

        <para></para>
      </sect1>

      <sect1>
        <title>Configuration</title>

        <para></para>

        <para>If you have a look at Installer#getConfigurationResources(),
        you'll see that the javadoc explains how which property files we look
        for to build up the configuration; each component's Installer adds its
        own set of property files. The implementaiton of this,
        InstallerAbstract, will indicate that the configurations
        xxx.properties and xxx_yyy.properties should be searched, where "xxx"
        is the installer type (eg "persistor") and "yyy" is the name of the
        implementation (eg "sql").</para>

        <para>Note that the type comes from the subclass of Installer for that
        module; in the case of a persistor, it'll implement
        PersistenceMechanismInstaller, where
        PersistenceMechanismInstaller.TYPE = "persistor". This "type" is also
        used to look for the key; and is done</para>

        <para></para>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Installers</title>

        <para></para>

        <note>
          <para>TODO: discuss Installer architecture; do indicate that this
          stuff is going to change with JSR-299</para>
        </note>

        <para></para>
      </sect1>
    </chapter>

    <chapter>
      <title><emphasis>Metamodel</emphasis> Module</title>

      <para></para>

      <para></para>

      <sect1>
        <title></title>

        <para></para>

        <para></para>

        <para>The core metamodel module defines the interfaces and classes
        that make up the Apache Isis metamodel. The metamodel is used in
        numerous ways, including:</para>

        <itemizedlist>
          <listitem>
            <para>by viewers to obtain information about the domain objects,
            so that they can be rendered in a generic object-oriented user
            interface;</para>
          </listitem>

          <listitem>
            <para>by object stores (the default and some of the alternatives)
            to determine which data is to be persisted;</para>
          </listitem>

          <listitem>
            <para>by remoting, to marshall domain objects automatically
            between different tiers;</para>
          </listitem>

          <listitem>
            <para>by the core runtime, to provide the ability to provide XML
            Snapshots (through the <classname>XmlSnapshot</classname> utility
            class). The metamodel module does not itself define the
            programming model conventions; that is the responsibility of the
            core progmodel.</para>
          </listitem>
        </itemizedlist>

        <para></para>
      </sect1>

      <sect1>
        <title>Architecture Diagram</title>

        <para></para>

        <para></para>

        <screenshot>
          <screeninfo>Top-level Architecture Diagram with SpecLoader
          expanded</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/metamodel/architecture-diagram-top-level-with-specloader-expanded.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>

        <screenshot>
          <screeninfo>Composition Diagram</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/metamodel/composition-diagram-top-level.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>
      </sect1>

      <sect1>
        <title>Reflection</title>

        <para></para>

        <para></para>

        <para>To make the domain objects useful within the framework the
        objects' public interfaces must be exposed. Reflection capabilities
        are used to determine what fields or properties an object has, what
        behaviour it can offer, and to find other information such as the
        object's title, a suggested order of it fields, when the actions can
        or can't be used. The details about this interface are recorded in an
        instance of <classname>ObjectSpecification</classname>. As each class
        of domain object is loaded into the system introspection is performed
        and an instance of <classname>ObjectSpecification</classname> is
        generated. That specification object is subsequently available from
        any object adapter (using the
        <methodname>ObjectAdapter.getSpecification</methodname> method) for
        that type of domain object; or it can be retrieved directly, by name
        or class, from the <classname>ObjectSpecificationLoader</classname>
        instance (obtained from the <classname>Isis</classname>
        repository).</para>

        <para>Through an object's <classname>ObjectSpecification</classname>
        instance the rest of the NOF can find out the fields that an object
        has, the methods it offers, the title to use to identify the object,
        and other details about the object. These are used normally used by
        the implementations of ObjectAdapter etc when another component ask
        the adapter for details about another object. For example For example
        the statement <code>adapter.getField(no.getFields()[0])</code> would
        retrieve the first field in the domain object held by the Isis
        referenced by <code>adapter</code>.</para>

        <sect2>
          <title>How it Works</title>

          <para>When a domain object is used within the NOF the
          <classname>ObjectSpecificationLoader</classname> instance is asked
          for the <classname>ObjectSpecification</classname> for the domain
          object's class (by name or <classname>java.lang.Class</classname>
          object). For performance reasons these objects are normally cached
          and if the class has previously been introspected then the cached
          version would be returned. The first time that class is requested
          however the loader is responsible for performing the introspection
          and creating a complete
          <classname>ObjectSpecification</classname>.</para>

          <para>For each field that the reflector recognises the loader
          creates either a <classname>OneToOneAssociation</classname> object
          for a value field or a reference field, or a
          <classname>OneToManyAssociation</classname> object for a collection
          or array. Using the field objects the NOF can access or change the
          values and references in the domain object. The fields can also be
          used by the NOF to find out the field name, if the fields are
          visible and whether it can be modified.</para>

          <para>For each action method that the reflector recognises the
          loader must create an <classname>Action</classname> object. Using
          the action object the NOF can invoke the method on the domain
          object. The action object also can be used by the NOF to find out
          the action's name, whether it is visible and whether it can be
          executed.</para>

          <para>In addition to the fields and actions the specification must
          can also: return the various forms of class name (singular; plural;
          short; and full); retrieve a title from, or generate a title for,
          the domain object; flag the type of object (abstract, lookup,
          object, value, and whether persistable); refer to its superclass,
          any inteferfaces it implements and any subclasses; and allow objects
          to marked/cleared as being dirty.</para>
        </sect2>

        <sect2>
          <title>Installation</title>

          <para>To set up the NOF to use a reflection mechanism the
          <classname>Isis</classname> repository must be given a
          <classname>ObjectSpecificationLoader</classname> instance before the
          repository is initialised. This can be done using the repository's
          static <methodname>setSpecificationLoader</methodname> method. For
          example, the following sets the NOF up to use the basic
          reflector.</para>

          <programlisting>ObjectSpecificationLoader loader = new
        JavaSpecificationLoader();
        Isis.setSpecificationLoader(loader);</programlisting>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Reflector</title>

        <para></para>

        <para>The reflector provides the NOF with two distinct facilities.
        First it provides the framework with a model of the domain objects
        that it will be using, and second, it provides a mechanism for the
        framework and the clients of the framework to access and maniplate the
        domain objects (the framework and its clients should never interact
        with the domain objects directly).</para>

        <para>This section is divided into two. The first part looks at how
        the reflector is used by the framework and its clients, while the
        second part looks at how the reflector itself works and how it can be
        extended.</para>
      </sect1>

      <sect1>
        <title>ObjectAdapter and ObjectSpecification</title>

        <para></para>
      </sect1>

      <sect1>
        <title>Adapters and OIDs</title>

        <para>Isis wrap each domain object in the system. The rest of the
        framework does not normally work with the domain objects directly, but
        via these proxies. The proxies provide access to the tools of the
        reflector by providing a <classname>ObjectSpecification</classname>
        for the object's class and to access additional information about the
        domain object. The specification is accessed via the
        <methodname>getSpecification()</methodname> method and is then used
        with the proxy as a mechanism to access and manipulate the domain
        object. Other key methods on the proxy allow access to the: object
        identifier, via the getOid() method to get its unique OID; version
        information, via <methodname>getVersion()</methodname> to get it
        current Version object; and its lazy loaded state, via the
        <methodname>getResolved()</methodname> state returning the
        <classname>ResolvedSate</classname> object reflecting how complete the
        object is.</para>

        <sect2>
          <title>OIDs</title>

          <para></para>

          <para></para>

          <para>*** An Oid is an object identifier, assigned by the runtime.
          For persisted objects it is value is assigned by the object store,
          but for transient objects the framework still assigns an Oid also
          (and will update the Oid if the object is persisted).</para>

          <para></para>

          <para></para>

          <para>Any domain object that is not a composite part of another
          domain object must have an identity so that the references between
          objects can be persisted for future access and transferred between
          VMs. The OID must be unique so that a one to one mapping can be
          maintained between an <classname>Oid</classname> and a
          <classname>ObjectAdapter</classname>, and hence a domain object.
          Using the OID the client and server can have copies of the same
          objects and identify those objects remotely and persistently. The
          identity is held by the proxy is an <classname>Oid</classname>
          object. The OID for a specific domain object is unique and will not
          change other than when the object is persisted. Until that point it
          has a transient OID that is morphed into the persistent OID when the
          object is persisted. This is so that the transient objects can be
          passed back and forth between client and server, and once persisted
          both ends can match the identity of the previously transient object
          with the identity of the now persistent object.</para>

          <para>When an object is made persistent (typically via the persistor
          and specifically via <classname>OidGenerator</classname>) its OID is
          changed to reflect this and also to allow the persistor to provide
          its own identifier (as is necessary when using natural keys in a
          relational database backend). So the
          <methodname>isTransient()</methodname> state changes from
          <code>true</code> to <code>false</code> while the internal id state
          might be changed. More visibly, the previous state of the OID is
          copied so that <methodname>getPrevious()</methodname> now returns a
          copy of the original OID instead of null and
          <methodname>hasPrevious()</methodname> will return true.</para>

          <para>When a OID with a previous OID is used to retrieve an object
          from the persistor the persistor first checks the OID and if
          <methodname>hasPrevious()</methodname> returns <code>true</code> the
          original tranisent object is retrieved, that object is removed from
          the cache, its OID is updated (via the
          <methodname>copyFrom(Oid)</methodname> method) and then it is
          returned to the cache. This results in the newly persisted object
          having the new persistent OID and it being accessible as such from
          the cache. At this point the original version's transient state will
          no longer be recognised.</para>
        </sect2>

        <sect2>
          <title>ResolveState</title>

          <para></para>

          <para></para>
        </sect2>

        <sect2>
          <title>Version</title>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>ObjectMember hierarchy</title>

        <para></para>
      </sect1>

      <sect1>
        <title>FacetedMethod</title>

        <para>aka ObjectMemberPeer</para>

        <para></para>
      </sect1>

      <sect1>
        <title>Similarity between Properties and Parameters</title>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>FacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>MethodFilteringFacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>MethodPrefixBasedFacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>PropertyOrCollectionIdentifyingFacetFactory</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>InteractionAdvisor</title>

        <para></para>

        <para></para>

        <sect2>
          <title>HidingInteractionAdvisor</title>

          <para></para>
        </sect2>

        <sect2>
          <title>DisablingInteractionAdvisor</title>

          <para></para>
        </sect2>

        <sect2>
          <title>ValidatingInteractionAdvisor</title>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>RuntimeContext</title>

        <para></para>
      </sect1>

      <sect1>
        <title>PropertyOrCollectionIdentifyingFacetFactory</title>

        <para></para>
      </sect1>

      <sect1>
        <title>Reflector Properties</title>

        <sect2>
          <title>FacetDecorator</title>

          <para></para>

          <para>*** gonna try to get rid of.</para>

          <para></para>

          <para>The reflector facet-decorators property specifies a list of
          <classname>FacetDecoratorInstaller</classname> objects that should
          be installed and registered with the reflector. These decorators
          decorate specific facets of the metamodel, allowing it change or
          modify their behaviour. This allows us to add internationalization,
          help look up and other features. Although transaction management is
          also achieved by decorating the reflector this is done automatically
          and does not need to be specified using this property. The following
          example adds a single decorator that provide internationalization
          via resource files.</para>

          <programlisting format="linespecific">isis.reflector.facet-decorators=resource-i18n</programlisting>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Using the reflector</title>

        <para></para>

        <para>When the framework starts up it is told about the service
        objects that are provided by DOM and any referenced class is then
        introspected to build up the model of the known domain objects. Any
        other domain classes that are subsequently used will also be reflected
        upon as they are used (this will happen when there are classes that
        have no direct references from the service objects, typically because
        the references are for abstract types and not concrete ones). With the
        model in place clients can then determine how to interact with the
        domain model. Each domain class that is in use by the framework has a
        corresponding <classname>ObjectSpecification</classname> detailing the
        properties and structure of the domain class. Properties include the
        classes variouse names (full, short, singular and plural names), a
        description and flags indicating various features. The structure of
        the object includes related classes (superclass, subclasses and
        implemented interfaces), properties and actions. In additions to these
        common elements there are also a set of <classname>Facet</classname>s
        associated with each specification that provide additional information
        about and behaviour for the class.</para>

        <para></para>

        <remark>Classes: MemberIdentifier</remark>

        <sect2>
          <title>Specifications</title>

          <para>The specification is typically retrieved from an adapted
          domain object via the
          <methodname>ObjectAdapter.getSpecification()</methodname> method,
          but can also be looked up via the
          <emphasis>ObjectReflector.loadSpecification()</emphasis> method (for
          a class object or class name) as follows</para>

          <programlisting>ObjectSpecification spec;
spec = IsisContext.getReflector().loadSpecification(Book.class);
String screenName = spec.getSingularName();</programlisting>

          <para></para>
        </sect2>

        <sect2>
          <title>Properties</title>

          <para></para>

          <para></para>

          <para>From the specification an array of every available property
          can be access via the <methodname>getProperties()</methodname>
          method and an individual property can be accessed via the
          <methodname>getProperty(String)</methodname> method, where the sole
          parameter is the the identifier of the property. For the included
          introspector the property identifier will be the name of the
          property method with the <emphasis>get</emphasis> prefix removed,
          and the first character of the remaining string converted to
          lowercase, so <methodname>getCustomerId()</methodname> become
          <emphasis>customerId</emphasis>. Typically the complete list of
          properties is used for things like persistence and remoting, user
          interfaces need to consider what properties they show to avoid
          making hidden or unauthorised properties visible.</para>

          <para>To gather a selective set of properties for a specification
          you can use the .... method.</para>

          <para>All properties detailed are as
          <classname>ObjectAssociation</classname> objects, specifically
          <classname>OneToOneAssociation</classname> and
          <classname>OneToManyAssociation</classname> for value and reference
          objects and collections respectively. Each association object knows
          what type it for (<methodname>getSpecification()</methodname>), can
          provide its name, description and help text, determine whether it
          should be visible and useable, provides various flags indicating its
          usage and provides access to the facets that exist a the property
          level.</para>

          <programlisting>ObjectAssociation[] properties = spec.getProperties();
for (int i = 0; i &lt; properties.length; i++) {
    String name = properties[i].getName();
    boolean mustEnter = properties[i].isMandatory();
    :
    :
}</programlisting>

          <para>To selectively get hold of properties the
          <methodname>getProperties(ObjectAssociationFilter)</methodname>
          method should be used. The
          <classname>ObjectAssociationFilter</classname> class allows us to
          set up a search filter to get properties based on name, type, facet
          etc. Predefined instances and factory methods are available from the
          <classname>Filters</classname> and
          <classname>DynamicFilters</classname> classes or you can extend the
          <classname>ObjectAssociationFilter</classname> class to create your
          own. Two useful predefined versions are the
          <varname>Filters.STATICALLY_VISIBLE</varname> instance and the
          <methodname>DynamicFilters.dynamicallyVisible(ObjectAdapter)</methodname>
          factory method. Using these filters you can find the properties that
          are visible on a particular type and for a particular object, in
          other words excluding those that where hidden during definition
          (using anotations etc) and those that are programatically hidden
          depending on role or state. Typically views are created using only
          dynamically visible properties so hidden fields are not visible and
          do not have any screen space reserved form them. In particular views
          all the possible properties might need space although the final
          propert might not be shown, a good example of this is table views
          where each statically visible property has a column created for it,
          while for each object shown in table only the dynamically visible
          properties for that object are show (ie there may be blank
          cells).</para>

          <para></para>

          <programlisting>ObjectAssociationFilter filter = DynamicFilters.DynamicFilters.dynamicallyVisible(object);
ObjectAssociation[] properties = object.getSpecification().getProperties(filter);
for (int i = 0; i &lt; properties.length; i++) {
    addField(properties[i].getName(), createFieldView(properties[i]));
}</programlisting>

          <para></para>

          <para></para>
        </sect2>

        <sect2>
          <title>Actions</title>

          <para></para>

          <para></para>

          <para></para>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Facets</title>

        <para>*** eliminate overlap with above</para>

        <para></para>

        <para></para>

        <sect2>
          <title>PropertiesAndCollectionsIdentifyingFacet</title>

          <para></para>
        </sect2>

        <sect2>
          <title>InteractionAdvisors</title>

          <para></para>

          <sect3>
            <title>HidingInteractionAdvisor</title>

            <para></para>
          </sect3>

          <sect3>
            <title>DisablingInteractionAdvisor</title>

            <para></para>
          </sect3>

          <sect3>
            <title>ValidatingInteractionAdvisor</title>

            <para></para>

            <para></para>
          </sect3>
        </sect2>
      </sect1>

      <sect1>
        <title>MetaModel Validator</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>ProgrammingModel API</title>

        <para></para>

        <para><classname>org.apache.isis.core.metamodel.progmodel.ProgrammingModel</classname></para>

        <para></para>

        <para>Isis also allows you to develop your domain application in
        Groovy. This support should be considered experimental for the moment;
        although the viewers and fixtures/in-memory object store work fine, it
        has not been fully tested out with other object stores. Further
        details are available in the
        {{{./support/languages/groovy/index.html}groovy}} module.p</para>

        <para></para>

        <para>x-ref chapter in part 2</para>

        <para></para>
      </sect1>
    </chapter>

    <chapter>
      <title><emphasis>Progmodel</emphasis> Module</title>

      <abstract>
        <para>***</para>
      </abstract>

      <para></para>

      <sect1>
        <title></title>

        <para></para>

        <para>The core progmodel provides a set of reusable elements
        (implementations of the <classname>FacetFactory</classname> API) that
        can be reused to make up a programming model.</para>

        <para>Most of those within this module are in fact used in the default
        programming model, defined by the default progmodel module. They are
        defined within core, however, to allow custom programming models
        (perhaps extending or trimming back the default programming model) to
        be defined.</para>

        <para></para>

        <para></para>

        <screenshot>
          <screeninfo>Architecture Diagram</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/progmodel/architecture-diagram.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>

        <screenshot>
          <screeninfo>Composition Diagram (facets package)</screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/progmodel/composition-diagram-facets-package.png"
                         scale="60" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1 id="i18n-files" label="">
        <title>Internationalization resource files (I18n Facet
        Decorator)</title>

        <sect2>
          <title>Files</title>

          <para>Translated names, descriptions and help text for a specific
          language should be held in a file named in the following
          format:</para>

          <screen format="linespecific">i18n_&lt;language code&gt;_&lt;country code&gt;.properties</screen>

          <para>The language and country codes must reflect the translated
          language are ISO standards and are detailed in the <link
          linkend="locale">Locale section</link>.</para>

          <para>Theses files must be on the root of the class path, otherwise
          they cannot be loaded.</para>
        </sect2>

        <sect2>
          <title>Properties</title>

          <para>Each property can have a line for each of the name,
          description and help text. The format for each is shown
          below.</para>

          <programlisting format="linespecific">&lt;fully qualified class name&gt;.property.&lt;property name&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.property.&lt;property name&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.property.&lt;property name&gt;.help=&lt;translated help&gt;</programlisting>

          <para>The class name must be fully qualified and the property name
          is the short name provided by the reflector. All the values are case
          sensitive. The following shows the translated name and description
          being specified for the property <emphasis>fullName</emphasis>,
          which is defined by the <methodname>getFullName</methodname>
          method.</para>

          <programlisting format="linespecific">example.dom.Contact.property.fullName.name=Nom
example.dom.Contact.property.fullName.description=Le nom complet du client</programlisting>
        </sect2>

        <sect2>
          <title>Collections</title>

          <para><remark>TODO: presumably i18n is supported for collections,
          too?</remark></para>
        </sect2>

        <sect2>
          <title>Actions</title>

          <para>Actions are specified in a similar fashion to properties but
          with the keyword <emphasis>action</emphasis> instead of
          <emphasis>property</emphasis>. Parameters within an action can also
          be translated by inserting <emphasis>parameter</emphasis> and a
          number before the keyword. Each parameter must be numbered to show
          its position, starting from one (1), eg
          <emphasis>parameter1</emphasis>, <emphasis>parameter2</emphasis>
          etc.</para>

          <programlisting format="linespecific">&lt;fully qualified class name&gt;.action.&lt;action name&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.help=&lt;translated help&gt;

&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.help=&lt;translated help&gt;</programlisting>

          <para>The class name must be fully qualified and the action name is
          the short name provided by the reflector. All the values are case
          sensitive. The following shows the translated action name and
          description, and two parameter names being specified for the action
          <emphasis>createPhone</emphasis>, which is defined by the
          <methodname>createPhone</methodname> method.</para>

          <programlisting format="linespecific">example.dom.Contact.action.createPhone.name=Nouveau téléphone
example.dom.Contact.action.createPhone.parameter1.name=Indicatif de zone
example.dom.Contact.action.createPhone.parameter2.name=Nombre
example.dom.Contact.action.createPhone.description=Créez un nouveau téléphone et ajoutez-le au contact actuel</programlisting>

          <para></para>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title><emphasis>Runtime</emphasis> Module</title>

      <para></para>
    </chapter>

    <chapter>
      <title><emphasis>Webapp</emphasis> Module</title>

      <para></para>
    </chapter>
  </part>

  <part id="prt.DefaultImplementations">
    <title>APIs and Implementations</title>

    <partintro>
      <abstract>
        <para>The implementations of the core <acronym>API</acronym>s.</para>
      </abstract>

      <para>This part of the guide discusses the default implementations of
      the core <acronym>API</acronym>s. (Alternative implementations have
      their own guides).</para>

      <para></para>
    </partintro>

    <chapter id="chp.ProgrammingModelApi">
      <title>Programming Model Default Implementation</title>

      <para></para>

      <para>*** not part of core</para>

      <para></para>

      <para></para>

      <note>
        <para>At the moment this API is rather fine-grained. We intend to
        introduce higher level abstractions to make it easier to work with. We
        may also split out member sorting into a separate abstraction.</para>
      </note>

      <para></para>

      <para></para>

      <para></para>

      <note>
        <para>TODO: tidy up the following paras, were just copied/pasted in
        from APT</para>
      </note>

      <para></para>

      <para>Although we generally recommend that you stick to the conventions
      of the programmingmodel as documented in the Application Library (in
      <filename>applib</filename>), it is in fact possible to customize or
      modify these conventions. A typical case might be to make Isis support
      some of your own annotations. You'll find that some of the viewers and
      object stores also define their own extensions to the standard
      programming model.</para>

      <para></para>

      <para>The metamodel is built up using a collection of
      &lt;&lt;&lt;FacetFactory&gt;&gt;&gt;s. These are used to identify the
      classes and class members, and to decorate these class members with
      semantics. It is easy to write new &lt;&lt;&lt;FacetFactory&gt;&gt;&gt;s
      to support new programming conventions or, indeed, new languages. The
      &lt;&lt;&lt;FacetFactory&gt;&gt;&gt; API is defined in
      {{{../core/metamodel/index.html}metamodel}} module, along with
      implementations to support the Java language. The
      {{{http://groovyobjects.sourceforge.net}Groovy Objects}} sister project
      provides implementations to allow Isis to support domain objects written
      in {{{http://groovy.codehaus.org}Groovy}}.</para>

      <para></para>

      <sect1>
        <title>ProgrammingModel API and ProgrammingModelFacetsJava5
        Implementation</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>"Rolling-your-own" Programming Model</title>

        <para></para>

        <para></para>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Extending the reflector</title>

        <remark>Describe how introspection takes place</remark>

        <para></para>

        <remark>Facets (describe (including how they are defined, how they are
        used), then list all types with descriptions; Javadocs should detail
        how to use each one, but do check as working through list)</remark>

        <para></para>

        <remark>Detail how introspector determines what facets to give to each
        holder</remark>

        <para></para>

        <remark>Adding behaviour via decorator facets, eg for I18n, logging
        etc</remark>

        <para></para>

        <remark>Adding new behaviour by adding new facets, including how to
        access then</remark>

        <para></para>

        <formalpara>
          <title>Interaction utilties</title>

          <para>Other than the properties and actions that the are made
          available by the reflector the other way the reflector is used is
          via by the reflector utilities classes <remark>I don't think this
          name really reflects the intent, a better one is required</remark>
          such as InteractionUtils and CollectionUtils. These helper classes
          generally make use of the <classname>Facet</classname>s on a
          <classname>FacetHolder</classname> to interact with the domain
          model. For example the <methodname>size(ObjectAdapter)</methodname>
          method on the <classname>CollectionFacetUtils</classname> class will
          determine the size of the collection without having to resort to
          finding the right facet and using that yourself.</para>
        </formalpara>

        <para>These utility classes then make use of the related facets (got
        singularly or a set via the
        <methodname>getFacets(FacetFilter)</methodname> method that typically
        search for facets using the mix-in interfaces that are used to mark
        the facets for this kind of use) which are then all process on behalf
        of the client. For example, the <methodname>isVisible</methodname>
        method get all the facets to do with hidding things by filtering for
        facets that <classname>are of the type
        HidingInteractionAdvisor</classname>. This interface is implemented by
        hide-related facets</para>

        <para></para>

        <para></para>

        <para><classname>DisablingInteractionAdvisor</classname>,
        <classname>HidingInteractionAdvisor</classname> and
        <classname>ValidatingInteractionAdvisor</classname> interfaces are
        used to bring together all facets for disabling, hiding and validating
        properties, actions and parameters. These each provide a single method
        for for checking a proposed interaction. These are then used by the
        <classname>InteractionUtils</classname> class to provide all the
        domain related interaction checking behaviour to the clients of the
        reflector</para>

        <para></para>
      </sect1>

      <sect1>
        <title>How to write your own Facet Decorator</title>

        <para></para>

        <para></para>
      </sect1>

      <sect1>
        <title>Configuring I18N</title>

        <para>x-ref core.progmodel</para>

        <para></para>

        <para></para>
      </sect1>
    </chapter>

    <chapter id="chp.SecurityApi">
      <title>Security API</title>

      <abstract>
        <para>This chapter covers the authentication and authorization
        APIs</para>
      </abstract>

      <para></para>

      <para></para>

      <para></para>

      <para>Apache Isis supports authentication  and role-based authorization.
      Within the framework the user is represented by a
      <classname>Session</classname> object. From the session object you can
      get the name of the user and their roles.</para>

      <para>The session is used within the distribution mechanism and the
      security manager. The security manager uses the session to determine if
      a user can access or manipulate an object member. The distribution
      mechanism passes the session to the server so the server knows which
      user is accessing it.</para>

      <para></para>

      <para></para>

      <para></para>

      <para></para>

      <para>As with authentication, authorization may be executed via a file,
      LDAP, or database. If no authorization mechanism is specified, all
      domain calls, methods and properties will be available to all
      users.</para>

      <para></para>

      <para></para>

      <note>
        <para>TODO: tidy up the following paras, were just copied/pasted in
        from APT</para>
      </note>

      <para><emphasis></emphasis></para>

      <para><emphasis>Apache Isis</emphasis> applications support
      authentication ("who are you"?) and authorization ("what can you do?").
      This allows the set of functionality to be restricted based upon the
      user's role, with no security knowledge needing to be embedded within
      the domain objects. The API is defined in
      {{{../core/runtime/index.html}runtime}}, along with two implementations,
      one file-based and one using LDAP.</para>

      <para></para>

      <para></para>

      <para>An <classname>Authoriser</classname> processes an
      <classname>AuthorizationRequest</classname> and if granted generates a
      <classname>Session</classname> object to represent the user.</para>

      <para></para>

      <para></para>

      <para>There is an optional capability to authorise the visibility and
      usability of fields independently. Thus a field may be visible to
      certain roles but not editable. In order to configure this against a
      authorization a flag must be added as follows.</para>

      <para></para>

      <para></para>

      <sect1>
        <title>Capturing authorization requirements automatically</title>

        <para>As a tool for helping to configure the initial security settings
        there is a 'learn' property.</para>

        <programlisting format="linespecific">isis.authorization.learn=true</programlisting>

        <para>When this is present and set, all methods will be authorised for
        all roles. However as each method is accessed through the user
        interface authorization will be configured for that method and the
        current role. Configuration will be saved in either the file (saved on
        shutdown), database table or LDAP security settings depending upon the
        reflector setup.</para>

        <para>The settings can then be modified to conform to the required
        security settings.</para>

        <para></para>

        <para></para>
      </sect1>
    </chapter>

    <chapter id="chp.DeployingIsisApplications">
      <title>Deployment Principles</title>

      <abstract>
        <para>*** The principles for deploying an <emphasis>Isis</emphasis>
        application.</para>
      </abstract>

      <para>Assuming that you have developed your domain model and tested it
      as a standalone prototype, this part of the guide describes the basic
      deployment options.</para>

      <para>Alternative implementations (most notably, remoting for
      client/server) that allow for different deployments have their own
      guidance on deployment. The same is also true for viewers that allow for
      different deployments (eg a viewer that supports a mobile phone or
      Eclipse OSGi would likely have its own packaging requirements).</para>

      <para></para>

      <para></para>

      <para></para>

      <note>
        <para>TODO: tidy up the following paras, were just copied/pasted in
        from APT</para>
      </note>

      <para></para>

      <para>All the following describe setting up the default security
      implementations. *** Mention that there are other implementations</para>

      <para></para>

      <para></para>

      <para>For desktop-based viewers the framework provides a
      <classname>ViewerInstaller</classname> <acronym>API</acronym>, defined
      in the <filename>core/runtime</filename> module. This approach is used
      by the <acronym>DnD</acronym> viewer and the <acronym>HTML</acronym>
      viewer, for example.</para>

      <para>Alternatively the viewer can use its own mechanism to get started
      (eg as a webapp) and then simply bootstrap the Isis runtime with a
      couple of lines of code. This is the technique used by the Scimpi webapp
      viewer, by the Wicket viewer and by the Restful viewer.</para>

      <para></para>

      <para>*** x-ref remoting docs as a way of deploying in client/server
      mode.</para>

      <para></para>

      <para></para>

      <sect1>
        <title>Setting up perspectives</title>

        <para></para>

        <para>profilestore</para>

        <para>x-ref alternatives/profilestore/xml</para>

        <para></para>

        <para>Perspectives allow the set of services available to a user (eg
        as icons in the DnD viewer) to be customized for that user. Since
        these services represent the "start points" for the user to interact
        with the domain model, they in a sense define an application on a
        per-user basis.</para>

        <para>The perspectives are stored in user-profiles, which are a
        persistence mechanism independent of the object store. (The intent is
        for user profiles to store additional information for use by viewers,
        for example allowing a user to reskin an application or change colors
        or fonts. As of NOF 4.0 the functionality provided is still limited,
        however).</para>

        <para>The key here is that if a user logs in and no perspective exists
        for that user then one will be created for them. The new perspective
        will be a copy of the 'template' perspective, or, if none was defined,
        a perspective containing all the known services. To create a template
        perspective add a perspective fixture that calls
        <methodname>saveAsDefault()</methodname>, rather than
        <methodname>saveForUser()</methodname> for a named user, as shown
        below.</para>

        <programlisting>public class PerspectivesFixture extends UserProfileFixture {
    @Override
    protected void installProfiles() {
        Profile profile = newUserProfile();
        Perspective perspective = profile.newPerspective("ECS");
        perspective.addToServices(LocationFactory.class);
        perspective.addToServices(CustomerRepository.class);
        perspective.addToServices(PaymentMethodFactory.class);
        
        saveAsDefault(profile);
    }
}
</programlisting>

        <para>With that set up, when a new user now logs in they will see
        three service icons on the screen for locations, customers and payment
        methods. On the drag and drop user interface the user can add and
        remove services from their perspective. To remove a service icon
        right-click on the grey border and select the close option. To add a
        service select the Services... option from the application menu
        (accessed by right-clicking on the application background) and drag
        the required service onto the desktop. Unfortunately there is no
        similar mechanism available on the HTML user interface so you will
        need to modify the created perspectives via the DND UI.</para>
      </sect1>

      <sect1>
        <title>Adding Security (Authentication and Authorization)</title>

        <para></para>

        <para>x-ref alternatives/security/file</para>

        <para></para>

        <sect2>
          <title></title>

          <para></para>
        </sect2>
      </sect1>

      <sect1>
        <title>Adding support for internationalisation</title>

        <para>All the text that appears to the user comes from the domain
        object model. Any literal text used within the code may be
        externalised, and localised using the standard Java mechanism of
        resource bundles. However as all field and menu names are derived from
        the method names the framework provides a mechanism to adapt these
        names using resource bundles as well.</para>

        <sect2>
          <title>Localisation files</title>

          <para>Create a file for each required language, e.g., <filename
          class="directory" moreinfo="none">i18n_en_GB.properties</filename>
          for English in Great Britain, and place them into the project such
          that they will be included in the class path. For the project
          structures we have already seen the files could be added to the
          <filename class="directory" moreinfo="none">resources</filename>
          directory, as the following example shows.</para>

          <screen format="linespecific">resources/
   <emphasis role="strong">i18n_en_GB.properties
   i18n_de_DE.properties
   i18n_fr_FR.properties</emphasis>
   </screen>

          <para>The following example is part of one of those translation file
          and shows how property and action names and descriptions may be
          specified.</para>

          <programlisting format="linespecific">example.dom.Contact.property.Phone.name=Téléphone
example.dom.Contact.action.NewPhone.name=Nouveau téléphone
example.dom.Contact.property.FullName.description=Le nom complet du client</programlisting>

          <para>For more details on defining localisation files, <xref
          linkend="i18n-files" />.</para>
        </sect2>

        <sect2>
          <title>Configuration</title>

          <para>The reflector needs to be decorated with a facet decorator to
          look up the translated names every time the framework needs
          information about the fields and menus. To include the decorator add
          the following to a properties file.</para>

          <programlisting format="linespecific">isis.reflector.facet-decorators=resource-i18n</programlisting>

          <para>If the application is being accessed via the web (html)
          viewer, then the server will need to perform the localisation, so
          the above property should be included in one of isis.properties read
          by the server; if the application is being accessed by a client
          (e.g. the DND viewer) then the localisation will be performed within
          the client, and the property should be specified in one of the
          properties files read by the client e.g. <filename class="directory"
          moreinfo="none">facet-decorator_i18n.properties</filename>.</para>

          <para>The locale will be picked up automatically from the machine on
          which the code is executing. You may override this by specifying the
          <link linkend="locale">locale</link> in a properties file.</para>
        </sect2>
      </sect1>
    </chapter>
  </part>

  <part>
    <title>TO MOVE</title>

    <chapter>
      <title></title>

      <section>
        <title></title>

        <para></para>
      </section>
    </chapter>
  </part>
</book>
