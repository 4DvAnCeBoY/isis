<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../documentation.dtd">
<section>
  <title>How to Resolve Problems in the Framework and its Components</title>

  <para>The NOF provides a number of tools to help resolve problems and debug
  the system. These are mainly applicable to issues within system code, but
  some of them can be useful when developing applications. The framework
  provides the following:-</para>

  <list>
    <para>Extensive use of logging through the <weblink
    address="http://logging.apache.org/log4j/docs/">Log4j</weblink> framework,
    an open source logging framework made available as part of the Apache
    Jakarta project ;</para>

    <para>Additional logging decorators that can be explicitly added to
    specific component to capture details about the usage of those
    components;</para>

    <para>And, debug views (from the user interface) that display details of
    components and anything else that implements the <class>DebugInfo</class>
    interface.</para>
  </list>

  <heading>Logging</heading>

  <para>Logging using Log4j is used throughout the NOF and the components the
  Naked Objects Group have created and it recommended that you use it too.
  Logging allows you to look what the framework and components have been when
  you investigate a problem and help to identify what parts of the system
  where doing what before an problem arose. Often logging alone is enough to
  pin point a problem, but if not it help you target what to
  investigate.</para>

  <para>Log4j allows you to log log debug messages, information about the
  system's state, warnings and errors. These events can be displayed on the
  console, written to files, or sent out over the network for remote logging.
  These are output in a user defined format and also can be filtered (so only
  events from certain components are seen). All this is configured through a
  set of properties passed to Log4J.</para>

  <subheading>Configuring Logging</subheading>

  <para>The complete options for outputting and formatting can be found in the
  relavent Log4J documentation (including the API). However, it crucial to
  smooth development of an NOF system that will cover some of it here. The NOF
  configures Log4j using properties files and will generally load
  <path>log4j.properties</path> or retrieve the properties from the that were
  loaded from <path>nakedobjects.properties</path> after that is loaded for
  framework configuration (these files need to be located in the working
  directory). If you are not using classes within the NOF to start the
  framework then how these properties are loaded could vary. The downside of
  putting the logging properities in the framework properties files is that
  there is no logging until it has been loaded. If this is necessary then it
  is better to use the separate properties file.</para>

  <para>The following file, or portion of a file, is a basic configuration for
  logging. It consists of two appenders and a basic logging
  configuration.</para>

  <property-listing>log4j.rootLogger=INFO, Console, File

# The console appender
log4j.appender.Console=org.apache.log4j.ConsoleAppender
log4j.appender.Console.Target=System.out
log4j.appender.Console.layout=org.apache.log4j.PatternLayout
log4j.appender.Console.layout.ConversionPattern=%-5r [%-20c{1} %-10t %-5p]  \t\t%m%n

# The exploration.log file appender
log4j.appender.File=org.apache.log4j.FileAppender
log4j.appender.File.File=exploration.log
log4j.appender.File.layout=org.apache.log4j.PatternLayout
log4j.appender.File.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n
log4j.appender.File.Append=false</property-listing>

  <para>The first line sets up logging to show events of level
  <ital>INFO</ital> and above through the <ital>Console</ital> and
  <ital>File</ital> appenders, which writes those events to the console and
  the file <path>exploration.log</path> respectively. The two blocks sepcifiy
  how to write to the console and the file. Other appenders can be used to
  change where the logs are written to. The number of appenders specified is
  unlimited, although there should be at least one. The console below (from
  Eclipse) shows the log. The file will contain the same thing although the
  formatting will be slightly different as the conversion pattern for the two
  appenders is different.</para>

  <screenshot fileref="images/console-log.png"></screenshot>

  <minorheading>Logging levels</minorheading>

  <para>The types of events that are logged can be changed. This determines
  how large the files become or how much traffic is put over the network, and
  is reflected in the amount of processing that needs to be done to process
  the events into messages that can be written out. Levels in order of
  increasing verbosity and log size, and is decreasing order of severity
  are:-</para>

  <list>
    <para>OFF - no logging</para>

    <para>FATAL - something very serious has happened that requires the system
    to be shut down.</para>

    <para>ERROR - something serious has happened that might affect any
    subsequent actions.</para>

    <para>WARN - something has not been set up properly, or needs attention.
    Although subsequent action might function correctly, they might not
    function as expected.</para>

    <para>INFO - information to the developer about something that has taken
    place.</para>

    <para>DEBUG - detailed information for the developer.</para>
  </list>

  <para>So in the above example to increase the logging level to debug change
  the first part of the property to <ital>DEBUG</ital> from <ital>INFO</ital>
  as below:</para>

  <property-listing>log4j.rootLogger=DEBUG, Console, File</property-listing>

  <para>Logging should almost never be set to off, but should at least be set
  to log the errors (unsing level ERROR). Whilst developing we recommend that
  you set your basic level to INFO and switch to DEBUG if you need to
  investigate something.</para>

  <para>Setting the logging level via the properties file applies that level
  at startup and cannot be changed using the properties, ie, that level will
  be used to filter all logged event while the system is running. If you are
  using the Skylark viewer, however, you can use the debug options to change
  the logging level on the client at any time. By using Ctrl-Shift-right-click
  on the desktop you will be shown the debug menu and see the following
  options:-</para>

  <inline-graphic fileref="images/logging-debug.png"></inline-graphic>

  <para>The greyed-out option indicates the current level. Selectiing one of
  the other levels will change the logging to that level.</para>

  <minorheading>Limiting logging by class</minorheading>

  <para>As well as limiting the level of events that are logged, we can also
  specify which classes we are interested in capturing log events for. In
  Log4j events are organised by loggers, which are set up programmatically,
  but as we create a logger for each class we talk about classes.</para>

  <para>To change the levels of events captured according to the class where
  the log event was created we can class based requirements after the root
  logger is specified. To set a logging level for a class add a property in
  the form</para>

  <property-listing>log4j.logger.&lt;package to log&gt;=&lt;level for package&gt;
log4j.logger.&lt;class to log&gt;=&lt;level for class&gt;</property-listing>

  <para>Events for the specified packages or class will be logged at the
  specified level, overriding the root level set up first. So for example the
  following configuration:</para>

  <property-listing>log4j.rootLogger=WARN, Console

log4j.logger.org.nakedobjects.object=INFO
log4j.logger.org.nakedobjects.object.reflect=DEBUG
log4j.logger.org.nakedobjects.object.persistence=DEBUG

log4j.logger.org.nakedobjects.object.loader.ObjectLoaderImpl=OFF</property-listing>

  <para>will capture warning and errors for all classes (as defined by the
  root logger), and information messages for those classes whose package
  begins with <class>org.nakedobjects.object</class>. In addition those
  classes beginning with <class>org.nakedobjects.object.reflect </class>or
  <class>org.nakedobjects.object.persistence</class> will have their debug
  events captured as well. Finally, the class <class>ObjectLoader</class> will
  have all of its events ignored.</para>

  <para>It is important to make use of this feature when using the Skylark
  viewer as it logs events about it rendering. In Java rendering the screen
  (via the <method>paint(Graphics)</method> method) happens very often and can
  cause the logs to be swamped with superflous events. The logger for these
  events are prepended with the text 'ui.' so we can disable all of these
  events across all the viewing classes by adding the following to the
  properties:</para>

  <property-listing>log4j.logger.ui=OFF</property-listing>

  <minorheading>Writing XML log files</minorheading>

  <para>By writing out the logs to a file in XML rather than as text allows
  you to look at the log using Chainsaw, a Log4j viewer. This tool allows you
  to quickly look at events in specific classes and hide events that are of no
  interest by setting up simple conditions.</para>

  <para>To write out an XML file the same appender as before is used, but the
  layout is changed. The following configuration logs all events (DEBUG and
  greater) to a file with an XML layout.</para>

  <property-listing>log4j.rootLogger=DEBUG, XmlFile

log4j.appender.XmlFile=org.apache.log4j.FileAppender
log4j.appender.XmlFile.file=nakedobjects.log.xml
log4j.appender.XmlFile.layout=org.apache.log4j.xml.XMLLayout
log4j.appender.XmlFile.append=false</property-listing>

  <minorheading>Writing HTML log files</minorheading>

  <para>HTML files can be viewed in a web browser and will display nicely in
  most email clients. Change the appender to use the <class>HTMLLayout</class>
  class.</para>

  <property-listing>log4j.appender.Snapshot.layout=org.apache.log4j.HTMLLayout</property-listing>

  <subheading>Snapshot appenders</subheading>

  <para>The NOF provides a number of appenders that create a snapshot of the
  recently logged events instead of capturing all events since the system
  started. The benefits here are twofold. First, writing to the appenders is
  minimised as they are only written when errors occur or the user demands it.
  Second, the partial log can be automatically sent over the network to
  someone who needs to know when things have gone wrong.</para>

  <para>All the snapshot appends support the same basic properties:-</para>

  <block>
    <label><property>addInfo</property></label>

    <para>(boolean) indicates whether to prepend details about the machine, os
    and Java to log, eg</para>

    <program-listing>Snapshot:- Thu Dec 01 14:34:24 GMT 2005
  R Matthews
  Windows XP (x86) 5.1
  Java HotSpot(TM) Client VM 1.4.2_04-b05
  Version  000000</program-listing>
  </block>

  <block>
    <label><property>bufferSize</property></label>

    <para>(integer) the number of events to write out to the snapshot.
    Defaults to 512 events.</para>
  </block>

  <block>
    <label><property>locationInfo</property></label>

    <para>(boolean) whether to capture the details of where in the code the
    event was generated. Note - capturing this information can be quite
    expensive.</para>
  </block>

  <block>
    <label><property>evaluatorClass</property></label>

    <para>(<class>org.apache.log4j.spi.TriggeringEventEvaluator</class>) a
    trigger that determines when a snapshot should be created. The trigger
    object is given each event that is logged and flags when to produce a
    snapsho.</para>

    <para>When not trigger is specified a default trigger is applied that
    triggers a snapshot when an event of level ERROR or FATAL occurs.</para>
  </block>

  <minorheading>File snapshot appender</minorheading>

  <para>The <class>FileSnapshotAppender</class> writes the snapshot to
  timestamped file. The following properties can be specified:-</para>

  <block>
    <label><property>directory</property></label>

    <para>The directory path where the files are to be created. If none is
    specified then the working directory will be used.</para>
  </block>

  <block>
    <label><property>extension</property></label>

    <para>The extension type to append to the file name.</para>
  </block>

  <block>
    <label><property>fileName</property></label>

    <para>The base name of the log file, which will have timestamp appended.
    Defaults to 'log-snapshot-'.</para>
  </block>

  <para>The following example writes xml snapshots to the logs directory to
  files ending with '.xml'.</para>

  <property-listing>log4j.appender.Snapshot=org.nakedobjects.utility.logging.FileSnapshotAppender
log4j.appender.Snapshot.bufferSize=1024
log4j.appender.Snapshot.addInfo=true
log4j.appender.Snapshot.locationInfo=true
log4j.appender.Snapshot.directory=logs
log4j.appender.Snapshot.extension=xml
log4j.appender.Snapshot.layout=org.apache.log4j.xml.XMLLayout</property-listing>

  <minorheading>Popup snapshot appender</minorheading>

  <para>The <class>PopupSnapshotAppender</class> displays a popup dialog
  showing the snapshot.</para>

  <inline-graphic fileref="images/popup-snapshot.png"></inline-graphic>

  <para>Do not use this on a server as there will be no one sitting in front
  of it to see it. It has no properties so its configuration is short.</para>

  <property-listing>log4j.appender.Popup=org.nakedobjects.utility.logging.PopupSnapshotAppender
log4j.appender.Popup.layout=org.apache.log4j.PatternLayout
log4j.appender.Popup.layout.ConversionPattern=%-5r [%-20c{1} %-10t %-5p]  %m%n
</property-listing>

  <minorheading>Email snapshot appender</minorheading>

  <para>The <class>SmtpSnapshotAppender</class> generates an email with the
  snapshot in it and sends it to a specified recipient. The following
  properties can be specified:-</para>

  <block>
    <label><property>server</property></label>

    <para>Address of the email server</para>
  </block>

  <block>
    <label><property>port</property></label>

    <para>The port the server listen on for SMTP requests. Defaults to port
    25.</para>
  </block>

  <block>
    <label><property>recipient</property></label>

    <para>Email address to send the snapshot to.</para>
  </block>

  <block>
    <label><property>domain</property></label>

    <para>The address that client connects to the server with. Some email
    servers validate the sender's address in the MAIL FROM command so you may
    need to specify a real address here.</para>
  </block>

  <para>The following example sends a short HTML snapshot logs to
  logs@support.acme.com, via the email server at my.emailserver.com using port
  25.</para>

  <property-listing>log4j.appender.EmailSnapshot=org.nakedobjects.utility.logging.SmtpSnapshotAppender
log4j.appender.EmailSnapshot.bufferSize=50
log4j.appender.EmailSnapshot.addInfo=true
log4j.appender.EmailSnapshot.server=my.emailserver.com
log4j.appender.EmailSnapshot.port=25
log4j.appender.EmailSnapshot.recipient=logs@support.acme.com
log4j.appender.EmailSnapshot.layout=org.apache.log4j.HTMLLayout</property-listing>

  <minorheading>Socket snapshot appender</minorheading>

  <para>The <class>SocketSnapshotAppender</class> establishes a socket
  connection to a server and passes across the the snapshot. This is designed
  to be used with <class>SnapshotServer</class>, which collects collects
  snapshots from multiple clients. The following properties can be
  specified:-</para>

  <block>
    <label><property>server</property></label>

    <para>Address of the server.</para>
  </block>

  <block>
    <label><property>port</property></label>

    <para>The port the server listens on for logging requests. Defaults to
    port 9289.</para>
  </block>

  <para>The following example sends an XML snapshot to a server on a private
  network.</para>

  <property-listing>log4j.appender.SocketSnapshot=org.nakedobjects.utility.logging.SocketSnapshotAppender
log4j.appender.SocketSnapshot.bufferSize=1024
log4j.appender.SocketSnapshot.addInfo=true
log4j.appender.SocketSnapshot.server=191.168.1.1
log4j.appender.SocketSnapshot.port=12345
log4j.appender.SocketSnapshot.layout=org.apache.log4j.xml.XMLLayout</property-listing>

  <para>The snaphot server should be directed to a maching running the server.
  The server is run using the following command:</para>

  <command-listing>java -cp nakedobjects.jar org.nakedobjects.utility.logging.SnapshotServer</command-listing>

  <para>The server needs a properties file with the following properties
  defined (with the prefix
  <property>nakedobjects.snapshotserver.</property>):-</para>

  <block>
    <label><property>port</property></label>

    <para>The port the server listens on for logging requests. Defaults to
    port 9289.</para>
  </block>

  <block>
    <label><property>directory</property></label>

    <para>The directory path where the transferred files are to be saved. If
    none is specified then the working directory will be used.</para>
  </block>

  <block>
    <label><property>fileName</property></label>

    <para>The base name of the log file, which will have timestamp appended.
    Defaults to 'log-snapshot-'.</para>
  </block>

  <block>
    <label><property>extension</property></label>

    <para>The extension type to append to the file name.</para>
  </block>

  <para>An example configuration would be:-</para>

  <property-listing>nakedobjects.snapshotserver.port=12345
nakedobjects.snapshotserver.directory=logs
nakedobjects.snapshotserver.filename=log
nakedobjects.snapshotserver.extension=xml</property-listing>

  <minorheading>Web snapshot appender</minorheading>

  <para>The <class>WebSnapshotAppender</class> sends the snapshot to a web
  server. The following properties can be specified:-</para>

  <block>
    <label><property>url</property></label>

    <para>URL of server to post data to (including the protocol
    'http').</para>
  </block>

  <block>
    <label><property>proxyAddress</property></label>

    <para>Address of web proxy if one is being used.</para>
  </block>

  <block>
    <label><property>proxyPort</property></label>

    <para>Port of proxy server.</para>
  </block>

  <para>The following example sends a default length snapshot to the
  webserver.</para>

  <property-listing>log4j.appender.Remote=org.nakedobjects.utility.logging.WebSnapshotAppender
log4j.appender.Remote.addInfo=true
log4j.appender.Remote.locationInfo=true
log4j.appender.Remote.url=http://192.168.1.3/support/test.php
log4j.appender.Remote.layout=org.apache.log4j.HTMLLayout</property-listing>

  <para>This appender use the HTTP POST method to upload the data. It passes
  up a message and the snapshot as two parameters to the request:
  <variable>error</variable> and <variable>trace</variable>.</para>

  <subheading>Using logging to get help</subheading>

  <para>When you are working with someone else it is often useful to send
  details of what is happening including screenshots, code, and logs. To make
  the other person's life easier provide as much information as
  possible:</para>

  <list>
    <para>Detail the version of the framework and the platform (Java or .Net)
    you are using</para>

    <para>Describe the problem in detail</para>

    <para>Provide screenshots (as a <path>.gif</path> or <path>.png</path>,
    avoid jpegs and Word documents) that shows the problem</para>

    <para>Provide log files from both the client and the server in an XML
    format so they can be viewed using Chainsaw</para>

    <para>Include your contact details, preferrably you email address</para>
  </list>

  <para>Collate all this information ensuring each file is clearly named. Then
  zip up (or tar) the whole set (as the logs, in particular, can be huge) and
  email the compressed file.</para>

  <subheading>Adding logging to your code</subheading>

  <para>It is recommended that you also add logging to your code, particularly
  if you are developing a component or extending the framework in some way.
  This way you will be able to see the interaction of your classes with those
  of the NOF. The following lays out how the framework uses Log4j, and hence
  how you should use it to be consistent.</para>

  <para>Simple ensure that any class that does any logging makes a
  <class>Logger</class> available. By convention the name is always
  <variable>LOG</variable>. The name of the logger should be the name of the
  class in its fully qualified form. To make this easy use the constructor
  that takes a <class>Class</class> object and pass in your class using as
  shown here. Don't forget to add an import to
  <class>org.apache.log4j.Logger</class>, not the class of the same name in
  the NOF or in Java itself.</para>

  <program-listing>private final static Logger LOG = Logger.getLogger(NakedClass.class);</program-listing>

  <para>Where you wish to add log message add a statement like the following,
  deciding first what level the event should be classified as (see above); the
  available methods are <method>debug</method>, <method>info</method>,
  <method>warn</method>, <method>error</method> and
  <method>fatal</method>.</para>

  <program-listing>LOG.debug("mark as dirty " + object);

LOG.error("failed to create instance of " + this, e);</program-listing>

  <para>The first statement in this example contains just a message, while the
  second version logs a message and, separately, the complete stack
  trace.</para>

  <minorheading>Making you classes useful in logs</minorheading>

  <para>To make the most of logging, even if you don't log anything in you
  code, make sure that you declare a <method>toString</method> method in each
  of you classes. This way when a log message is created that references your
  object the message will show your object in detail rather than like
  this:</para>

  <output-listing>MyObject@33D4</output-listing>

  <para>A suitable toString can cause it to be rendered more usefully such
  as:</para>

  <output-listing>MyObject [name=windows,size=34x20]</output-listing>

  <heading>Component loggers</heading>

  <para>The NOF provides a set of component loggers that specifically log the
  use of a component, adding additional log messages to the Log4j log or write
  out to a separate file. Additional logger can also be defined for other
  components. These logger are designed to log the parameters passed to and
  the the results return from the requests to a component and tend to be more
  verbose than the general logging just discussed. At present the following
  components have loggers available:-</para>

  <list>
    <para>The object persistor - <class>ObjectPersistorLogger</class></para>

    <para>The object store - <class>ObjectStoreLogger</class></para>

    <para>The distibution interface - <class>DistributionLogger</class></para>
  </list>

  <para>To set up a logger create an instance of it passing in the object you
  are logging. Then use the logger instance in place of the original
  component. The constructors for each of the loggers are overloaded so they
  take a component to decorate and possibly a file name. If the filename is
  specified then the logging is done to that file. If there is no file name
  then the events are logged via Log4j. For example the object store persistor
  would logged by replacing:</para>

  <program-listing>NakedObjectPersistor persistor = new ObjectStorePersistor();
nakedObjects.setObjectPersistor(persistor);</program-listing>

  <para>with this, which will log request to the persistor the
  <path>sever-persistor.log</path> file:</para>

  <program-listing>NakedObjectPersistor persistor = new ObjectStorePersistor();
persistor = new ObjectManagerLogger(persistor, "server-persistor.log");
nakedObjects.setObjectPersistor(persistor);</program-listing>

  <para>Please note that the log files, when used, are created when the logger
  is instantiated and will overwrite any exsiting file. This is not normally a
  problem as we are interested in the activities during an entire session.
  However on a stateless server where the component is being recreated each
  time the continual recreation of the file could be a problem.</para>

  <minorheading>Defining a logger</minorheading>

  <para>To define a logger extend the Logger class, providing a suitable
  constructor, and implement the <method>getDecoratedClass</method> so it
  passes back the <class>Class</class> object of the class being decorated
  (this allows the Log4j logger to log messages as that class rather than as a
  separate class). Within the subclass you can use the following
  methods:</para>

  <block>
    <label><method>void log(String message) </method></label>

    <para>output a log entry with the specified message.</para>
  </block>

  <block>
    <label><method>void log(String message, Object result) </method></label>

    <para>output a log entry with the specified message and the specified
    result. This is useful when needing to show both the entry and exit
    states, or the paramters and the return value.</para>
  </block>

  <block>
    <label><method>void close() </method></label>

    <para>closes the file that is being written to.</para>
  </block>

  <heading>Debugging from within the Skylark viewer</heading>

  <para>While using the NOF through the Skylark viewer you a have a number of
  ways of looking at the state of the system. Every view, including the
  desktop, has debug options that can be accessed by
  Crtl-Shift-right-clicking. The following options might be useful to
  you.</para>

  <minorheading>From the destop menu</minorheading>

  <block>
    <label>Log Level OFF/ERROR/WARN/INFO/DEBUG</label>

    <para>Change the log level in Log4j</para>
  </block>

  <block>
    <label>Debug graphics on/off</label>

    <para>Turn on or off the debug drawing within the viewer. This sets/clears
    the <variable>AbstractView.debug</variable> variable, which is used within
    draw methods to do additional drawing for debug purposes.</para>

    <screenshot fileref="images/degug-graphics.png"></screenshot>
  </block>

  <block>
    <label>Show mouse spy</label>

    <para>Brings up a debug window showing details about the mouse and it
    position within the view hierarchy.</para>
  </block>

  <block>
    <label>Restart object loader/persistor</label>

    <para>Calls <method>reset</method> on the <class>NakedObjectLoader</class>
    and <class>NakedObjectPersistor</class> objects. This should clear all the
    objects and adapters from memory, forcing them to be reloaded from
    persistent storage. It is important not have any open objects on the
    screen as these will no longer be linked to the known objects and might
    cause problems.</para>
  </block>

  <block>
    <label>Debug system</label>

    <para>Brings up a debug frame showing debug details for the main
    components of the system. These include the persistor, loader,
    configuration, and specification loader.</para>

    <screenshot fileref="images/debug-system.png"></screenshot>
  </block>

  <block>
    <label>Debug viewer</label>

    <para>Brings up a debug frame showing debug details for the Skylark
    viewer.</para>

    <screenshot fileref="images/debug-viewer.png"></screenshot>
  </block>

  <block>
    <label>Dump log to snapshot</label>

    <para>Creates a Log4j snapshot, which is send to each of the snapshot
    appenders. This is only enabled if Log4j is setup with one or more
    snapshot appenders.</para>
  </block>

  <minorheading>From the view</minorheading>

  <para>1. From a view we have these debug options available on the
  <ital>view</ital> menu:</para>

  <block>
    <label>Refresh view</label>

    <para>Causes the view to be redisplayed after rereading the state of the
    view's content. This only affects the values and not the reference
    objects.</para>
  </block>

  <block>
    <label>Invalidate content</label>

    <para>Flag the view's content as invalid causing the view to be
    recreated.</para>
  </block>

  <block>
    <label>Invalidate layout</label>

    <para>Flag the view's layout as invalid causing the view to be relaid
    out.</para>
  </block>

  <block>
    <label>Debug view</label>

    <para>Brings up a debug frame showing debug details for the current
    view/object. These include the adapter's state, the domain object graph,
    the object specification, the view's content object, the structure of the
    view, and a full listing of the drawing done to render the view.</para>

    <screenshot fileref="images/debug-view.png"></screenshot>
  </block>

  <para>2. Also from the view we have these debug options available on the
  <ital>object</ital> menu:</para>

  <block>
    <label>Destroy object</label>

    <para>Forces a destory call to the object persistor.</para>
  </block>

  <block>
    <label>Clear resolve</label>

    <para>Forces the object's resolve state back to <ital>Ghost</ital>.</para>
  </block>

  <block>
    <label>Debug view</label>

    <para>Brings up a debug frame showing debug details for the current
    view/object (see above).</para>
  </block>

  <heading>Writing code to help investigate problems</heading>

  <minorheading>The Dump Utility</minorheading>

  <para>The <class>org.nakedobjects.object.Dump</class> class provides a
  simple way out outputting the details of adapters and specifications. The
  two <method>specification </method>methods detail the specified
  <class>NakedObjectSpecification</class> as follows:-</para>

  <output-listing>Full Name: bom.Location
Short Name: Location
Plural Name: Locations
Singular Name: Location

Abstract: false
Lookup: false
Object: true
Value: false
Persistable: User Persistable
Superclass: java.lang.Object
Subclasses: empty
Interfaces: bom.Common
Fields
    OneToOneAssociationImpl@1408a92 [type=VALUE,id=type,label='Type',derived=false,type=Option]
    :
    :</output-listing>

  <para>The two <method>object</method> methods detail the specified
  <class>Naked</class> object as follows:-</para>

  <output-listing>Specification: bom.Location
Class: bom.Location
Adapter: org.nakedobjects.object.defaults.PojoAdapter
Hash: #dada24
Title: test, Fort Worth
Object: bom.Location@18e4327
OID: OID#2F
State: ResolveState@1e1be92 [name=Resolved,code=PR]
Version: LongNumberVersion#1 20051118-025400170
Icon: null
Persistable: User Persistable</output-listing>

  <para>The two <method>graph</method> methods detail the specified
  <class>Naked</class> object as follows, showing each adapter, it associated
  objects and values:-</para>

  <output-listing>PojoAdapter@dada24 [PR:OID#2F,specification=Location,version=LongNumberVersion#1 20051118-025400...
    +--type: POJO BusinessValueAdapter: One
    +--knownas: POJO TextStringAdapter: test
    +--streetaddress: POJO TextStringAdapter: address
    +--city: PojoAdapter@b51404 [PR:OID#C,specification=City,version=LongNumberVersion#1 ...
    |    +--name: POJO TextStringAdapter: Fort Worth
    +--customer: PojoAdapter@92dcdb [PR:OID#1C,specification=Customer,version=LongNumberVers...
    |    +--firstname: POJO TextStringAdapter: Richard
    |    +--lastname: POJO TextStringAdapter: Pawson
    |    +--phonenumbers: VectorCollectionAdapter@1d381d2 [PR:-,specification=Vector,version=...
    : 
    :</output-listing>
</section>