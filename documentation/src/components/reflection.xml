<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../documentation.dtd">
<section label="reflection">
  <title>Reflection</title>

  <para>The NOF provides two pieces of the Reflection ..... it provides a
  subframework for building the reflection layer, and, based on that
  framework, it provides a full implementation that introspects and
  manipulates Java classes conforming to the conventions in the supplied
  application library. The main reason for providing this framework is not
  only that this area is fairly complicated, but that reflection layer needs
  to deal with all classes in the system, and not just classes that conform to
  the applcaition library requirements, that is certain NOF classes are also
  reflected on and used with the NOF. By providing this framework these
  classes can dealt with internally, sparing the reflection developer of
  having to explicitly deal with them.</para>

  <para></para>

  <minorheading>Member specifications</minorheading>

  <para>Each NakedObjectSpecification details information about the class
  including what methods it has and what fields it provides. Each of these is
  speficified through an <class>Action</class>,
  <class>OneToOneAssociation</class> or <class>OneToManyAssociation</class>
  object. The framework provides implementations of each of these along with
  peer definition that allow us to provide reflector specific behaviour and to
  declaratively modify that behaviour to implement services such as security,
  distribution and help.</para>

  <para></para>

  <para></para>

  <minorheading>Managing the loading of specifications</minorheading>

  <para><class>AbstractSpecificationLoader</class> manages the loading of the
  specifications, their caching and decoration to <rephrase>add additional
  behaviour</rephrase>. When a specification is requested (via either of the
  <method>loadSpecification</method> methods) the cache is checked first and
  if it contains the requested specification it is returned immediately. If
  not already loaded the loader needs to load the class and will normally call
  the abstract <method>install</method> method that must be implemented in the
  subclass, however there are special cases that cause the loader to create
  different classes of specifications. These include when the class is an
  Exception class or a NOF internal class (that implements the
  <class>InternalNakedObject</class> interface). Also if the
  <method>install</method> method returns <object>null</object>, indicating
  that it could introspect the class, then a
  <class>NoMemberSpecification</class> object is created. As soon as a
  specification is instantiated it is added to the cache and only then is its
  <method>introspect</method> method called.</para>

  <para>To decorate the behaviour of the reflector a
  <class>ReflectionPeerBuilder</class> can be set up on the specification
  loader though the <method>setReflectionPeerFactory</method> method.</para>

  <minorheading>Caching the specifications</minorheading>

  <para>The loader's cache is set up via the <class>setCache</class> method.
  Two types of cache are supplied and others can be defined by implementing
  the <class>SpecifiactionCache</class> interface. The cache classes supplied
  are <class>SimpleSpecificationCache</class> and
  <class>StaticSpecificationCache</class>, and differ only in the way they
  store the specification. The static version uses a static variable for the
  hash so that specification are shared by different instances of the
  cache.</para>

  <minorheading>Decorating the reflector</minorheading>

  <para>The <class>ReflectionPeerBuilder</class> provides a way to decorate
  the reflection classes allowing us to add aspects such as localisation,
  security, transactional constraints and distribution to the reflection
  mechanism in a declarative manner. By setting up the builder with an array
  of <class>ReflectionPeerFactory</class> objects at startup, any
  specification created will have the reflective compone.... As each
  specification is created the reflective peer from the reflector, which uses
  reflection to interact with the domain object, will have the specified set
  of decorators added to it. For example it the builder is set up with two
  factories where the first provides help and the second provides
  authorisation then any Action objects generated will delegate to action help
  peer, which in turn will delegate to the autorisation peer, and that will
  delegate to the actual reflection peer that invokes the action on the domain
  object. For each set of peers a <class>ActionImpl</class>,
  <class>OneToOneAssociationImpl</class> and
  <class>OneToManyAssociationImpl</class> is created that delegates to the
  topmost peer.</para>

  <para>Each <class>ReflectionPeerFactory</class> implements three method that
  create action, one to one, and one to many peers, given an existing peer.
  The specified peer is the one that it should pass on its own request to once
  the peer has added its behaviour (the decorator pattern). The orignal peer
  is always the one that reflectively manipulates the domain object. Often
  these peers need to access specific services such as security, an these
  should be set up when the factory is initialised.</para>

  <para>To set up the specification loader to add reflection peers set the
  loader up with a ReflectionPeerBuilder that has been set up a the factory
  array during initalisation as below:</para>

  <program-listing>ReflectionPeerFactory[] factories = new ReflectionPeerFactory[] {
     new TransactionPeerFactory(),
};

JavaSpecificationLoader specificationLoader = new JavaSpecificationLoader();
specificationLoader.setReflectionPeerFactories(factories);
</program-listing>

  <para></para>

  <minorheading>Introspection</minorheading>

  <para>The <class>AbstractSpecificationLoader</class> loader implementation
  must create a <class>NakedObjectSpecification</class> when its install
  method is called and return it. When the specification's
  <method>introspect</method> method is subsequently called it must introspect
  the specified class and collate information about the class including names
  for class (short, plural full), the type of class (object, colletion,
  abstract), hwo a title is to be generated, how and whether it can be
  persisted. It also needs to generate a set of <class>ActionPeer</class>,
  <class>OneToOnePeer</class> and <class>OneToManyPeer</class> objects
  representing each behaviour and field in the class.</para>

  <para>The recommended way of collecting together all this information is to
  create a separate object (which we will refer to as an introspector) to
  perform the introspection. When it is complete the compiled information is
  copied into the specification class and the introspector can be destroyed.
  This ensures that all the superflous objects that get created suring
  introspection, but are not needed later on, are removed from memory.</para>

  <para>The introspector should then use the ReflectionPeerBuilder to create
  the required <class>Action</class>, <class>OneToOneAssociation</class> and
  <class>OneToManyAssociation</class> object and its decorators.</para>

  <para></para>

  <subheading>Implementation</subheading>

  <para>The NOF provides a Java 1.1 compatible reflector in the class
  <class>JavaReflector</class>. Methods beginning with 'get', 'set' and
  'action' are recognised, along with any methods that are additionally
  prefixed with 'about', as fields and methods respectivley.</para>

  <para>As certain methods must match one another, the method names must be
  consistently spelt with just the prefix changing e.g., getCustomer with
  setCustomer and actionRelease aboutActionRelease. Certain other aspects of
  the declaration are also checked to ensure that only valid method are made
  available e.g., get methods must return a valid type and cannot be void,
  whereas set methods must be void and have to have a parameter type that
  matches the type specified by the corresponding get. It should be noted that
  all non-public method are completely ignored as they will not be able to be
  accessed when needed.</para>

  <para>The <class>JavaReflector</class> is defined in the package
  <class>org.nakedobjects.reflector.java.reflect</class>.</para>

  <subheading>Classes</subheading>

  <javadoc class="AbstractNakedObjectSpecification" outline="yes"
           package="???"></javadoc>

  <javadoc class="SpecificationCache" outline="yes" package="???"></javadoc>

  <javadoc class="ActionPeer" outline="yes" package="???"></javadoc>

  <javadoc class="OneToOnePeer" outline="yes" package="???"></javadoc>

  <javadoc class="OneToManyPeer" outline="yes" package="???"></javadoc>
</section>