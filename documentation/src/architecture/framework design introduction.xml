<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "./documentation.dtd">
<section>
  <title>Introduction</title>

  <description>A look at the Naked Objects Framework and how it
  works</description>

  <para>The Naked Objects Framework (NOF) transforms a domain object model
  (DOM) into an <rephrase>application</rephrase> that the user can interact
  with. Where the objects the users create and manipulate can be managed,
  persisted and distributed in a way that allows multiple users to work
  simultaneously on separate machines, and even use different types of
  interface.</para>

  <para>To run an application in NOF the domain objects need not be part of
  the NOF and should ideally just be plain Java or .Net objects (refered to as
  POJOs or plain old Java objects), although they will need to be consistent
  and transparent enough so that their properties and behaviours can be
  determined simply by looking at their definitions. By defining the DOM
  separately from any particular system, specifically the NOF, we can create a
  portable and reusable system.</para>

  <para>The NOF is divided into three distinct parts (see the following
  diagram) that we will look at now. The main part as far as the application
  developer is concerned is the Domain Object Model (DOM) with its supporting
  library and container. The server manipulates and manges the DOM, providing
  the necessary services such as persistence and distribution through
  reflection and adapters. Clients - such as command and graphical user
  interfaces, testing frameworks and scripts - indirectly display and
  manipulate the DOM via the server.</para>

  <figure fileref="architecture/nakedobjects.png"
          label="The architecture of the NOF"></figure>

  <subheading>Domain objects and container</subheading>

  <para>To use the framework a set of domain objects are defined in Java/.Net
  that adhere to number of simple coding convention. These object defintions
  (classes) are made available to the framework using reflection, which is
  used to compile a profile of the class and is used to access the fields and
  behaviours of instances of that type, as is done by the rest of the
  framework. For example a pair of accessor methods (<method>get...</method>
  and <method>set...</method>) might be noted in the profile as an object's
  field, while an <method>action...</method> method is seen as a behaviour to
  offer to the user.</para>

  <para>With such a DOM the NOF has to turn it into an application
  <comment>this term is probably wrong</comment>. To make it an application
  the objects in the DOM need to be accessible so the user can work with them,
  rendered so the user can see and manipulate them, persisted so they are
  available from one session to next session, distributed across the network
  so multiple users can access them and a central server can manage them,
  control access to them so only the authorised users can see and change them,
  and test them so that we can be confident that the application is
  correct.</para>

  <para>For such objects to be part of any system there are few needs of the
  object to access the system, depite such a strong separation being matained.
  To achieve this, and to keep the system separated we suggest providing a the
  DOM with a container that it can use to find instances or make objects
  persistence. Also if objects change then the container can be informed so
  that the persistent objects can be updated. This kind of functionality is
  needed irrespective of how the system is implemented so providing an
  interface with these responsibilities means then NOF can implement that
  interface and therfore make itself available to the DOM without tying the
  DOM into the NOF.</para>

  <para>In addition to the container the DOM objects often need value objects
  (see Fowler, PEAA) for common business value such as money, time, quantity
  etc. Again these are common to application rather than the system so can be
  provided as part of an application library.</para>

  <para>Also, it is useful to be able to mark objects with attribute such as
  transient or persistent, a lookup, or to provide application specific
  exceptions. Again these are all application specific and not part of the
  implementing system, and hence should be part of an application
  library.</para>

  <subheading>Server</subheading>

  <para>The server makes the DOM useable by providing access to the domain
  objects using reflection and wrapping each in an adapter. A memory
  management and persistent storage layer ensures that object can be
  saved.</para>

  <minorheading>Reflector</minorheading>

  <para>To enable the NOF to make use of the DOM the framework uses reflection
  to identify each objects fields or properties and its behaviours, theses are
  the things that the user is interested in viewing and using to manipulate an
  object. The reflection component of the NOF needs to be designed to work
  with the DOM objects, knowing how it properties are defined, how its action
  methods are defined, how it flags different object types, and how it
  provides control over its properties and methods.</para>

  <para>The NOF builds up a specification for each type of domain object and
  provides the user with access to the objects. I can then persist and
  distribute those objects, authorise thier use, and test the
  application.</para>

  <minorheading>Adapters and Identifiers</minorheading>

  <para>To deal with domain objects the NOF provides an adapter, or proxy, for
  each object. These adapters are internal to the NOF and provide a way for
  the NOF to work with an domain object whose type it does not know. To
  facilitate distribution and persistence each persistent object's adapter is
  assigned an identifier - refered to as its object identifier (OID) - that
  uniquely identifies an object over space and time. By giving objects OIDs
  two copies of an object on two difference machines are known to be the same
  because their OIDs are same. Similarly in the persistent store references to
  other objects can be stored using OIDs instead of memory pointers, which are
  only valid while objects are in memory.</para>

  <minorheading>Objects in memory and in persistent storage</minorheading>

  <para>The object loader manges all objects in memory and affords two core
  services. First, it provides the mapping between a domain object and its
  wrapper, ensuring that only one wrapper ever exists for any one domain
  object. Second, it provides the mapping between an adapter for a persistent
  domain object and its OID that uniquely identifies it.</para>

  <para>The object persistor manages the peristence of objects that need to
  kept across invocations of the virtual machine. When an object needs to be
  persisted it is past to the object persistor. This asks the reflection
  mechanism to provide it with each of the object's fields which it then
  writes out to the persistent store. The persistor also loads objects back
  into memory by recreating the requested domain object, retrieving its data,
  and then setting each of its properties through requests to the reflector.
  The persistor supports all the needs of persistence such as saving,
  updating, loading and deleting objects, as well as providing a generalised
  mechanism for searching for objects. Finally it allows the NOF to request
  that groups of requests are treated as a transaction, and hence will be
  persisted as their entirety or not at all.</para>

  <minorheading>Configuration properties</minorheading>

  <para>A set of configuration properties are made available within the NOF,
  allowing any component to look up properties. The configuration can be
  loaded from anywhere, but by defualt it is loaded from a Java style
  properties files.</para>

  <minorheading>Repository</minorheading>

  <para>A globally accessible repository makes all the core available to all
  those parts of the NOF that need them. The accessible components include the
  configuration, object loader and persistor, and the specification
  loader.</para>

  <minorheading>Fixtures</minorheading>

  <para>A mechanism is provided with the server that loads in object fixture
  specification and will create a series of objects ready use once the
  framework has started.</para>

  <minorheading>Event handling</minorheading>

  <para>A number of listeners are are available within the NOF that allow the
  framework to notify clients that exceptions have occurred that need to be
  dealt with, that objects have changed, or that there are messages to be
  conveyed to the user.</para>

  <minorheading>Utilities and development tools</minorheading>

  <para>The NOF also provides a number of general utilities such as splash
  window, assert logic (for Java 1.1), logging appenders, performance
  profiling utilities and an exception helper that prints out the full details
  of an exception even in .Net.</para>

  <para>The NOF provides a number of tools to the developer of the NOF and to
  those extending it. These hekp to make the framework and it component more
  transparent, showing the developer what state the system is in, and what it
  has been doing. There is a simple debug interface that allows any component
  or subcomponent to provide information via a dialog or window. Dumping the
  content of objects and specifications is provided in helper classes, as well
  as helper classes to do things like generate to-string values simply.</para>

  <subheading>Clients</subheading>

  <para>Numerous clients use the server to make the domain objects visible or
  to manipulate them. These include the supplied Graphical User Interface, the
  acceptance testing (XAT) framework.</para>

  <minorheading>User Interface</minorheading>

  <para>Once the NOF has a way to reference objects in the DOM and it has an
  understanding of the objects structures it can make them visible to user,
  render them, or persist them to some form of persistent storeage, and pass
  the objects over the network. All this can be done using reflection to
  access the fields of an object and invoke their behavious. Reflection is a
  programming facility that allows objects to be accessed dynamically at
  runtime, rather than statically in the system code, as expressed at compile
  time. To make an object visible a viewing mechanism gets the information
  about what the object that is is displaying contains and then determines how
  it can display each part.</para>

  <para>To provide the user with the ability to create, access, view and
  manipulate these object a viewing mechanism is automatically created by
  using these profiles to determine how display the objects and how they
  should behave in response to user interactions. For example, in the basic
  user interface, an object's fields are displayed and displayed as edit
  fields or an icon representing a referenced object depending on the type of
  the field; action methods are shown as options on the icon's popup
  menu.</para>

  <para>The reflector provides the NOF with the means to work with the domain
  objects, tranforming the domain object model into an application that the
  user can interact with, and NOF can manage, persist and distribute. The
  reflector must analyse each class that is used within the system to
  determine what fields or properties it has and what behaviours it offers.
  These are then advertised to the NOF ready for request to be made. When the
  NOF wishes to interogate an object or manipulate it, e.g. in response to a
  user action, the reflector is asked to do the work.</para>

  <para>The viewer is not such much a component as a client of the framework.
  Like all clients of the framework it uses the components just described to
  access and manipulate the objects in the domain model. A viewer's job is to
  render visible the domain objects to a user, and provide the user with means
  to modify the objects and invoke methods on them. All this is done via the
  reflector without direct access with the domain objects.</para>

  <minorheading>Testing</minorheading>

  <para>Like the viewer, the testing framework makes use of the NOF and
  effectively pretends that it is a user interface. The tests describe each
  step in generalised fashion and the XAT Framework exececutes those steps
  manipulating the underlying domain objects. Having manipulated the objects
  the tests then assert that certain conditions are met. Additional
  manipulations and assertions can be undertaking. If all conditions are met
  then the test passes, otherwise it will fail. The tests are written using an
  extended Junit framework so the results are normally displayed as green or
  red bar.</para>

  <subheading>Dealing with Other Concerns</subheading>

  <para>The above descriptions do not discuss other concerns that you might
  need to address in an enterprise system, such as security, distribution and
  transactional integrity. All of these, and others, are dealt with in the NOF
  by adapting the components we have already discussed so that they can
  perform the needed work.</para>

  <minorheading>Distribution</minorheading>

  <para>To allow the application to work across multiple tiers the NOF
  distributes requests to the object manager and reflector, passing the
  request to a remote machine instead of invoking it locally. Using the
  reflection mechanism the NOF is able serialize and deserialize objects and
  pass them across the network.</para>

  <para>Distributing the NOF over multiple tiers is accomplished not through a
  specific component, but through the implementations of specific components,
  namely the object manager and the reflector, which forward their requests to
  a server and awaits a response. The domain objects are replicated so that
  the client only holds a copy of the objects that are in use. By selectively
  forwarding requests work that needs to done on the server, such as executing
  business behaviour, is passed onto the server for execution. Other tasks,
  such as determining whether an action can be invoked, can be executed on the
  client as all the necessary information is to hand.</para>

  <minorheading>Transactions</minorheading>

  <para>The object persistor has start, end and abort methods to tell the
  underlying persistent layer to group together requests into atomic units and
  these need to be called by the NOF to create the transactions. The NOF
  provides an addition to the reflection mechanism that will start and stop
  transactions.</para>

  <minorheading>Security</minorheading>

  <para>Providing control over who can access the domain objects and what
  properties and behaviours are available is achieved by getting the
  reflection mechanism to check each reflective request. The reflector will
  only make available those fields and behaviours that the security layer
  allows.</para>

  <minorheading>Localisation</minorheading>

  <para>In addition to security the reflection mechanism can also intercepts
  requests for names and descriptions of field and behaviours and return
  internationalized version, allowing an application to be localised.</para>
</section>