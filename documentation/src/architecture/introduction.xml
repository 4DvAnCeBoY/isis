<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../documentation.dtd">
<section>
  <title>Introduction</title>

  <description>A look at the Naked Objects Framework architecture and how it
  is used.</description>

  <para>The Naked Objects Framework (NOF) transforms a domain object model
  (DOM) into an application that the user can interact with, where the objects
  that the user create and manipulate can be managed, persisted and
  distributed in a way that allows multiple users to work simultaneously on
  separate machines, and even use different types of interface. To run an
  application in NOF the domain objects need not be part of the NOF and
  ideally should just be plain Java or .Net objects (refered to as POJOs or
  'plain old Java objects'), although they will need to be consistent and
  transparent enough so that their properties and behaviours can be determined
  simply by looking at their definitions. By defining the DOM separately from
  any particular system, specifically the NOF, we can create a portable and
  reusable system.</para>

  <para>The NOF is divided into three distinct parts (see the following
  diagram) that we will look at now. The main part, as far as the application
  developer is concerned, is the Domain Object Model (DOM) with its supporting
  library and container. The server manipulates and manges the DOM, providing
  the necessary services such as persistence and distribution through
  reflection and adapters. Clients - such as command and graphical user
  interfaces, testing frameworks and scripts - indirectly display and
  manipulate the DOM via the server.</para>

  <figure fileref="architecture/nakedobjects.png"
          label="The architecture of the NOF"></figure>

  <subheading>Domain objects and a supporting container</subheading>

  <para>To use the framework a set of domain objects are defined in Java/.Net
  that adhere to number of simple coding convention. These object definitions
  (classes) are made available to the framework using reflection, which is
  used to compile a profile of each class and is used to access the fields and
  behaviours of instances of each type, as is done by the rest of the
  framework. For example a pair of accessor methods (<method>get...</method>
  and <method>set...</method>) might be noted in the profile as an object's
  field, while an <method>action...</method> method could be seen as a
  behaviour that should be made available to the user.</para>

  <para>With such a DOM the NOF has to turn it into an application <note>We
  use the term application to refer to a program that is run to do some work,
  rather than a particular use that you might make of a system - contrast a
  word processor or drawing program with using your web browser to buy a book
  from Amazon or a spreadsheet template to complete an expenses claim</note>.
  To make it into an application the objects in the DOM needs to be:
  accessible so the user can work with them; rendered so the user can see and
  manipulate them; persisted so they are available from one session to next
  session; distributed across the network so multiple users can access them
  and a central server can manage them; control access to them so only the
  authorised users can see and change them; and test them so that we can be
  confident that the application is correct.</para>

  <para>For domain objects to be part of any system there is the need for the
  object to also be able to access the system, despite the need to maintain a
  strong separation between the DOM and the system it runs on. To achieve
  this, while maintaining the separation we suggest providing a the DOM with a
  container that it can use to find instances, make objects persistence and do
  other necessary work that it can't do by itself. Also, if the objects change
  then the container can be informed so that the persistent storage mechanism
  objects can be updated with those changes. This kind of functionality is
  needed irrespective of how the system is implemented so providing an
  interface with these responsibilities means that the NOF can implement that
  interface and therfore make itself available to the DOM without tying the
  DOM into the NOF.</para>

  <para>In addition to the container the DOM objects often need value objects
  <note>see Fowler, Patterns of Enterprise Application Atchitecture</note> for
  common business value such as money, time, quantity etc. Again these are
  common to applications rather than the system so can be provided as part of
  an application library.</para>

  <para>Also, it is useful to be able to mark objects with attributes such as
  transient or persistent, a lookup, or to provide application specific
  exceptions. Again these are all application specific and not part of the
  implementing system, and hence should be part of an application
  library.</para>

  <para>To help application developers make use of the NOF we also provide an
  application library to be used for writing DOMs.</para>

  <subheading>Server</subheading>

  <para>The server makes the DOM useable by providing access to the domain
  objects using reflection and wrapping each in an adapter. A memory
  management and persistent storage layer ensures that objects can be
  saved.</para>

  <minorheading>Reflection</minorheading>

  <para>Once the NOF has a way to reference objects in the DOM and it has an
  understanding of the objects structures it can render them visible to the
  user, persist them to some form of persistent storage, or pass the objects
  over the network. All this can be done using reflection to access the fields
  of an object and invoke their behavious. Reflection is a programming
  facility that allows objects to be accessed dynamically at runtime, rather
  than statically in the system code, as expressed at compile time. For the
  NOF to make use of the DOM the framework uses reflection to identify each
  objects fields or properties and its behaviours, these are the things that
  the user is interested in viewing and using to manipulate an object. The
  reflection component of the NOF needs to be implemented to work with a
  particular style of the DOM objects (rather than the specific definitions of
  each domain object), knowing how their properties and action methods are
  defined, how it flags the different object types, and how it provides
  control over its properties and methods.</para>

  <para>The NOF builds up a specification for each type of domain object and
  uses this to provide the client with access to the domain objects. The NOF
  can then persist and distribute those objects, authorise their use, and test
  the application.</para>

  <minorheading>Adapters and Identifiers</minorheading>

  <para>To allow the NOF to work with the domain objects the framework
  provides an adapter, or proxy, for each object. These adapters are internal
  to the NOF and provide a way for the NOF to work with an domain object whose
  type it does not know. To facilitate distribution and persistence each
  persistent object's adapter is assigned an identifier - refered to as its
  object identifier (OID) - that uniquely identifies an object over space and
  time. By giving objects OIDs two copies of an object on two difference
  machines are known to be the same because their OIDs are same. Similarly in
  the persistent store references to other objects can be stored using OIDs
  instead of memory pointers, which are only valid while objects are in
  memory.</para>

  <minorheading>Objects in memory and in persistent storage</minorheading>

  <para>The object loader manages all objects in memory and affords two core
  services. First, it provides the mapping between a domain object and its
  wrapper, ensuring that only one wrapper ever exists for any one domain
  object. Second, it provides the mapping between an adapter for a persistent
  domain object and its OID that uniquely identifies it.</para>

  <para>The object persistor manages the peristence of objects that need to
  kept across invocations of the virtual machine. When an object needs to be
  persisted it is past to the object persistor. This asks the reflection
  mechanism to provide it with each of the object's fields which it then
  writes to persistent storage. The persistor also loads objects back into
  memory by recreating the requested domain object, retrieving its data, and
  then setting each of its properties through requests to the reflector. The
  persistor supports all the needs of persistence such as saving, updating,
  loading and deleting objects, as well as providing a generalised mechanism
  for searching for objects. Finally it allows the NOF to request that groups
  of persistence requests are treated as a transaction, and hence will be
  persisted in their entirety or not at all.</para>

  <minorheading>Configuration properties</minorheading>

  <para>A set of configuration properties are made available within the NOF,
  allowing any component to look up properties. The configuration can be
  loaded from anywhere, but by default it is loaded from a Java style
  properties files.</para>

  <minorheading>Repository</minorheading>

  <para>A globally accessible repository makes all the core components
  available to all those parts of the NOF that need them. The accessible
  components include the configuration, object loader and persistor, and the
  specification loader.</para>

  <minorheading>Fixtures</minorheading>

  <para>A mechanism is provided with the server that loads in object fixture
  specification and will create a series of objects ready use once the
  framework has started.</para>

  <minorheading>Event handling</minorheading>

  <para>A number of listeners are are available within the NOF that allow the
  framework to notify clients that exceptions have occurred that need to be
  dealt with, that objects have changed, or that there are messages to be
  conveyed to the user.</para>

  <minorheading>Utilities and development tools</minorheading>

  <para>The NOF also provides a number of general utilities such as splash
  window, assert logic (for Java 1.1), logging appenders, performance
  profiling utilities and an exception helper that prints out the full details
  of an exception, even in .Net.</para>

  <para>The NOF provides a number of tools to the developer of the NOF and to
  those extending it. These help to make the framework and its components more
  transparent, showing the developer what state the system is in, and what it
  has been doing. There is a simple debug interface that allows any component
  or subcomponent to provide information via a dialog or window. Dumping the
  content of objects and specifications is provided in helper classes, as well
  as helper classes to do things like generate toString values simply.</para>

  <subheading>Clients</subheading>

  <para>Numerous clients use the server to make the domain objects visible or
  to manipulate them. These include the supplied Graphical User Interface and
  the acceptance testing (XAT) framework.</para>

  <minorheading>User Interface</minorheading>

  <para>To make an object visible a viewing mechanism gets the information
  about what the object that is to be displayed contains and then determines
  how it can display each part. </para>

  <para>To provide the user with the ability to create, access, view and
  manipulate these object a viewing mechanism is automatically created by
  using these profiles to determine how display the objects and how they
  should behave in response to user interactions. For example, in the basic
  user interface, an object's fields are displayed and displayed as edit
  fields or an icon representing a referenced object depending on the type of
  the field; action methods are shown as options on the icon's popup
  menu.</para>

  <para>The reflector provides the NOF with the means to work with the domain
  objects, tranforming the domain object model into an application that the
  user can interact with, and NOF can manage, persist and distribute. The
  reflector must analyse each class that is used within the system to
  determine what fields or properties it has and what behaviours it offers.
  These are then advertised to the NOF ready for request to be made. When the
  NOF wishes to interogate an object or manipulate it, e.g. in response to a
  user action, the reflector is asked to do the work.</para>

  <para>The viewer is not such much a component as a client of the framework.
  Like all clients of the framework it uses the components just described to
  access and manipulate the objects in the domain model. A viewer's job is to
  render visible the domain objects to a user, and provide the user with means
  to modify the objects and invoke methods on them. All this is done via the
  reflector without direct access with the domain objects.</para>

  <minorheading>Testing</minorheading>

  <para>Like the viewer, the testing framework makes use of the NOF and
  effectively pretends that it is a user interface. The tests describe each
  step in generalised fashion and the XAT Framework executes these
  instructions manipulating the underlying domain objects. Having manipulated
  the objects the tests then assert that certain conditions have been met.
  Additional manipulations and assertions can then be undertaken further
  testing the system in an incremental fashion. If all conditions are met then
  the test passes, otherwise it will fail indicating that more work is
  required. The tests are written using an extended <weblink
  address="http://junit.org">Junit</weblink> framework so the results are
  normally displayed as green or red bar.</para>

  <subheading>Dealing with Other Concerns</subheading>

  <para>The above descriptions do not discuss the other concerns that need to
  be addressed in an enterprise system, such as security, distribution and
  transactional integrity. All of these, and others, are dealt with in the NOF
  by adapting the components we have already discussed so that they can
  perform the needed work.</para>

  <minorheading>Distribution</minorheading>

  <para>To allow the application to work across multiple tiers the NOF
  distributes requests made to the clients object persistor and reflector,
  passing them across to a remote machine instead of invoking them locally.
  Using the reflection mechanism the NOF is able to serialize and deserialize
  objects and pass them across the network. The domain objects are replicated
  so that the client only holds a copy of the objects that are in use. By
  selectively forwarding requests work that needs to done on the server, such
  as executing business behaviour, is passed onto the server for execution.
  Other tasks, such as determining whether an action can be invoked, can be
  executed on the client as all the necessary information is to hand.</para>

  <minorheading>Transactions</minorheading>

  <para>The object persistor has start, end and abort methods to tell the
  underlying persistent storage to group together requests into atomic units.
  The transaction demarcation methods need to be called by the NOF to create
  the transactions. By modifying the reflection mechanism we can start and
  stop transactions at suitable points such as the start and end of an action
  method.</para>

  <minorheading>Security</minorheading>

  <para>Providing control over who can access the domain objects and what
  properties and behaviours are available is achieved by modifiying the
  reflection mechanism to check each reflective request. The reflector will
  then only make available those fields and behaviours that the security layer
  allows.</para>

  <minorheading>Localisation and Help</minorheading>

  <para>In addition to security the reflection mechanism can also intercepts
  requests for names and descriptions of field and behaviours and return
  internationalized version, allowing an application to be localised, and help
  to be externalised.</para>
</section>