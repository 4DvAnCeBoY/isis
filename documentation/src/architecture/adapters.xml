<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../documentation.dtd">
<section label="adapters">
  <title>Adapters and Identifiers</title>

  <para>Adapters allow the NOF to represent all the different types of object
  in the domain model, to manipulate, distribute and persist the domain
  objects. Through the adapters the domain objects take on a known interface
  that the rest of the NOF knows about, and is programmed to, hence the
  framework can then work with those objects through the adapters. The NOF
  works with three types of objects: value objects, reference objects and
  collections.</para>

  <para><em>Value objects</em> tend to be small objects that don't reference
  other objects, and whose state is commonly editable via the keyboard, or
  more precisely by parsing a string; this also allows them to be persisted as
  strings. Value objects are do not have an identity like the reference
  objects do. Finally, value objects are not shared in same way, so that two
  fields with the same value will use two value objects to represent
  them.</para>

  <para><em>Reference objects</em> are objects that reference other objects
  (value, reference and collection types), have user invokable behaviours, and
  have their own unique identifier when they are persistent. We say that a
  reference object has a set of fields or properties and actions; the identity
  is an internal aspect.</para>

  <para><em>Collection objects</em> are similar to reference objects except
  they hold a set of references instead of a number of disparate
  fields.</para>

  <para>Each type of domain object is given an adapter when it is used by the
  NOF. Adapters must be created by the <see
  label="oibject-loader"><class>NakedObjectLoader</class></see> and not
  instantiated directly. The loader will ensure that only one adapter is
  created for any particular domain object, as having more than one adapter
  will cause issues. All the adapter interfaces extend from the interface
  <class>Naked</class> as shown below.</para>

  <inline-graphic fileref="adapter-classes.jpg"></inline-graphic>

  <subheading>Adapters</subheading>

  <para>There are specific types of adapter for each type of domain object.
  Every adapter is able to tell you what domain object is adapting, provide a
  specification for that type of object, and provide a title for that
  object.</para>

  <javadoc class="Naked" package="???"></javadoc>

  <minorheading>Value object adapters</minorheading>

  <para>Value objects are integrated using <class>NakedValue</class> adapter
  classes. This type of adapter is responsible for managing user entry by
  parsing a string to set up or create a domain value object. If the string
  entry is not valid then an InvalidEnrtyException can be thrown to indicate
  this, and to acknowledge that the adapted value has not been modified. If
  the value can be cleared then the adapter should flag this by returning true
  from the canClear method and clear the value when clear is called.
  Consequently the isEmpty method should then return true to show that the
  value is empty. Not all values support the concept of empty hence it is
  possible to turn off this feature. The other responsibility of value
  adapters is to provide encode and decode functionality to allow simple
  persistence and distribution. Note that this is not the same as getting the
  title string and parsing it, as the formatting of the text string might vary
  between platform due to locale; dates are a good example of this.</para>

  <para>There is a series of specific value adapter interfaces defined within
  the NOF. These allow common types like integers, booleans and strings to be
  recognised by the framework. The interfaces are:
  <class>BooleanValue</class>, <class>ByteValue</class>,
  <class>CharValue</class>, <class>ColorValue</class>,
  <class>DateValue</class>, <class>DoubleFloatingPointValue</class>,
  <class>FloatingPointValue</class>, <class>IntegerValue</class>,
  <class>LongValue</class>, <class>MultilineStringValue</class>,
  <class>PasswordValue</class>, <class>ShortValue</class> and
  <class>StringValue</class>, which are all in the package
  <class>org.nakedobjects.object.value</class>. The framework provide
  implementations of some of these for the primitives provided by Java and for
  the <class>java.lang.String</class> class, these are:
  <class>BooleanAdapter</class>, <class>ByteAdapter</class>,
  <class>CharAdapter</class>, <class>DateAdapter</class>,
  <class>DoubleAdapter</class>, <class>FloatAdapter</class>,
  <class>IntAdapter</class>, <class>LongAdapter</class>,
  <class>ShortAdapter</class> and <class>StringAdapter</class>, which are all
  in the package <class>org.nakedobjects.object.value.adapter</class>.</para>

  <javadoc class="NakedValue" package="???"></javadoc>

  <minorheading>Collection adapters</minorheading>

  <para>Collections are integrated using <class>NakedCollection</class>
  classes. This type of adapter is responsible providing the NOF with the
  elements of a collection (as adapted objects of course). A special
  subinterface that is very commonly used with systems is the
  <class>TypedNakedCollection</class>, which is used for typed collection
  (those that can only store a specific type of object).</para>

  <comment>need to note that these interfaces are based on
  NakedReference</comment>

  <javadoc class="NakedCollection" package="???"></javadoc>

  <javadoc class="TypedNakedCollection" package="???"></javadoc>

  <minorheading>Reference object adapters</minorheading>

  <para>Reference objects are integrated using <class>NakedObject</class>
  classes. This type of adapter is responsible providing the NOF with access
  to the fields and action methods of the domain objects. For each field the
  NOF is able to get hold of its contents (suitably adapted), set its content
  and initialise it contents. (The difference between setting and intialising
  a field is the extent to which other objects are affected, when setting,
  associated object are also set up and the object is marked as dirty, but
  when initialised only the field is set and it is not marked as dirty.) For
  each field the NOF can also find out if it is visible, currently usable or
  if it is valid to set the field with a specified value.</para>

  <para>Similarly for each method. The NOF is able to execute a specific
  method, and can determine if it is visible, currently usable or if it is
  valid to execute it with the specified set of parameters.</para>

  <comment>need to note that this interface is based on
  NakedReference</comment>

  <javadoc class="NakedObject" package="???"></javadoc>

  <para></para>

  <subheading>Object IDs and Java references</subheading>

  <para>The relationship between the objects held by the object store, their
  Java references, and the Naked Objects OID is an important one, and must be
  maintained while an object remains in working memory. That is, while an
  object is in working memory any requests to the persistor for that object
  (using its OID) must return that same object, i.e. the same Java instance.
  The persistor must, therefore, store business objects and be able to return
  an object given its OID.</para>

  <para>When an object is no longer being referenced it can be removed from
  working memory. When it is needed next it will have to be restored from the
  persistent mechanism and placed back in working memory.</para>

  <para>Failure to do this will result in more than one Java object being in
  use for the same naked object.</para>

  <para>The following two methods from the <class>NakedObjectPersistor</class>
  must be implemented (these method are already implemented in
  <class>AbstractObjectStore</class>):-</para>

  <list>
    <para><code>public boolean isInWorkingMemory(Object oid)</code> determines
    if the specified object is currently held by the cache, returning
    <code>true</code> if it is.</para>

    <para><code>public void dispose(NakedObject object)</code> removes the
    specified object from working memory. This method should only be called
    when an object is no longer being referenced within working memory.</para>

    <para><code>public NakedObject recreateObject(ExternalOid oid)</code>
    recreates the object that is identified by the external OID.</para>
  </list>

  <para></para>

  <para></para>

  <subheading>The naked object lifecyle</subheading>

  <para>To put this into context we will briefly examine the lifecyle of a
  domain object that is persisted within the NOF. This should be contrasted
  with the simple lifecyle that Java objects have where each object is created
  when required (using the <code>new</code> operator) and is garbage collected
  and finalized when it no longer has any references to it. The need to be
  able to persist objects so that they can be removed from working memory and
  be restore later, often in a different invocation of the virtual machine,
  complicates this by requiring new objects to be made explicitly persistent
  and then when they are no longer required to explicitly delete them. An
  added complexity is that the objects are not necessarily in working memory
  even though they exist within the persistent mechanism. The full life cycle
  is as follows:-</para>

  <list>
    <item2>
      <label>new</label>

      <para>All new objects are transient and are not immediately added to the
      persistence mechanism.</para>

      <para>New objects are instantiated using the <code>new</code> operator,
      or the <method>newInstance</method> method in <class>Class</class>.
      After a naked object is first created, however, its
      <method>created</method> method should be called. This normally happens
      within Naked Objects as the objects are usually created by the user
      selecting the <menu>New Instance...</menu> menu item on the class icon
      or the programmer invoking the static <method>createInstance...</method>
      methods in the <class>AbstractNakedObject</class> class.</para>

      <para>A transient object need never move on to the next stage, but
      unless it does it can not be referenced by other persistent
      objects.</para>
    </item2>

    <item2>
      <label>persistent</label>

      <para>A transient object is made <term>persistent</term> by calling its
      <method>makePersistent</method> method. This adds the object to the set
      of retrievable objects by placing it within the persistent mechanism and
      gives the object an OID. This normally also occurs as part of the
      <menu>New Instance...</menu> menu option or by another explicit action
      by the user. This method is also invoked by the
      <method>createInstance</method> method but not by
      <method>createInstanceTransient</method>.</para>

      <para>The newly persistent object can now be referenced by other
      persistent objects.</para>
    </item2>

    <item2>
      <label>dirty</label>

      <para>Whenever an object is changed - its values are edited or
      associations are added or removed - then the object becomes
      <term>dirty</term>. Object changes will occur through editing fields,
      dropping and removing objects from fields and during some action method
      invocations. The programmer can explicitly tells an object that it has
      changed during a method invocation by calling its
      <method>objectChanged</method> method. In response to an object being
      changed the data in the persistent store is updated.</para>
    </item2>

    <item2>
      <label>restored</label>

      <para></para>
    </item2>

    <item2>
      <label>resolved</label>
    </item2>

    <item2>
      <label>destroyed</label>

      <para>An object is <term>deleted</term> by calling its
      <method>destroy</method> method. At this point the object will no longer
      be persisted. The user normally deletes an object by selecting the
      <menu>Destroy</menu> option for that object.</para>
    </item2>
  </list>

  <para>In addition to these four main states a persistent object can be in
  two minor states:-</para>

  <list>
    <para>An object that does not yet have its data loaded and its
    associations set is <term>unresolved</term>.</para>

    <para>Once an unresolved object has had it data loaded and its association
    recreated it is <term>resolved</term>. The loading of data is requested by
    invoking the objects <method>resolve</method> method.</para>

    <el>test element</el>
  </list>
</section>