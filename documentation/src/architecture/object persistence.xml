<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../documentation.dtd">
<section>
  <title>Object Persistence</title>

  <para>One of the key issues with Naked Objects is how its domain objects are
  persisted. Applications designed to work with the NOF are designed around
  objects whereas most persistence mechanisms currently look at all storage
  requirements as data. Add to this is the common requirement that these
  conventional data stores, such as relational databases, must be an integral
  part of any development, then it is important to bridge this divide and
  convert or map from one to the other. Again, the framework provides an
  interface that allows the rest of the NOF to save domain objects to any type
  of persistence mechanism. This section looks at how a persistence mecahnism
  must work and what is needed to implement such an interface.</para>

  <para><class>NakedObjectPersistor</class> is the interface to one of the
  core mechanisms in the NOF and is charged with persisting all the objects it
  is told about. How it persists these objects is independent of the rest of
  the framework, and can be achieved by writing the objects to files,
  connecting to relational or object databases, delegating the requests to
  other persistent mechanisms, or by passing on the requests on to another
  <class>NakedObjectStore</class>. It is even possible just to store the
  objects in memory (assuming your hardware and software is reliable), as long
  as the client can be shut down and started up again and is still be able to
  access the data.</para>

  <para>To provide the services specified by the
  <class>NakedObjectPersistor</class> interface any implemention must be
  capable of persisting business objects and collections, managing the
  relationships between those objects and maintaining the resulting sets of
  instances. Persisting the objects means that we need a way to create,
  retreive, update and delete the business objects (commonly refered to as the
  CRUD operations) wihin long term storage, storing all the values and
  relationships of each object. Managing the relationships means that we need
  to use some form of identifiers for each object, instead of the simple
  memory addresses, to reference the other objects. The sets of instances for
  each type of object also needs to be maintained so the persistor can make
  all objects available to the user.</para>

  <subheading>How the Persistor Works</subheading>

  <para>The pivotal role of the persistor is to take a domain object and
  preserve its data. Later, when that object is requested, most likely after
  the original object has been removed from working memory, the persistor
  should be able to recreate and return the object in its original state.
  Ideally, a specific <class>NakedObjectPersistor</class> implementation
  should be able to persist any domain object, even those of a type it has not
  seen before. Often this is possible, but if existing data structures are
  being used then they will normally be a need for some manual
  configuration.</para>

  <para>How an object's data is stored is specified by the persistor and this
  must relate to, and work with, the chosen persistence mechanism. As most
  persistence mechanisms can't store objects directly some form of mapping of
  the object's data to the persistence mechanism's data is required. This
  mapping is usually achieved reflectively.</para>

  <para>Objects held by the persistor should be held separately, that is, the
  object's whole <term>graph</term> should not stored as a part of the object,
  where the object graph is the object itself, the objects it refers to and
  the objects that they in turn refer to, and so on. To maintain the
  relationships that exist within the graph each object is, therefore,
  assigned a unique identifier (which we refer to these as the <term>Object
  Identifier</term> or OID) and any real references are then replaced, within
  the object store, by the referenced object's OID. Then to retrieve an object
  from the persistor it must be requested by specifying the object's
  OID.</para>

  <inline-graphic fileref="no-systems/references.png">
    <description>Diagram showing a normal java object referring (show
    addresses) to other objects and how this is done in the object store. This
    would show the reference replaced by OID object and no explicity links to
    the other objects - showing the objects in isolation.</description>
  </inline-graphic>

  <para>When an object is retreived from persistent memory we would expect
  that object to be in the same state as when we saved it, and for its related
  objects to be retreived also, i.e. the ones within its graph. Thefore, we
  need the NOF to ensure that for every object we explicitly retrieve it
  retrieves any objects that we might be able to reach, via any references,
  before we actually use those referenced objects. For example, a booking
  object displays its fields - a city, pick up and drop off locations etc. -
  when it is shown in an an open representation, such as a form, rather than a
  closed one, such as an icon. The NOF must therefore retrieve the related
  <class>City</class> and <class>Location</class> objects as well as the
  <class>Booking</class> object that was requested. The recreation of the
  object graph, however, could be limited to only those nodes that are
  required, i.e. the city objects held by the two locations need not be
  retreived.</para>

  <para>The persistor must, therefore, be able to retrieve an object given its
  OID. The data for the requested object should be solicited from the
  persistor and all the value objects initialised using the relevant data.
  Associationed objects should be recreated (or retrieved from the cache if
  they exist there) by instantiating an object of the required type and
  setting its OID, but no other data need be read in or set up within the
  associated object. At the end of the request we will have, in working
  memory, the requested object complete with all its value data and references
  to all the objects that it did when it was persisted. The fact that all the
  referenced objects are not necessarily in same state as when they where
  persisted is minor inconvenience and can be resolved later, before those
  objects are ever used.</para>

  <para>When a restored object is used within the framework, e.g. when
  displayed, it will probably need to access its referenced objects.
  Associated objects, however, might not contain any of their data yet. If
  they are accessed through a properly processed accessor method then the
  object's missing data will be restored (this is why when using the NOF's
  default Java reflector you must have the <method>resolve</method> method
  call in your association accessors). The persistor must respond, therefore,
  to such requests to set up the associated object and, if the object is not
  already marked as resolved, load the data for that object and re-initialise
  the object so its values and associations are set up. Each association
  should then either refer to its the relevant cached object, if it was
  already held by the cache, or to a newly created object of the proper type
  with its OID properly set. The object itself should then be marked as
  resolved while its uncached associations should be left as unresolved. An
  associated object can subsequently also be resolved by asking the persistor
  to complete the object's loading, thereby assuring that its data has been
  loaded.</para>

  <inline-graphic fileref="no-systems/resolving.png">
    <description>Diagram showing unresolved object and transition to resolved
    object.</description>
  </inline-graphic>

  <para>When an object should be no longer kept then it has to be explicitly
  removed from the set of persistent objects. The
  <class>NakedObjectPersistor</class> provide a specific method to request
  this, but it should be remembered that while removing an object is normally
  a straight forward process, ensuring that other objects do not currently
  refer to it, and, hence, will subsequently have an invalid reference, is
  another matter entirely and must be catered for within the persistor
  implementation.</para>

  <subheading>Using the persistor</subheading>

  <para>The main user of the persistor is the framework itself. As it manages
  the objects on behalf of the user it will call the
  <class>NakedObjectPersistor</class> with request persist objects.</para>

  <minorheading>Object persistence methods</minorheading>

  <para>The persistence of an object must be guaranteed by implementing the
  following methods of the <class>NakedObjectPersistor</class> interface. This
  is offen refered to as the <term>CRUD</term> functionality - Create,
  Retrieve, Update and Delete - and is to be provided by the
  <method>makePersistent</method>, <method>getObject</method>,
  <method>saveChangee</method> and <method>destroyObject</method> methods
  respectively. There are also a number of metods to refresh objects that
  might have changed, as well lazily load object.</para>

    <block>
      <label><class>makePersistent(NakedObject)</class></label>

      <para>makes a naked object persistent. The specified object will have an
      OID created for it, be stored in some persistent medium, and then once
      it has been stored should have the OID assigned to it by calling the
      objects <method>setOid</method> method. The object, with its OID set,
      should also be added to the cache.</para>

      <para>If the object has any associations (either one-to-one or
      one-to-many) then each of these, that aren't already persistent, should
      also be made persistent.</para>
    </block>

    <block>
      <label><class>objectChanged(NakedObject)</class></label>

      <para>add the specified object to list of objects that needs to be saved
      when <method>savChanges()</method> is called..</para>
    </block>

    <block>
      <label><class>saveChanges()</class></label>

      <para>updates the changed object in the persistent medium.</para>
    </block>

    <block>
      <label><code>destroyObject(NakedObject)</code></label>

      <para>removes the specified object from the set of persistent
      objects.</para>
    </block>

    <block>
      <label><code>getObject(Oid, NakedObjectSpecification)</code></label>

      <para>retrieves the object identified by the specified OID from the
      object store. The loaded objects should be checked first and, if the
      object is cached, the cached version should be returned. It is important
      that if this method is called again, while the originally returned
      object is in working memory, then this method must return that same
      adapter.</para>

      <para>Assuming that the object is not cached then the data for the
      object should be retreived from the persistent medium and the object
      recreated and an adapter created. The specified OID should then be
      assigned to the adapter before returning the object. Also it resolve
      state should be properly specified.</para>

      <para>If the persistor does not known of an object with the specified
      OID then a <class>ObjectNotFoundException</class> should be
      thrown.</para>
    </block>

    <block>
      <label><code>reload(NakedObject)</code></label>

      <para>re-retrieves the specified object's data from the persistent store
      and updates the attributes of the object. This is used when an object on
      a user screen has been changed by another user and is therefore out of
      date.</para>
    </block>

    <block>
      <label><code>resolveImmediately(NakedObject)</code></label>

      <para>initialises the fields of an object that have not yet been set up.
      This method should return immediately if the object's resolved state is
      already set to 'resolved'. If the object is in a 'ghost' or
      'part-resolved' state then the object's data should be retreieved from
      the persistent store and used to set up the value objects and
      associations. The object should be set up in the same manner as in
      <method>getObject</method> above.</para>
    </block>

    <block>
      <label><code>resolveField(NakedObject, NakedObjectField)</code></label>

      <para>initialises the specified field of the specified object,
      especially a collection. This method should return immediately if the
      referenced object's resolved state is already set to 'resolved'. If the
      object is in a 'ghost' or 'part-resolved' state then the object's data
      should be retreieved from the persistent store and used to set up the
      value objects and associations. The object should be set up in the same
      manner as in <method>getObject</method> above.</para>
    </block>

  <minorheading>Managing instances</minorheading>

  <para>Naked Objects provides access to each and every instance of every type
  of domain object within the system. Again, it is the persistor that
  shoulders the burden of compiling the instances and making them available on
  request. A set of instances (as opposed to all instances) for a specific
  type are requested by supplying a criteria object.</para>

  <para>Instances are returned as an array but are normally then made
  available through the <class>InstanceCollection</class> class. The instance
  collection differs from other collections in that does not allow the adding
  or removing of objects.</para>

  <para>To support the accessing of the instances the persistor must implement
  the following methods. Each method should generate the same result for
  successive calls where no new instances have been persistent or existing
  ones destroyed.</para>

    <block>
      <label><class>boolean hasInstances(NakedObjectSpecification
      specification)</class></label>

      <para>Checks whether there are any instances of the specified
      type.</para>
    </block>

    <block>
      <label><class>int numberOfInstances(NakedObjectSpecification
      specification)</class></label>

      <para>Determines how many instances of the specific type there
      are.</para>
    </block>

    <block>
      <label><class>TypedNakedCollection allInstances(NakedObjectSpecification
      specification, boolean includeSubclasses)</class></label>

      <para>Get hold of all instances of the specified type, including
      instances of any subclasses if specified by the include flag.</para>
    </block>

    <block>
      <label><class>TypedNakedCollection findInstances(InstancesCriteria
      criteria)</class></label>

      <para>Find all the instances that match the specified criteria
      object.</para>
    </block>

  <comment>TODO Add in details about InstancesCriteria</comment>

  <minorheading>Transactions</minorheading>

  <para>A transaction groups a set of operations together so that they are
  executed as single operation, i.e. all complete successfully or none
  complete at all. In Naked Objects each user action, as seen by the
  framework, is deemed to be a transaction, for example, the selection of a
  menu option, the droping of an object into a field or the editing of a
  value. The <method>startTransaction</method> method is called as the action
  is started and <method>endTransaction</method> is called after it completes.
  If an exception is thrown after <method>startTransaction</method> was called
  then <method>abortTransaction</method> will be called instead of
  <method>endTransaction</method>.</para>

    <block>
      <label><class>void startTransaction()</class></label>

      <para>starts a transaction. The persistor should tell the persistor
      (assuming it supports transactions) that a transaction is
      starting.</para>
    </block>

    <block>
      <label><class>void endTransaction()</class></label>

      <para>ends the transaction. The persistor should tell the persistor
      (assuming it supports transactions) that a transaction has ended
      succesfully.</para>
    </block>

    <block>
      <label><class>void abortTransaction()</class></label>

      <para>aborts the transaction. The persistor should tell the persistor
      (assuming it supports transactions) that a transaction has failed and
      that all changes need to be reversed/undone.</para>
    </block>

  <minorheading>Other methods</minorheading>

  <para>In addition to the <class>NakedObjectPersistor</class> methods that
  directly interact with the persistor there are also methods that support the
  object store, which also need to be implemented. As for the cache most of
  these are already implemented in <class>AbstractObjectStore</class>, but are
  listed here for completeness.</para>

    <block>
      <label><class>void init()</class></label>

      <para>initialises the object store. The persistor should initialise
      itself by connecting to resources it will require, and log any opening
      comments.</para>
    </block>

    <block>
      <label><class>void shutdown()</class></label>

      <para>shuts down the object store. The persistor should take this as a
      signal to disconnect itself from any services it is using, dispose of
      any objects in the cache and free up resources. There should be no more
      requests after this has been invoked.</para>
    </block>

    <block>
      <label><class>void reset()</class></label>

      <para>restart the persistor.</para>
    </block>

  <subheading>Installation</subheading>

  <para>The naked objects repositry needs to have an object persistor
  installed. To install the persistor call the
  <method>setObjectPersistor</method> method on <class>NakedObjects</class>
  passing in an instance of
  <class>org.nakedobjects.object.NakedObjectPersistor</class>.</para>

  <program-listing>objectPersistor = new Persistor();
:
:
NakedObjects.setObjectPersistor(objectPersistor);</program-listing>
</section>