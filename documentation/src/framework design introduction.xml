<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "./documentation.dtd">
<section>
  <title>Introduction - the Naked Objects Framework</title>

  <description>A look at the Naked Objects Framework and how it
  works</description>

  <para>The Naked Objects Framework (NOF) transforms a domain object model
  (DOM) into an application that the user can interact with, and the objects
  the users create and manipulate can be managed, persisted and distributed in
  a way that allows multiple users to work simultaneously on separate
  machines, and even use different types of interface.</para>

  <subheading>Separating Concerns</subheading>

  <para>To run an application in NOF the domain objects need not be part of
  the NOF and should ideally just be plain Java or .Net objects (refered to as
  POJOs, plain old Java objects), although they will need to be consistent and
  transparent enough so that their properties and behaviours can be determined
  simply by looking at their definitions. By defining the DOM separately from
  any particular system, specifically the NOF, we can create a portable and
  reusable system.</para>

  <para>To use the framework a set of domain objects are defined in Java/.Net
  that adhere to number of simple coding convention. These object defintions
  (classes) are made available to the framework using reflection, which is
  used to compile a profile of the class and is used to access the fields and
  behaviours of instances of that type, as is done by the rest of the
  framework. For example a pair of accessor methods (<method>get...</method>
  and <method>set...</method>) might be noted in the profile as an object's
  field, while an <method>action...</method> method is seen as a behaviour to
  offer to the user.</para>

  <figure fileref="architecture/nakedobjects.png"
          label="The architecture of the NOF"></figure>

  <para>With such a DOM the NOF has to turn it into an application
  <comment>this term is probably wrong</comment>. To make it an application
  the objects in the DOM need to be accessible so the user can work with them,
  rendered so the user can see and manipulate them, persisted so they are
  available from one session to next session, distributed across the network
  so multiple users can access them and a central server can manage them,
  control access to them so only the authorised users can see and change them,
  and test them so that we can be confident that the application is
  correct.</para>

  <para>For such objects to be part of any system there are few needs of the
  object to access the system, depite such a strong separation being matained.
  To achieve this, and to keep the system separated we suggest providing a the
  DOM with a container that it can use to find instances or make objects
  persistence. Also if objects change then the container can be informed so
  that the persistent objects can be updated. This kind of functionality is
  needed irrespective of how the system is implemented so providing an
  interface with these responsibilities means then NOF can implement that
  interface and therfore make itself available to the DOM without tying the
  DOM into the NOF.</para>

  <para>In addition to the container the DOM objects often need value objects
  (see Fowler, PEAA) for common business value such as money, time, quantity
  etc. Again these are common to application rather than the system so can be
  provided as part of an application library.</para>

  <para>Also, it is useful to be able to mark objects with attribute such as
  transient or persistent, a lookup, or to provide application specific
  exceptions. Again these are all application specific and not part of the
  implementing system, and hence should be part of an application
  library.</para>

  <subheading>Reflection</subheading>

  <para>To enable the NOF to make use of the DOM the framework uses reflection
  to identify each objects fields or properties and its behaviours, theses are
  the things that the user is interested in viewing and using to manipulate an
  object. The reflection component of the NOF needs to be designed to work
  with the DOM objects, knowing how it properties are defined, how its action
  methods are defined, how it flags different object types, and how it
  provides control over its properties and methods.</para>

  <para>The NOF runs the application providing the user with access to the
  objects, persisting and distributing the objects, authorising usage, and
  testing the application.</para>

  <subheading>Object Adapters and Object Identity</subheading>

  <para>To deal with domain objects the NOF provides an adapter, or proxy, for
  each object. These adapters are internal to the NOF and provide a way for
  the NOF to work with an domain object whose type it does not know. To
  facilitate distribution and persistence each persistent object's adapter is
  assigned an identifier - refered to as its object identifier (OID) - that
  uniquely identifies an object over space and time. By giving objects OIDs
  two copies of an object on two difference machines are known to be the same
  because their OIDs are same. SImilarly in the persistent store references to
  other objects can be stored using OIDs instead of memory pointers, which are
  only valid while objects are in memory.</para>

  <para>The object loader deals with these requirements, providing two core
  services. First, it provides the mapping between a domain object and its
  wrapper and ensures that only one wrapper ever exists for any one domain
  object. Second, it provides the mapping between an adapter for a domain
  object that is persistent and its OID that uniquely identifies it.</para>

  <subheading>User Interface</subheading>

  <para>Once the NOF has a way to reference objects in the DOM and it has an
  understanding of the objects structures it can make them visible to user,
  render them, or persist them to some form of persistent storeage, and pass
  the objects over the network. All this can be done using reflection to
  access the fields of an object and invoke their behavious. Reflection is a
  programming facility that allows objects to be accessed dynamically at
  runtime, rather than statically in the system code, as expressed at compile
  time. To make an object visible a viewing mechanism gets the information
  about what the object that is is displaying contains and then determines how
  it can display each part.</para>

  <para>To provide the user with the ability to create, access, view and
  manipulate these object a viewing mechanism is automatically created by
  using these profiles to determine how display the objects and how they
  should behave in response to user interactions. For example, in the basic
  user interface, an object's fields are displayed and displayed as edit
  fields or an icon representing a referenced object depending on the type of
  the field; action methods are shown as options on the icon's popup
  menu.</para>

  <para>The reflector provides the NOF with the means to work with the domain
  objects, tranforming the domain object model into an application that the
  user can interact with, and NOF can manage, persist and distribute. The
  reflector must analyse each class that is used within the system to
  determine what fields or properties it has and what behaviours it offers.
  These are then advertised to the NOF ready for request to be made. When the
  NOF wishes to interogate an object or manipulate it, e.g. in response to a
  user action, the reflector is asked to do the work.</para>

  <para>The viewer is not such much a component as a client of the framework.
  Like all clients of the framework it uses the components just described to
  access and manipulate the objects in the domain model. A viewer's job is to
  render visible the domain objects to a user, and provide the user with means
  to modify the objects and invoke methods on them. All this is done via the
  reflector without direct access with the domain objects.</para>

  <subheading>Persistence</subheading>

  <para>When an object needs to be persisted it is past to the object manager.
  Using the same techniques, the object manager asks the reflection layer to
  provide it with each of the object's fields which it then writes out to the
  persistent store. The OM also loads objects back into memory, loading in an
  object's data, recreating the domain object and then setting each of its
  properties via requests to the reflector. The OM supports all the needs of
  persistence such as saving, updating, loading and deleting objects, in
  addition it also allows for objects to be searched for, and transactions to
  be used. <comment>what do we mean by used?</comment></para>

  <para></para>

  <para>The object manager takes care of the persistence of the domain
  objects. This covers the creation of new objects, removal of old ones,
  updaing of existing ones, and the retrieval of persisted objects back into
  memory - individually, as instances of a particulay class, or as defined by
  some criteria. In addition to these tasks the object manager responsible for
  maintaining transactional integrity, and must provide the ability to
  demarcate transaction and provide rollback if necessary. In the NOF every
  user directed change of an doman object and every invocation of an action
  method is seen as a transaction.</para>

  <para>The main implementation of the object manager deals with the basic
  requirements of the object manager and then delegates those explicitly
  requiring persistence to an object store subcomponent. This deals with the
  issues of persistence....</para>

  <subheading>Distribution</subheading>

  <para>To allow the application to work across multiple tiers the NOF
  distributes requests to the object manager and reflector, passing the
  request to a remote machine instead of invoking it locally. Using the
  reflection mechanism the NOF is able serialize and deserialize objects and
  pass them across the network.</para>

  <para></para>

  <para>Distributing the NOF over multiple tiers is accomplished not through a
  specific component, but through the implementations of specific components,
  namely the object manager and the reflector, which forward their requests to
  a server and awaits a response. The domain objects are replicated so that
  the client only holds a copy of the objects that are in use. By selectively
  forwarding requests work that needs to done on the server, such as executing
  business behaviour, is passed onto the server for execution. Other tasks,
  such as determining whether an action can be invoked, can be executed on the
  client as all the necessary information is to hand.</para>

  <subheading>Security</subheading>

  <para>Providing control over who can access the domain objects and what
  properties and behaviours are available is achieved by getting the
  reflection mecahism to check each reflective request. The reflector will
  only make available those fields and behaviours that the security layer
  allows.</para>

  <subheading>Localisation</subheading>

  <para>In addition to security the reflection mechanism can also intercepts
  requests for names and descriptions of field and behavious and return
  internationalized version, allowing an application to be localised.</para>

  <subheading>Testing</subheading>

  <para>Like the viewer the testing framework makes use of the NOF and
  effectively pretends that it is a user interface. The tests describe each
  step in generalised fashion and the XAT Framework exececutes those steps
  manipulating the underlying domain objects. Having manipulated the objects
  the tests then assert that certain conditions are met. Additional
  manipulations and assertions can be undertaking. If all conditions are met
  then the test passes, otherwise it will fail. The tests are written using an
  extended Junit framework so the results are normally displayed as green or
  red bar.</para>

  <subheading>Configuration</subheading>

  <para>The NOF is configured in two ways. First, the components are
  instantiated and wired together either programmatically or via some kind of
  configuration such as Spring. Second, a set of configuration properties are
  made available within the NOF, allowing any component to look up properties.
  The configuration can be loaded from anywhere, but by defualt it is loaded
  from a Java style properties files.</para>
</section>